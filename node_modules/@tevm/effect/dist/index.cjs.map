{"version":3,"sources":["../src/createRequireEffect.js","../src/fileExists.js","../src/logAllErrors.js","../src/parseJson.js","../src/resolve.js"],"names":["tryEffect","createRequire","map","logDebug","flatMap","promise","access","constants","tap","all","e","logError","parse","trySync","resolve","effectAsync","fail","succeed"],"mappings":"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","file":"index.cjs","sourcesContent":["import { createRequire } from 'node:module'\n// TODO unused move this to @tevm/createRequire package\nimport { map, try as tryEffect } from 'effect/Effect'\n\nexport class CreateRequireError extends Error {\n\t/**\n\t * @type {'CreateRequireError'}\n\t */\n\t_tag = 'CreateRequireError'\n\t/**\n\t * @param {string} url\n\t * @param {object} [cause]\n\t * @param {unknown} [cause.cause]\n\t * @internal\n\t */\n\tconstructor(url, options = {}) {\n\t\tsuper(`Failed to create require for ${url}`, options)\n\t}\n}\n\nexport class RequireError extends Error {\n\t_tag = 'RequireError'\n\t/**\n\t * @param {string} url\n\t * @param {object} [cause]\n\t * @param {unknown} [cause.cause]\n\t * @internal\n\t */\n\tconstructor(url, options = {}) {\n\t\tsuper(`Failed to require ${url}`, options)\n\t}\n}\n\n/**\n * An {@link https://www.effect.website/docs/introduction Effect} wrapper around createRequire\n * createRequire is used to use the node.js `require` function in esm modules and cjs modules\n * in a way that is compatible with both. It also wraps them with Effect for better error handling\n * @param {string} url - url to create require from\n * @returns {import(\"effect/Effect\").Effect<(id: string) => import(\"effect/Effect\").Effect<ReturnType<NodeRequire>, RequireError, never>, CreateRequireError, never>} require function\n * @example\n * ```typescript\n * import { createRequireEffect } from '@eth-optimism/config'\n * const requireEffect = createRequireEffect(import.meta.url)\n * const solcEffect = requireEffect('solc')\n * ```\n * @see https://nodejs.org/api/modules.html#modules_module_createrequire_filename\n * @internal\n */\nexport const createRequireEffect = (url) => {\n\treturn tryEffect({\n\t\ttry: () => createRequire(url),\n\t\tcatch: (cause) => new CreateRequireError(url, { cause }),\n\t}).pipe(\n\t\tmap((createdRequire) => {\n\t\t\t/**\n\t\t\t * Same as require but returns a module as an Effect\n\t\t\t * @param {string} id\n\t\t\t * @returns {import(\"effect/Effect\").Effect<ReturnType<NodeRequire>, RequireError, never>}\n\t\t\t */\n\t\t\tconst requireAsEffect = (id) => {\n\t\t\t\treturn tryEffect({\n\t\t\t\t\ttry: () => createdRequire(id),\n\t\t\t\t\tcatch: (cause) => new RequireError(id, { cause }),\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn requireAsEffect\n\t\t}),\n\t)\n}\n","import { constants } from 'node:fs'\nimport { access } from 'node:fs/promises'\nimport { flatMap, logDebug, promise, tap } from 'effect/Effect'\n\n/**\n * Checks if a file exists at the given path\n * @param {string} path - path to check\n * @returns {import(\"effect/Effect\").Effect<boolean, never, never>} true if the file exists, false otherwise\n * @example\n * ```typescript\n * import { fileExists } from '@eth-optimism/config'\n * await fileExists('./someFile.txt')\n * ```\n * @internal\n */\nexport const fileExists = (path) => {\n\treturn logDebug(`fileExists: Checking if file exists at path: ${path}`).pipe(\n\t\tflatMap(() =>\n\t\t\tpromise(() =>\n\t\t\t\taccess(path, constants.F_OK)\n\t\t\t\t\t.then(() => true)\n\t\t\t\t\t.catch(() => false),\n\t\t\t),\n\t\t),\n\t\ttap((exists) => logDebug(`fileExists: ${path}: ${exists}`)),\n\t)\n}\n","import { all, logError } from 'effect/Effect'\n\n/**\n * Logs all errors and causes from effect\n * @param {unknown} e\n * @returns {import(\"effect/Effect\").Effect<void, never, never>}\n * @internal\n * @example\n * ```typescript\n * import { logAllErrors } from '@eth-optimism/config'\n *\n * someEffect.pipe(\n *   tapError(logAllErrors)\n * )\n */\nexport const logAllErrors = (e) => {\n\tconst errors = [e]\n\tlet nextError = /** @type {Error} */ (e)\n\twhile (nextError.cause) {\n\t\terrors.unshift(nextError.cause)\n\t\tnextError = /** @type {Error} */ (nextError.cause)\n\t}\n\treturn all(errors.map((e) => logError(e)))\n}\n","import { try as tryEffect } from 'effect/Effect'\nimport { parse } from 'jsonc-parser'\n\n/**\n * Error thrown when the tsconfig.json file is not valid json\n * @internal\n */\nexport class ParseJsonError extends Error {\n\t/**\n\t * @type {'ParseJsonError'}\n\t */\n\t_tag = 'ParseJsonError'\n\t/**\n\t * @param {object} [options]\n\t * @param {unknown} [options.cause]\n\t */\n\tconstructor(options = {}) {\n\t\tsuper('Failed to parse tsconfig.json', options)\n\t}\n}\n\n/**\n * Parses a json string\n * @param {string} jsonStr\n * @returns {import(\"effect/Effect\").Effect<unknown, ParseJsonError, never>}\n * @throws {ParseJsonError} when the tevm.json file is not valid json\n * @example\n * ```ts\n * const jsonEffect = parseJson('{ \"compilerOptions\": { \"plugins\": [{ \"name\": \"@tevm/ts-plugin\" }] } }')\n * ````\n * @internal\n */\nexport const parseJson = (jsonStr) => {\n\treturn tryEffect({\n\t\ttry: () => {\n\t\t\tconst errors = /** @type {import(\"jsonc-parser\").ParseError[]}*/ ([])\n\t\t\tconst res = parse(jsonStr, errors, {\n\t\t\t\tdisallowComments: false,\n\t\t\t\tallowTrailingComma: true,\n\t\t\t\tallowEmptyContent: false,\n\t\t\t})\n\t\t\tif (errors.length > 0) {\n\t\t\t\tthrow new AggregateError(errors)\n\t\t\t}\n\t\t\treturn res\n\t\t},\n\t\tcatch: (cause) => new ParseJsonError({ cause }),\n\t})\n}\n","import { async as effectAsync, fail, succeed, try as trySync } from 'effect/Effect'\nimport resolve from 'resolve'\n\n/**\n * @typedef {function(string, import('resolve').SyncOpts & import('resolve').AsyncOpts): import('effect/Effect').Effect<string, CouldNotResolveImportError, never>} ResolveSafe\n */\n\n/**\n * Error thrown when 'node:resolve' throws\n */\nexport class CouldNotResolveImportError extends Error {\n\t/**\n\t * @type {'CouldNotResolveImportError'}\n\t */\n\t_tag = 'CouldNotResolveImportError'\n\t/**\n\t * @type {'CouldNotResolveImportError'}\n\t * @override\n\t */\n\tname = 'CouldNotResolveImportError'\n\t/**\n\t * @param {string} importPath\n\t * @param {string} absolutePath\n\t * @param {Error} cause\n\t */\n\tconstructor(importPath, absolutePath, cause) {\n\t\tsuper(`Could not resolve import ${importPath} from ${absolutePath}. Please check your remappings and libraries.`, {\n\t\t\tcause,\n\t\t})\n\t}\n}\n\n/**\n * Effect wrapper around import('node:resolve').resolveSync\n * @type {ResolveSafe}\n * @example\n * ```ts\n * import {tap} from 'effect/Effect'\n * import {resolveSync} from '@tevm/effect'\n * resolveSync('react').pipe(\n *    tap(console.log)\n * )\n * ````\n * `\n */\nexport const resolveSync = (importPath, options) => {\n\treturn trySync({\n\t\ttry: () => resolve.sync(importPath, options),\n\t\tcatch: (e) => new CouldNotResolveImportError(importPath, options.basedir ?? __dirname, /** @type {Error} */ (e)),\n\t})\n}\n\n/**\n * Effect wrpper around import('node:resolve')\n * @type {ResolveSafe}\n * @example\n * ```ts\n * import {tap} from 'effect/Effect'\n * import {resolveAsync} from '@tevm/effect'\n * resolveAsync('react').pipe(\n *    tap(console.log)\n * )\n * ````\n */\nexport const resolveAsync = (importPath, options) => {\n\treturn effectAsync((resume) => {\n\t\tresolve(importPath, options, (err, resolvedPath) => {\n\t\t\tif (err) {\n\t\t\t\tresume(fail(new CouldNotResolveImportError(importPath, options.basedir ?? '', err)))\n\t\t\t} else {\n\t\t\t\tresume(succeed(/** @type {string} */ (resolvedPath)))\n\t\t\t}\n\t\t})\n\t})\n}\n"]}