import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useQuery } from '@tanstack/react-query';
import { Box, Text, useInput } from 'ink';
import Spinner from 'ink-spinner';
import { option } from 'pastel';
import { useState } from 'react';
import zod from 'zod';
// Import refactored components
import ActionTab from '../components/ActionTab.js';
import HomeTab from '../components/HomeTab.js';
import LogViewer from '../components/LogViewer.js';
import { initializeServer } from '../utils/server.js';
// Import action components
import Call from './call.js';
import GetAccount from './getAccount.js';
import SetAccount from './setAccount.js';
// Add command description for help output
export const description = 'Start an Ethereum JSON-RPC server with TEVM features';
export const options = zod.object({
    port: zod
        .number()
        .default(8545)
        .describe(option({
        description: 'Port to listen on',
        defaultValueDescription: '8545',
    })),
    host: zod
        .string()
        .default('localhost')
        .describe(option({
        description: 'Host to bind to',
        defaultValueDescription: 'localhost',
    })),
    fork: zod
        .string()
        .optional()
        .describe(option({
        description: 'URL of network to fork',
    })),
    chainId: zod
        .string()
        .default('900')
        .describe(option({
        description: 'Use known chain ID',
        defaultValueDescription: '900 (tevm)',
    })),
    forkBlockNumber: zod
        .string()
        .default('latest')
        .describe(option({
        description: 'Set fork block number',
        defaultValueDescription: 'latest',
    })),
    loggingLevel: zod
        .string()
        .default('info')
        .describe(option({
        description: 'Set logging level',
        defaultValueDescription: 'info',
    })),
    verbose: zod
        .boolean()
        .default(false)
        .describe(option({
        description: 'Enable verbose logging of JSON-RPC requests',
    })),
});
export default function Serve({ options }) {
    const [activeTab, setActiveTab] = useState(0);
    const [isInteractive, setIsInteractive] = useState(false);
    // Generate the RPC URL for the local server
    const rpcUrl = `http://${options.host}:${options.port}`;
    // Define tabs with action components
    const tabs = [
        { name: 'Home', component: null }, // Home tab - use server info display
        {
            name: 'Call',
            component: () => (_jsx(ActionTab, { actionName: "Call", interactive: isInteractive, rpcUrl: rpcUrl, ActionComponent: Call })),
        },
        {
            name: 'GetAccount',
            component: () => (_jsx(ActionTab, { actionName: "GetAccount", interactive: isInteractive, rpcUrl: rpcUrl, ActionComponent: GetAccount })),
        },
        {
            name: 'SetAccount',
            component: () => (_jsx(ActionTab, { actionName: "SetAccount", interactive: isInteractive, rpcUrl: rpcUrl, ActionComponent: SetAccount })),
        },
        { name: 'Logs', component: LogViewer },
    ];
    // Use React Query to start and manage the server
    const { isLoading, isError, error } = useQuery({
        queryKey: ['server', options],
        queryFn: async () => {
            return initializeServer({
                port: options.port,
                host: options.host,
                chainId: options.chainId,
                fork: options.fork,
                forkBlockNumber: options.forkBlockNumber,
                loggingLevel: options.loggingLevel,
                verbose: options.verbose,
            });
        },
        retry: false,
        refetchOnWindowFocus: false,
        refetchOnReconnect: false,
        enabled: true,
        staleTime: Infinity,
        gcTime: 0,
    });
    // Handle keyboard navigation and interaction
    useInput((_, key) => {
        // If in interactive mode, only handle Escape to exit
        if (isInteractive) {
            if (key.escape) {
                setIsInteractive(false);
            }
            return;
        }
        // Tab navigation when not in interactive mode
        if (key.tab || key.rightArrow) {
            setActiveTab((prev) => (prev + 1) % tabs.length);
        }
        else if ((key.shift && key.tab) || key.leftArrow) {
            setActiveTab((prev) => (prev - 1 + tabs.length) % tabs.length);
        }
        else if (key.return && activeTab > 0) {
            // Enter on a tab enters interactive mode
            setIsInteractive(true);
        }
    });
    // Display loading state while server is starting
    if (isLoading) {
        return (_jsx(Box, { children: _jsxs(Text, { children: [_jsx(Text, { color: "green", children: _jsx(Spinner, { type: "dots" }) }), ' Starting server...'] }) }));
    }
    // Display error state if server failed to start
    if (isError) {
        return (_jsx(Box, { flexDirection: "column", children: _jsxs(Text, { color: "red", children: ["Error starting server: ", error instanceof Error ? error.message : String(error)] }) }));
    }
    // Render content based on active tab and interactive state
    const renderContent = () => {
        // Home tab content - server info
        if (activeTab === 0) {
            return (_jsx(HomeTab, { host: options.host, port: options.port, chainId: options.chainId, fork: options.fork, verbose: options.verbose }));
        }
        // Action component or Logs tab
        const currentTab = tabs[activeTab];
        if (currentTab?.component) {
            const TabComponent = currentTab.component;
            return _jsx(TabComponent, { interactive: isInteractive });
        }
        return _jsx(Text, { children: "Tab content not available" });
    };
    return (_jsxs(Box, { flexDirection: "column", children: [!isInteractive && (_jsx(Box, { marginBottom: 1, children: tabs.map((tab, index) => (_jsx(Box, { marginRight: 2, children: _jsx(Text, { backgroundColor: activeTab === index ? 'blue' : undefined, color: activeTab === index ? 'white' : 'gray', bold: activeTab === index, children: tab.name }) }, tab.name))) })), _jsx(Box, { marginTop: 1, children: renderContent() }), _jsx(Box, { marginTop: 1, children: isInteractive ? (_jsx(Text, { children: "Press Escape to return to tabs" })) : (_jsxs(Text, { children: ["Use Tab/Arrow keys to navigate between tabs", activeTab > 0 ? ', Enter to interact with action' : ''] })) })] }));
}
