import * as _tevm_utils from '@tevm/utils';
import { Abi as Abi$1, Address as Address$1, Hex as Hex$1, ContractFunctionName, EncodeFunctionDataParameters, DecodeFunctionResultReturnType, ContractConstructorArgs, EncodeDeployDataParameters, BlockTag as BlockTag$1 } from '@tevm/utils';
import { JsonRpcRequest, JsonRpcResponse } from '@tevm/jsonrpc';
import * as _tevm_node from '@tevm/node';
import { TevmNode, Filter } from '@tevm/node';
import { InvalidParamsError, InvalidSkipBalanceError, InvalidGasRefundError, InvalidBlockError, InvalidGasPriceError, InvalidOriginError, InvalidCallerError, InvalidDepthError, InvalidBlobVersionedHashesError, InvalidAddToMempoolError, InvalidAddToBlockchainError, UnknownBlockError, AuthCallUnsetError, BLS12381FpNotInFieldError, BLS12381InputEmptyError, BLS12381InvalidInputLengthError, BLS12381PointNotOnCurveError, CodeStoreOutOfGasError, CodeSizeExceedsMaximumError, CreateCollisionError, InvalidCommitmentError, EvmRevertError, InitcodeSizeViolationError, InsufficientBalanceError, InternalEvmError, InvalidBeginSubError, InvalidBytecodeResultError, InvalidEofFormatError, InvalidInputLengthError, InvalidJumpError, InvalidJumpSubError, InvalidKzgInputsError, InvalidOpcodeError, InvalidProofError, InvalidReturnSubError, OutOfGasError, OutOfRangeError, RefundExhaustedError, StackOverflowError, StackUnderflowError, StaticStateChangeError, StopError, ValueOverflowError, InvalidAddressError, InvalidGasLimitError, InvalidSaltError, InvalidDataError, InvalidBytecodeError, InternalError, ExecutionError, RevertError, ForkError, InvalidRequestError, InvalidAbiError, InvalidArgsError, InvalidFunctionNameError, AccountNotFoundError, InvalidBalanceError, InvalidNonceError, InvalidDeployedBytecodeError, InvalidStorageRootError } from '@tevm/errors';
import * as zod from 'zod';
import { z } from 'zod';
import { Address as Address$2 } from '@tevm/address';
import * as _tevm_evm from '@tevm/evm';
import { InterpreterStep, EvmResult, PrecompileInput, ExecResult } from '@tevm/evm';
import * as _tevm_vm from '@tevm/vm';
import * as _tevm_block from '@tevm/block';
import { Block as Block$1 } from '@tevm/block';
import * as viem from 'viem';
import { SerializableTevmState, ParameterizedTevmState, TevmState, StateRoots } from '@tevm/state';
import { ChainOptions } from '@tevm/blockchain';
import { ConsensusAlgorithm, ConsensusType } from '@tevm/common';
import { TxPool } from '@tevm/txpool';
import { TxReceipt } from '@tevm/receipt-manager';

/**
 * A valid [Ethereum JSON ABI](https://docs.soliditylang.org/en/latest/abi-spec.html#json)
 */
type Abi = Abi$1;

/**
 * A hex string
 * @example
 * const hex: Hex = '0x1234ff'
 */
type Hex = `0x${string}`;

/**
 * The state of an account as captured by `debug_` traces
 */
type AccountState = {
    readonly balance: Hex;
    readonly nonce: number;
    readonly code: Hex;
    readonly storage: Record<Hex, Hex>;
};

/**
 * An ethereum address represented as a hex string
 * @see https://abitype.dev/config#addresstype for configuration options to change type to being a string if preferred
 */
type Address = Address$1;

/**
 * Header information of an ethereum block
 */
type Block = {
    /**
     * The block number (height) in the blockchain.
     */
    readonly number: bigint;
    /**
     * The address of the miner or validator who mined or validated the block.
     */
    readonly coinbase: Address;
    /**
     * The timestamp at which the block was mined or validated.
     */
    readonly timestamp: bigint;
    /**
     * The difficulty level of the block (relevant in PoW chains).
     */
    readonly difficulty: bigint;
    /**
     * The gas limit for the block, i.e., the maximum amount of gas that can be used by the transactions in the block.
     */
    readonly gasLimit: bigint;
    /**
     * (Optional) The base fee per gas in the block, introduced in EIP-1559 for dynamic transaction fee calculation.
     */
    readonly baseFeePerGas?: bigint;
    /**
     * The gas price for the block; may be undefined in blocks after EIP-1559.
     */
    readonly blobGasPrice?: bigint;
};

/**
 * The fields of this optional object customize the block as part of which the call is simulated. The object contains the following fields:
 * This option cannot be used when `createTransaction` is set to `true`
 * Setting the block number to past block will not run in the context of that blocks state. To do that fork that block number first.
 */
type BlockOverrideSet = {
    /**
     * Fake block number
     */
    number?: bigint;
    /**
     * Fake difficulty. Note post-merge difficulty should be 0.
     * not included as an option atm
     */
    /**
     * Fake block timestamp
     */
    time?: bigint;
    /**
     * Block gas capacity
     */
    gasLimit?: bigint;
    /**
     * Block fee recipient
     */
    coinbase?: Address$1;
    /**
     * Fake PrevRandao value
     * Not included as an option atm
     */
    /**
     * Block base fee (see EIP-1559)
     */
    baseFee?: bigint;
    /**
     * Block blob base fee (see EIP-4844)
     */
    blobBaseFee?: bigint;
};

type BlockTag = 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized';

type BlockParam = BlockTag | Hex$1 | bigint;

/**
 * A transaction request object
 */
type TransactionParams = {
    readonly from: Address;
    readonly to?: Address;
    readonly gas?: Hex;
    readonly gasPrice?: Hex;
    readonly value?: Hex;
    readonly input: Hex;
    readonly nonce?: Hex;
};

/**
 * The type returned by block related
 * json rpc procedures
 */
type BlockResult<TIncludeTransactions extends boolean = false> = {
    /**
     * The block number (height) in the blockchain.
     */
    readonly number: Hex;
    /**
     * The hex stringhash of the block.
     */
    readonly hash: Hex;
    /**
     * The hex stringhash of the parent block.
     */
    readonly parentHash: Hex;
    readonly nonce: Hex;
    /**
     * The hex stringhash of the uncles of the block.
     */
    readonly sha3Uncles: Hex;
    readonly logsBloom: Hex;
    readonly transactionsRoot: Hex;
    readonly stateRoot: Hex;
    readonly miner: Hex;
    readonly difficulty: Hex;
    readonly totalDifficulty: Hex;
    readonly extraData: Hex;
    readonly size: Hex;
    readonly gasLimit: Hex;
    readonly gasUsed: Hex;
    readonly timestamp: Hex;
    readonly transactions: TIncludeTransactions extends true ? Array<TransactionParams> : Hex[];
    readonly uncles: Hex[];
};

/**
 * Event emitted when a new contract is created
 */
interface NewContractEvent {
    /** Address of the newly created contract */
    address: Address$2;
    /** Deployed contract bytecode */
    code: Uint8Array;
}
/**
 * Message object representing a call to the EVM
 * This corresponds to the EVM's internal Message object
 */
interface Message {
    /** Target address (undefined for contract creation) */
    to?: Address$2;
    /** Value sent with the call (in wei) */
    value: bigint;
    /** Address of the account that initiated this call */
    caller: Address$2;
    /** Gas limit for this call */
    gasLimit: bigint;
    /** Input data to the call */
    data: Uint8Array;
    /** Contract code for the call - can be bytecode or a precompile function */
    code?: Uint8Array | any;
    /** Call depth */
    depth: number;
    /** Whether the call is static (view) */
    isStatic: boolean;
    /** Whether this is precompiled contract code */
    isCompiled: boolean;
    /** Whether this is a DELEGATECALL */
    delegatecall: boolean;
    /** Salt for CREATE2 calls */
    salt?: Uint8Array;
    /** Origin address for AUTH calls */
    authcallOrigin?: Address$2;
    /** Gas refund counter */
    gasRefund?: bigint;
}
/**
 * Event handlers for EVM execution during a call
 * @example
 * ```typescript
 * import { createMemoryClient } from 'tevm'
 * import { tevmCall } from 'tevm/actions'
 *
 * const client = createMemoryClient()
 *
 * const result = await tevmCall(client, {
 *   to: '0x1234...',
 *   data: '0xabcdef...',
 *   onStep: (step, next) => {
 *     console.log(`Executing ${step.opcode.name} at PC=${step.pc}`)
 *     next?.()
 *   }
 * })
 * ```
 */
type CallEvents = {
    /**
     * Handler called on each EVM step (instruction execution)
     * @param data Step information including opcode, stack, and memory state
     * @param next Function to continue execution - must be called to proceed
     */
    onStep?: (data: InterpreterStep, next?: () => void) => void;
    /**
     * Handler called when a new contract is created
     * @param data Contract creation information
     * @param next Function to continue execution - must be called to proceed
     */
    onNewContract?: (data: NewContractEvent, next?: () => void) => void;
    /**
     * Handler called before a message (call) is processed
     * @param data Message information
     * @param next Function to continue execution - must be called to proceed
     */
    onBeforeMessage?: (data: Message, next?: () => void) => void;
    /**
     * Handler called after a message (call) is processed
     * @param data Result information
     * @param next Function to continue execution - must be called to proceed
     */
    onAfterMessage?: (data: EvmResult, next?: () => void) => void;
};

type TraceType = 'CALL' | 'DELEGATECALL' | 'STATICCALL' | 'CREATE' | 'CREATE2' | 'SELFDESTRUCT';

type TraceCall = {
    type: TraceType;
    from: Address;
    to: Address;
    value?: bigint;
    gas?: bigint;
    gasUsed?: bigint;
    input: Hex;
    output: Hex;
    error?: string;
    revertReason?: string;
    calls?: TraceCall[];
};

/** Result from `debug_*` with `callTracer` */
type CallTraceResult = {
    type: TraceType;
    from: Address;
    to: Address;
    value: bigint;
    gas: bigint;
    gasUsed: bigint;
    input: Hex;
    output: Hex;
    calls?: TraceCall[];
};

type EmptyParams = readonly [] | {} | undefined | never;

/**
 * FilterLog type for eth JSON-RPC procedures
 */
type FilterLog = {
    readonly address: Hex;
    readonly blockHash: Hex;
    readonly blockNumber: bigint;
    readonly data: Hex;
    readonly logIndex: bigint;
    readonly removed: boolean;
    readonly topics: readonly Hex[];
    readonly transactionHash: Hex;
    readonly transactionIndex: bigint;
};

/**
 * An event filter options object
 */
type FilterParams = {
    readonly fromBlock?: BlockParam;
    readonly toBlock?: BlockParam;
    readonly address?: Address;
    readonly topics?: ReadonlyArray<Hex> | ReadonlyArray<ReadonlyArray<Hex>>;
};

/**
 * Result from `debug_*` with `4byteTracer`
 * Returns a mapping of selector-calldata_size keys to their call counts as well as an additional mapping of contract address to selector keys to an array of calldata they were called with.
 *
 * Nodes usually only return the first mapping, but Tevm returns both for better debugging.
 *
 * The entries in the first mapping are in the format "0x{selector}-{calldata_size}" -> count where:
 * - selector: 4-byte function selector (e.g., "0x27dc297e")
 * - calldata_size: size of call data excluding the 4-byte selector
 * - count: number of times the selector-calldata_size combination was called
 *
 * The entries in the second mapping are in the format "0x{contract_address}" -> "0x{selector}" -> [calldata1, calldata2, ...] where:
 * - contract_address: 20-byte contract address (e.g., "0x1234567890123456789012345678901234567890")
 * - selector: 4-byte function selector (e.g., "0x27dc297e")
 * - calldata: hex-encoded calldata that was called with the selector
 *
 * @example
 * ```json
 * {
 *   "0x27dc297e-32": 1,
 *   "0x38cc4831-0": 2,
 *   "0x524f3889-64": 1,
 *   "0x1234567890123456789012345678901234567890": {
 *     "0x27dc297e": ["0x0000000000000000000000000000000000000000000000000000000000000001"],
 *     "0x38cc4831": ["0x", "0x"],
 *     "0x524f3889": ["0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"]
 *   }
 * }
 * ```
 */
type FourbyteTraceResult = {
    readonly [K: string]: typeof K extends `${Hex}-${number}` ? number : typeof K extends Hex ? {
        readonly [S: Hex]: readonly Hex[];
    } : never;
};

/**
 * Generic log information
 */
type Log = {
    readonly address: Address;
    readonly topics: Hex[];
    readonly data: Hex;
};

/**
 * Represents a configuration for a forked or proxied network
 */
type NetworkConfig = {
    /**
     * The URL to the RPC endpoint
     */
    url: string;
    /**
     * the block tag to fork from
     */
    blockTag: BlockParam;
};

/** Result from `debug_*` with `prestateTracer` */
type PrestateTraceResult<TDiffMode extends boolean = boolean> = TDiffMode extends true ? {
    readonly pre: Record<Hex, AccountState>;
    readonly post: Record<Hex, Partial<AccountState>>;
} : Record<Hex, AccountState>;

/**
 * The state override set is an optional address-to-state mapping, where each entry specifies some state to be ephemerally overridden prior to executing the call. Each address maps to an object containing:
 * This option cannot be used when `createTransaction` is set to `true`
 *
 * The goal of the state override set is manyfold:

 * It can be used by DApps to reduce the amount of contract code needed to be deployed on chain. Code that simply returns internal state or does pre-defined validations can be kept off chain and fed to the node on-demand.
 * It can be used for smart contract analysis by extending the code deployed on chain with custom methods and invoking them. This avoids having to download and reconstruct the entire state in a sandbox to run custom code against.
 * It can be used to debug smart contracts in an already deployed large suite of contracts by selectively overriding some code or state and seeing how execution changes. Specialized tooling will probably be necessary.
 * @example
 * ```ts
 * {
 *   "0xd9c9cd5f6779558b6e0ed4e6acf6b1947e7fa1f3": {
 *     "balance": "0xde0b6b3a7640000"
 *   },
 *   "0xebe8efa441b9302a0d7eaecc277c09d20d684540": {
 *     "code": "0x...",
 *     "state": {
 *       "0x...": "0x..."
 *     }
 *   }
 * }
 * ```
 */
type StateOverrideSet = {
    [address: Address]: {
        /**
         * Fake balance to set for the account before executing the call.
         */
        balance?: bigint;
        /**
         * Fake nonce to set for the account before executing the call.
         */
        nonce?: bigint;
        /**
         * Fake code to set for the account before executing the call.
         */
        code?: Hex$1;
        /**
         * Fake key-value mapping to override all slots in the account storage before executing the calls
         */
        state?: Record<Hex$1, Hex$1>;
        /**
         * Fake key-value mapping to override individual slots in the account storage before executing the calls
         */
        stateDiff?: Record<Hex$1, Hex$1>;
    };
};

type StructLog = {
    readonly depth: number;
    readonly gas: bigint;
    readonly gasCost: bigint;
    readonly op: string;
    readonly pc: number;
    readonly stack: Array<Hex>;
    readonly error?: {
        error: string;
        errorType: string;
    };
};

/** Result from `debug_*` with no tracer */
type TraceResult = {
    failed: boolean;
    gas: bigint;
    returnValue: Hex;
    structLogs: Array<StructLog>;
};

/**
 * Transaction receipt result type for eth JSON-RPC procedures
 */
type TransactionReceiptResult = {
    readonly blockHash: Hex;
    readonly blockNumber: bigint;
    readonly contractAddress: Hex | null;
    readonly cumulativeGasUsed: bigint;
    readonly effectiveGasPrice: bigint;
    readonly from: Hex;
    readonly gasUsed: bigint;
    readonly logs: readonly FilterLog[];
    readonly logsBloom: Hex;
    readonly status?: Hex;
    readonly root?: Hex;
    readonly to: Hex | null;
    readonly transactionHash: Hex;
    readonly transactionIndex: bigint;
    readonly blobGasUsed?: bigint;
    readonly blobGasPrice?: bigint;
};

/**
 * The type returned by transaction related
 * json rpc procedures
 */
type TransactionResult = {
    readonly blockHash: Hex;
    readonly blockNumber: Hex;
    readonly from: Hex;
    readonly gas: Hex;
    readonly gasPrice: Hex;
    readonly hash: Hex;
    readonly input: Hex;
    readonly nonce: Hex;
    readonly to: Hex;
    readonly transactionIndex: Hex;
    readonly value: Hex;
    readonly v: Hex;
    readonly r: Hex;
    readonly s: Hex;
    readonly chainId?: Hex;
    readonly maxFeePerGas?: Hex;
    readonly maxPriorityFeePerGas?: Hex;
    readonly type?: Hex;
    readonly accessList?: ReadonlyArray<{
        readonly address: Hex;
        readonly storageKeys: ReadonlyArray<Hex>;
    }>;
    readonly maxFeePerBlobGas?: Hex;
    readonly blobVersionedHashes?: ReadonlyArray<Hex>;
    readonly isImpersonated?: boolean;
};

/***
 * TODO I didn't update any of these jsdocs
 */

/**
 * Params fro `anvil_impersonateAccount` handler
 */
type AnvilImpersonateAccountParams = {
    /**
     * The address to impersonate
     */
    readonly address: Address;
};
/**
 * Params for `anvil_stopImpersonatingAccount` handler
 */
type AnvilStopImpersonatingAccountParams = {
    /**
     * The address to stop impersonating
     */
    readonly address: Address;
};
/**
 * Params for `anvil_autoImpersonateAccount` handler
 * Not included atm because tevm_call supports it and i was getting methodNotFound errors trying it in anvil
 */
/**
 * Params for `anvil_getAutomine` handler
 */
type AnvilGetAutomineParams = {} | undefined | never;
/**
 * Params for `anvil_mine` handler
 */
type AnvilMineParams = {
    /**
     * Number of blocks to mine. Defaults to 1
     */
    readonly blockCount?: number;
    /**
     * mineing interval
     */
    readonly interval?: number;
};
/**
 * Params for `anvil_reset` handler
 */
type AnvilResetParams = {};
/**
 * Params for `anvil_dropTransaction` handler
 */
type AnvilDropTransactionParams = {
    /**
     * The transaction hash
     */
    readonly transactionHash: Hex;
};
/**
 * Params for `anvil_setBalance` handler
 */
type AnvilSetBalanceParams = {
    /**
     * The address to set the balance for
     */
    readonly address: Address;
    /**
     * The balance to set
     */
    readonly balance: Hex | BigInt;
};
/**
 * Params for `anvil_setCode` handler
 */
type AnvilSetCodeParams = {
    /**
     * The address to set the code for
     */
    readonly address: Address;
    /**
     * The code to set
     */
    readonly code: Hex;
};
/**
 * Params for `anvil_setNonce` handler
 */
type AnvilSetNonceParams = {
    /**
     * The address to set the nonce for
     */
    readonly address: Address;
    /**
     * The nonce to set
     */
    readonly nonce: BigInt;
};
/**
 * Params for `anvil_setStorageAt` handler
 */
type AnvilSetStorageAtParams = {
    /**
     * The address to set the storage for
     */
    readonly address: Address;
    /**
     * The position in storage to set
     */
    readonly position: Hex | BigInt;
    /**
     * The value to set
     */
    readonly value: Hex | BigInt;
};
/**
 * Params for `anvil_setChainId` handler
 */
type AnvilSetChainIdParams = {
    /**
     * The chain id to set
     */
    readonly chainId: number;
};
/**
 * Params for `anvil_dumpState` handler
 */
type AnvilDumpStateParams = {} | undefined | never;
/**
 * Params for `anvil_loadState` handler
 */
type AnvilLoadStateParams = {
    /**
     * The state to load
     */
    readonly state: Record<Hex, Hex>;
};
type AnvilDealParams = {
    /** The address of the ERC20 token to deal */
    erc20?: Address;
    /** The owner of the dealt tokens */
    account: Address;
    /** The amount of tokens to deal */
    amount: bigint;
};

type AnvilImpersonateAccountResult = null;
type AnvilStopImpersonatingAccountResult = null;
type AnvilGetAutomineResult = boolean;
type AnvilMineResult = null;
type AnvilResetResult = null;
type AnvilDropTransactionResult = null;
type AnvilSetBalanceResult = null;
type AnvilSetCodeResult = null;
type AnvilSetNonceResult = null;
type AnvilSetStorageAtResult = null;
type AnvilSetChainIdResult = null;
type AnvilDumpStateResult = Hex;
type AnvilLoadStateResult = null;
type AnvilDealResult = {
    errors?: Error[];
};

type AnvilImpersonateAccountHandler = (params: AnvilImpersonateAccountParams) => Promise<AnvilImpersonateAccountResult>;
type AnvilStopImpersonatingAccountHandler = (params: AnvilStopImpersonatingAccountParams) => Promise<AnvilStopImpersonatingAccountResult>;
type AnvilGetAutomineHandler = (params: AnvilGetAutomineParams) => Promise<AnvilGetAutomineResult>;
type AnvilMineHandler = (params: AnvilMineParams) => Promise<AnvilMineResult>;
type AnvilResetHandler = (params: AnvilResetParams) => Promise<AnvilResetResult>;
type AnvilDropTransactionHandler = (params: AnvilDropTransactionParams) => Promise<AnvilDropTransactionResult>;
type AnvilSetBalanceHandler = (params: AnvilSetBalanceParams) => Promise<AnvilSetBalanceResult>;
type AnvilSetCodeHandler = (params: AnvilSetCodeParams) => Promise<AnvilSetCodeResult>;
type AnvilSetNonceHandler = (params: AnvilSetNonceParams) => Promise<AnvilSetNonceResult>;
type AnvilSetStorageAtHandler = (params: AnvilSetStorageAtParams) => Promise<AnvilSetStorageAtResult>;
type AnvilSetChainIdHandler = (params: AnvilSetChainIdParams) => Promise<AnvilSetChainIdResult>;
type AnvilDumpStateHandler = (params: AnvilDumpStateParams) => Promise<AnvilDumpStateResult>;
type AnvilLoadStateHandler = (params: AnvilLoadStateParams) => Promise<AnvilLoadStateResult>;
type AnvilDealHandler = (params: AnvilDealParams) => Promise<AnvilDealResult>;

type JsonSerializable = bigint | string | number | boolean | null | JsonSerializableArray | JsonSerializableObject | JsonSerializableSet | (Error & {
    code: number | string;
});
type JsonSerializableArray = ReadonlyArray<JsonSerializable>;
type JsonSerializableObject = {
    [key: string]: JsonSerializable;
};
type JsonSerializableSet<T extends bigint | string | number | boolean = bigint | string | number | boolean> = Set<T>;
type BigIntToHex<T> = T extends bigint ? Hex$1 : T;
type SetToHex<T> = T extends Set<any> ? Hex$1 : T;
type SerializeToJson<T> = T extends Error & {
    code: infer TCode;
} ? {
    code: TCode;
    message: T['message'];
} : T extends JsonSerializableSet<infer S> ? ReadonlyArray<S> : T extends JsonSerializableObject ? {
    [P in keyof T]: SerializeToJson<T[P]>;
} : T extends JsonSerializableArray ? SerializeToJson<T[number]>[] : BigIntToHex<SetToHex<T>>;

/**
 * JSON-RPC request for `anvil_impersonateAccount` method
 */
type AnvilImpersonateAccountJsonRpcRequest = JsonRpcRequest<'anvil_impersonateAccount', readonly [Address$1]>;
/**
 * JSON-RPC request for `anvil_stopImpersonatingAccount` method
 */
type AnvilStopImpersonatingAccountJsonRpcRequest = JsonRpcRequest<'anvil_stopImpersonatingAccount', readonly [Address$1]>;
/**
 * JSON-RPC request for `anvil_autoImpersonateAccount` method
 * Not included atm because tevm_call supports it and i was getting methodNotFound errors trying it in anvil
 */
/**
 * JSON-RPC request for `anvil_getAutomine` method
 */
type AnvilGetAutomineJsonRpcRequest = JsonRpcRequest<'anvil_getAutomine', [
    SerializeToJson<AnvilGetAutomineParams>
]>;
/**
 * JSON-RPC request for `anvil_setCoinbase` method
 * Not included atm because tevm_call supports it and i was getting methodNotFound errors trying it in anvil
 */
type AnvilSetCoinbaseJsonRpcRequest = JsonRpcRequest<'anvil_setCoinbase', readonly [Address$1]>;
/**
 * JSON-RPC request for `anvil_mine` method
 */
type AnvilMineJsonRpcRequest = JsonRpcRequest<'anvil_mine', readonly [blockCount: Hex$1, interval: Hex$1]>;
/**
 * JSON-RPC request for `anvil_reset` method
 */
type AnvilResetJsonRpcRequest = JsonRpcRequest<'anvil_reset', readonly []>;
/**
 * JSON-RPC request for `anvil_dropTransaction` method
 */
type AnvilDropTransactionJsonRpcRequest = JsonRpcRequest<'anvil_dropTransaction', [
    SerializeToJson<AnvilDropTransactionParams>
]>;
/**
 * JSON-RPC request for `anvil_setBalance` method
 */
type AnvilSetBalanceJsonRpcRequest = JsonRpcRequest<'anvil_setBalance', readonly [address: Address$1, balance: Hex$1]>;
/**
 * JSON-RPC request for `anvil_setCode` method
 */
type AnvilSetCodeJsonRpcRequest = JsonRpcRequest<'anvil_setCode', readonly [account: Address$1, deployedBytecode: Hex$1]>;
/**
 * JSON-RPC request for `anvil_setNonce` method
 */
type AnvilSetNonceJsonRpcRequest = JsonRpcRequest<'anvil_setNonce', readonly [address: Address$1, nonce: Hex$1]>;
/**
 * JSON-RPC request for `anvil_setStorageAt` method
 */
type AnvilSetStorageAtJsonRpcRequest = JsonRpcRequest<'anvil_setStorageAt', [
    address: Address$1,
    slot: Hex$1,
    value: Hex$1
]>;
/**
 * JSON-RPC request for `anvil_setChainId` method
 */
type AnvilSetChainIdJsonRpcRequest = JsonRpcRequest<'anvil_setChainId', readonly [Hex$1]>;
/**
 * JSON-RPC request for `anvil_dumpState` method
 */
type AnvilDumpStateJsonRpcRequest = JsonRpcRequest<'anvil_dumpState', readonly [SerializeToJson<AnvilDumpStateParams>]>;
/**
 * JSON-RPC request for `anvil_loadState` method
 */
type AnvilLoadStateJsonRpcRequest = JsonRpcRequest<'anvil_loadState', readonly [SerializeToJson<AnvilLoadStateParams>]>;
/**
 * JSON-RPC request for `anvil_deal` method
 */
type AnvilDealJsonRpcRequest = JsonRpcRequest<'anvil_deal', [SerializeToJson<AnvilDealParams>]>;
type AnvilJsonRpcRequest = AnvilImpersonateAccountJsonRpcRequest | AnvilStopImpersonatingAccountJsonRpcRequest | AnvilGetAutomineJsonRpcRequest | AnvilMineJsonRpcRequest | AnvilResetJsonRpcRequest | AnvilDropTransactionJsonRpcRequest | AnvilSetBalanceJsonRpcRequest | AnvilSetCodeJsonRpcRequest | AnvilSetNonceJsonRpcRequest | AnvilSetStorageAtJsonRpcRequest | AnvilSetChainIdJsonRpcRequest | AnvilDumpStateJsonRpcRequest | AnvilLoadStateJsonRpcRequest | AnvilSetCoinbaseJsonRpcRequest | AnvilDealJsonRpcRequest;

type AnvilError = string;
/**
 * JSON-RPC response for `anvil_impersonateAccount` procedure
 */
type AnvilImpersonateAccountJsonRpcResponse = JsonRpcResponse<'anvil_impersonateAccount', SerializeToJson<AnvilImpersonateAccountResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_stopImpersonatingAccount` procedure
 */
type AnvilStopImpersonatingAccountJsonRpcResponse = JsonRpcResponse<'anvil_stopImpersonatingAccount', SerializeToJson<AnvilStopImpersonatingAccountResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_setCoinbase` procedure
 */
type AnvilSetCoinbaseJsonRpcResponse = JsonRpcResponse<'anvil_setCoinbase', Address$1, AnvilError>;
/**
 * JSON-RPC response for `anvil_autoImpersonateAccount` procedure
 * Not included atm because tevm_call supports it and i was getting methodNotFound errors trying it in anvil
 */
/**
 * JSON-RPC response for `anvil_getAutomine` procedure
 */
type AnvilGetAutomineJsonRpcResponse = JsonRpcResponse<'anvil_getAutomine', SerializeToJson<AnvilGetAutomineResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_mine` procedure
 */
type AnvilMineJsonRpcResponse = JsonRpcResponse<'anvil_mine', SerializeToJson<AnvilMineResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_reset` procedure
 */
type AnvilResetJsonRpcResponse = JsonRpcResponse<'anvil_reset', SerializeToJson<AnvilResetResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_dropTransaction` procedure
 */
type AnvilDropTransactionJsonRpcResponse = JsonRpcResponse<'anvil_dropTransaction', SerializeToJson<AnvilDropTransactionResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_setBalance` procedure
 */
type AnvilSetBalanceJsonRpcResponse = JsonRpcResponse<'anvil_setBalance', SerializeToJson<AnvilSetBalanceResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_setCode` procedure
 */
type AnvilSetCodeJsonRpcResponse = JsonRpcResponse<'anvil_setCode', SerializeToJson<AnvilSetCodeResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_setNonce` procedure
 */
type AnvilSetNonceJsonRpcResponse = JsonRpcResponse<'anvil_setNonce', SerializeToJson<AnvilSetNonceResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_setStorageAt` procedure
 */
type AnvilSetStorageAtJsonRpcResponse = JsonRpcResponse<'anvil_setStorageAt', SerializeToJson<AnvilSetStorageAtResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_setChainId` procedure
 */
type AnvilSetChainIdJsonRpcResponse = JsonRpcResponse<'anvil_setChainId', SerializeToJson<AnvilSetChainIdResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_dumpState` procedure
 */
type AnvilDumpStateJsonRpcResponse = JsonRpcResponse<'anvil_dumpState', SerializeToJson<AnvilDumpStateResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_loadState` procedure
 */
type AnvilLoadStateJsonRpcResponse = JsonRpcResponse<'anvil_loadState', SerializeToJson<AnvilLoadStateResult>, AnvilError>;
/**
 * JSON-RPC response for `anvil_deal` procedure
 */
type AnvilDealJsonRpcResponse = JsonRpcResponse<'anvil_deal', SerializeToJson<AnvilDealResult>, AnvilError>;

type AnvilSetCoinbaseProcedure = (request: AnvilSetCoinbaseJsonRpcRequest) => Promise<AnvilSetCoinbaseJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_impersonateAccount`
 */
type AnvilImpersonateAccountProcedure = (request: AnvilImpersonateAccountJsonRpcRequest) => Promise<AnvilImpersonateAccountJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_stopImpersonatingAccount`
 */
type AnvilStopImpersonatingAccountProcedure = (request: AnvilStopImpersonatingAccountJsonRpcRequest) => Promise<AnvilStopImpersonatingAccountJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_autoImpersonateAccount`
 * Not included atm because tevm_call supports it and i was getting methodNotFound errors trying it in anvil
 */
/**
 * JSON-RPC procedure for `anvil_getAutomine`
 */
type AnvilGetAutomineProcedure = (request: AnvilGetAutomineJsonRpcRequest) => Promise<AnvilGetAutomineJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_mine`
 */
type AnvilMineProcedure = (request: AnvilMineJsonRpcRequest) => Promise<AnvilMineJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_reset`
 */
type AnvilResetProcedure = (request: AnvilResetJsonRpcRequest) => Promise<AnvilResetJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_dropTransaction`
 */
type AnvilDropTransactionProcedure = (request: AnvilDropTransactionJsonRpcRequest) => Promise<AnvilDropTransactionJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_setBalance`
 */
type AnvilSetBalanceProcedure = (request: AnvilSetBalanceJsonRpcRequest) => Promise<AnvilSetBalanceJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_setCode`
 */
type AnvilSetCodeProcedure = (request: AnvilSetCodeJsonRpcRequest) => Promise<AnvilSetCodeJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_setNonce`
 */
type AnvilSetNonceProcedure = (request: AnvilSetNonceJsonRpcRequest) => Promise<AnvilSetNonceJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_setStorageAt`
 */
type AnvilSetStorageAtProcedure = (request: AnvilSetStorageAtJsonRpcRequest) => Promise<AnvilSetStorageAtJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_setChainId`
 */
type AnvilSetChainIdProcedure = (request: AnvilSetChainIdJsonRpcRequest) => Promise<AnvilSetChainIdJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_dumpState`
 */
type AnvilDumpStateProcedure = (request: AnvilDumpStateJsonRpcRequest) => Promise<AnvilDumpStateJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_loadState`
 */
type AnvilLoadStateProcedure = (request: AnvilLoadStateJsonRpcRequest) => Promise<AnvilLoadStateJsonRpcResponse>;
/**
 * JSON-RPC procedure for `anvil_deal`
 */
type AnvilDealProcedure = (request: AnvilDealJsonRpcRequest) => Promise<AnvilDealJsonRpcResponse>;
type AnvilProcedure = AnvilSetCoinbaseProcedure | AnvilImpersonateAccountProcedure | AnvilStopImpersonatingAccountProcedure | AnvilGetAutomineProcedure | AnvilMineProcedure | AnvilResetProcedure | AnvilDropTransactionProcedure | AnvilSetBalanceProcedure | AnvilSetCodeProcedure | AnvilSetNonceProcedure | AnvilSetStorageAtProcedure | AnvilSetChainIdProcedure | AnvilDumpStateProcedure | AnvilLoadStateProcedure | AnvilDealProcedure;

declare function dealHandler(node: _tevm_node.TevmNode): AnvilDealHandler;

declare function anvilDealJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilDealProcedure;

declare function anvilDropTransactionJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilDropTransactionProcedure;

declare function anvilDumpStateJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilDumpStateProcedure;

declare function anvilGetAutomineJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilGetAutomineProcedure;

declare function anvilImpersonateAccountJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilImpersonateAccountProcedure;

declare function anvilLoadStateJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilLoadStateProcedure;

declare function anvilResetJsonRpcProcedure(node: _tevm_node.TevmNode): AnvilResetProcedure;

declare function anvilSetBalanceJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilSetBalanceProcedure;

declare function anvilSetChainIdJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilSetChainIdProcedure;

declare function anvilSetCodeJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilSetCodeProcedure;

declare function anvilSetCoinbaseJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilSetCoinbaseProcedure;

declare function anvilSetNonceJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilSetNonceProcedure;

declare function anvilSetStorageAtJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilSetStorageAtProcedure;

declare function anvilStopImpersonatingAccountJsonRpcProcedure(client: _tevm_node.TevmNode): AnvilStopImpersonatingAccountProcedure;

/**
 * The base parameters shared across all actions
 */
type BaseParams<TThrowOnFail extends boolean = boolean> = {
    /**
     * Whether to throw on errors or return errors as value on the 'errors' property
     * Defaults to `true`
     */
    readonly throwOnFail?: TThrowOnFail;
};

/**
 * Properties shared across call-like params.
 * This type is used as the base for various call-like parameter types:
 * - [CallParams](https://tevm.sh/reference/tevm/actions/type-aliases/callparams-1/)
 * - [ContractParams](https://tevm.sh/reference/tevm/actions/type-aliases/contractparams-1/)
 * - [DeployParams](https://tevm.sh/reference/tevm/actions/type-aliases/deployparams-1/)
 * - [ScriptParams](https://tevm.sh/reference/tevm/actions/type-aliases/scriptparams-1/)
 *
 * @extends BaseParams
 * @example
 * ```typescript
 * import { BaseCallParams } from 'tevm'
 *
 * const params: BaseCallParams = {
 *   createTrace: true,
 *   createAccessList: true,
 *   createTransaction: 'on-success',
 *   blockTag: 'latest',
 *   skipBalance: true,
 *   gas: 1000000n,
 *   gasPrice: 1n,
 *   maxFeePerGas: 1n,
 *   maxPriorityFeePerGas: 1n,
 *   gasRefund: 0n,
 *   from: '0x123...',
 *   origin: '0x123...',
 *   caller: '0x123...',
 *   value: 0n,
 *   depth: 0,
 *   to: '0x123...',
 * }
 * ```
 */
type BaseCallParams<TThrowOnFail extends boolean = boolean> = BaseParams<TThrowOnFail> & {
    /**
     * Whether to return a complete trace with the call.
     * Defaults to `false`.
     * @example
     * ```ts
     * import { createMemoryClient } from 'tevm'
     *
     * const client = createMemoryClient()
     *
     * const { trace } = await client.call({ address: '0x1234', data: '0x1234', createTrace: true })
     *
     * trace.structLogs.forEach(console.log)
     * ```
     */
    readonly createTrace?: boolean;
    /**
     * Whether to return an access list mapping of addresses to storage keys.
     * Defaults to `false`.
     * @example
     * ```ts
     * import { createMemoryClient } from 'tevm'
     *
     * const client = createMemoryClient()
     *
     * const { accessList } = await client.tevmCall({ to: '0x1234...', data: '0x1234', createAccessList: true })
     * console.log(accessList) // { "0x...": Set(["0x..."]) }
     * ```
     */
    readonly createAccessList?: boolean;
    /**
     * @deprecated Use `addToMempool` or `addToBlockchain` instead.
     * Whether or not to update the state or run the call in a dry-run. Defaults to `never`.
     * - `on-success`: Only update the state if the call is successful.
     * - `always`: Always include the transaction even if it reverts.
     * - `never`: Never include the transaction.
     * - `true`: Alias for `on-success`.
     * - `false`: Alias for `never`.
     *
     * @example
     * ```typescript
     * // Deprecated approach
     * const { txHash } = await client.call({ address: '0x1234', data: '0x1234', createTransaction: 'on-success' })
     * await client.mine()
     * const receipt = await client.getTransactionReceipt({ hash: txHash })
     *
     * // New approach
     * const { txHash } = await client.call({ address: '0x1234', data: '0x1234', addToMempool: true })
     * await client.mine()
     * const receipt = await client.getTransactionReceipt({ hash: txHash })
     *
     * // Or automatically mine the transaction
     * const { txHash } = await client.call({ address: '0x1234', data: '0x1234', addToBlockchain: true })
     * const receipt = await client.getTransactionReceipt({ hash: txHash })
     * ```
     */
    readonly createTransaction?: 'on-success' | 'always' | 'never' | boolean;
    /**
     * Whether to add the transaction to the mempool. Defaults to `false`.
     * - `on-success`: Only add the transaction to the mempool if the call is successful.
     * - `always`: Always add the transaction to the mempool even if it reverts.
     * - `never`: Never add the transaction to the mempool.
     * - `true`: Alias for `on-success`.
     * - `false`: Alias for `never`.
     *
     * This does NOT automatically mine the transaction. To include the transaction in a block,
     * you must call `client.mine()` afterward or use `addToBlockchain: true`.
     *
     * @example
     * ```typescript
     * const { txHash } = await client.call({ address: '0x1234', data: '0x1234', addToMempool: true })
     * await client.mine()
     * const receipt = await client.getTransactionReceipt({ hash: txHash })
     * ```
     */
    readonly addToMempool?: 'on-success' | 'always' | 'never' | boolean;
    /**
     * Whether to add the transaction to the blockchain (mine it immediately). Defaults to `false`.
     * - `on-success`: Only add the transaction to the blockchain if the call is successful.
     * - `always`: Always add the transaction to the blockchain even if it reverts.
     * - `never`: Never add the transaction to the blockchain.
     * - `true`: Alias for `on-success`.
     * - `false`: Alias for `never`.
     *
     * This automatically adds the transaction to the mempool AND mines it.
     * It only mines the current transaction, not any other transactions in the mempool.
     *
     * @example
     * ```typescript
     * const { txHash } = await client.call({ address: '0x1234', data: '0x1234', addToBlockchain: true })
     * const receipt = await client.getTransactionReceipt({ hash: txHash })
     * ```
     */
    readonly addToBlockchain?: 'on-success' | 'always' | 'never' | boolean;
    /**
     * The block number or block tag to execute the call at. Defaults to `latest`.
     * - `bigint`: The block number to execute the call at.
     * - `Hex`: The block hash to execute the call at.
     * - `BlockTag`: The named block tag to execute the call at.
     *
     * Notable block tags:
     * - 'latest': The canonical head.
     * - 'pending': A block that is optimistically built with transactions in the txpool that have not yet been mined.
     * - 'forked': If forking, the 'forked' block will be the block the chain was forked at.
     */
    readonly blockTag?: BlockParam;
    /**
     * Whether to skip the balance check. Defaults to `false`, except for scripts where it is set to `true`.
     */
    readonly skipBalance?: boolean;
    /**
     * The gas limit for the call.
     * Defaults to the block gas limit as specified by the common configuration or the fork URL.
     */
    readonly gas?: bigint;
    /**
     * The gas price for the call.
     * Note: This option is currently ignored when creating transactions because only EIP-1559 transactions are supported. This will be fixed in a future release.
     */
    readonly gasPrice?: bigint;
    /**
     * The maximum fee per gas for EIP-1559 transactions.
     */
    readonly maxFeePerGas?: bigint;
    /**
     * The maximum priority fee per gas for EIP-1559 transactions.
     */
    readonly maxPriorityFeePerGas?: bigint;
    /**
     * The refund counter. Defaults to `0`.
     */
    readonly gasRefund?: bigint;
    /**
     * The from address for the call. Defaults to the zero address for reads and the first account for writes.
     * It is also possible to set the `origin` and `caller` addresses separately using those options. Otherwise, both are set to the `from` address.
     */
    readonly from?: Address;
    /**
     * The nonce for the transaction. If provided, this nonce will be used instead of automatically calculating the next available nonce.
     * This is useful when you want to replace a pending transaction or ensure a specific nonce is used.
     */
    readonly nonce?: bigint;
    /**
     * The address where the call originated from. Defaults to the zero address.
     * If the `from` address is set, it defaults to the `from` address; otherwise, it defaults to the zero address.
     */
    readonly origin?: Address;
    /**
     * The address that ran this code (`msg.sender`). Defaults to the zero address.
     * If the `from` address is set, it defaults to the `from` address; otherwise, it defaults to the zero address.
     */
    readonly caller?: Address;
    /**
     * The value in ether that is being sent to the `to` address. Defaults to `0`.
     */
    readonly value?: bigint;
    /**
     * The depth of the EVM call. Useful for simulating an internal call. Defaults to `0`.
     */
    readonly depth?: number;
    /**
     * Addresses to selfdestruct. Defaults to an empty set.
     */
    readonly selfdestruct?: Set<Address>;
    /**
     * The address of the account executing this code (`address(this)`). Defaults to the zero address.
     * This is not set for create transactions but is required for most transactions.
     */
    readonly to?: Address;
    /**
     * Versioned hashes for each blob in a blob transaction for EIP-4844 transactions.
     */
    readonly blobVersionedHashes?: Hex[];
    /**
     * The state override set is an optional address-to-state mapping where each entry specifies some state to be ephemerally overridden prior to executing the call. Each address maps to an object containing:
     * This option cannot be used when `createTransaction` is set to `true`.
     *
     * @example
     * ```ts
     * const stateOverride = {
     *   "0xd9c9cd5f6779558b6e0ed4e6acf6b1947e7fa1f3": {
     *     balance: "0xde0b6b3a7640000"
     *   },
     *   "0xebe8efa441b9302a0d7eaecc277c09d20d684540": {
     *     code: "0x...",
     *     state: {
     *       "0x...": "0x..."
     *     }
     *   }
     * }
     * const res = await client.call({ address: '0x1234', data: '0x1234', stateOverrideSet: stateOverride })
     * ```
     */
    readonly stateOverrideSet?: StateOverrideSet;
    /**
     * The fields of this optional object customize the block as part of which the call is simulated.
     * The object contains fields such as block number, hash, parent hash, nonce, etc.
     * This option cannot be used when `createTransaction` is set to `true`.
     * Setting the block number to a past block will not run in the context of that block's state. To do that, fork that block number first.
     *
     * @example
     * ```ts
     * const blockOverride = {
     *   number: "0x1b4",
     *   hash: "0x...",
     *   parentHash: "0x...",
     *   nonce: "0x0000000000000042",
     * }
     * const res = await client.call({ address: '0x1234', data: '0x1234', blockOverrideSet: blockOverride })
     * ```
     */
    readonly blockOverrideSet?: BlockOverrideSet;
};

declare function validateBaseCallParams(action: BaseCallParams): ValidateBaseCallParamsError[];
type ValidateBaseCallParamsError = InvalidParamsError | InvalidSkipBalanceError | InvalidGasRefundError | InvalidBlockError | InvalidGasPriceError | InvalidOriginError | InvalidCallerError | InvalidDepthError | InvalidBlobVersionedHashesError | InvalidAddToMempoolError | InvalidAddToBlockchainError;

declare const zBaseCallParams: z.ZodObject<{
    throwOnFail: z.ZodOptional<z.ZodBoolean>;
    createTrace: z.ZodOptional<z.ZodBoolean>;
    createAccessList: z.ZodOptional<z.ZodBoolean>;
    createTransaction: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    addToMempool: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    addToBlockchain: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    skipBalance: z.ZodOptional<z.ZodBoolean>;
    gasRefund: z.ZodOptional<z.ZodBigInt>;
    blockTag: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"latest">, z.ZodLiteral<"earliest">, z.ZodLiteral<"pending">, z.ZodLiteral<"safe">, z.ZodLiteral<"finalized">, z.ZodBigInt, z.ZodPipe<z.ZodNumber, z.ZodTransform<bigint, number>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>]>>;
    gasPrice: z.ZodOptional<z.ZodBigInt>;
    origin: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    caller: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    gas: z.ZodOptional<z.ZodBigInt>;
    value: z.ZodOptional<z.ZodBigInt>;
    depth: z.ZodOptional<z.ZodNumber>;
    selfdestruct: z.ZodOptional<z.ZodSet<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>>;
    to: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    blobVersionedHashes: z.ZodOptional<z.ZodArray<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    stateOverrideSet: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>, z.ZodObject<{
        balance: z.ZodOptional<z.ZodBigInt>;
        nonce: z.ZodOptional<z.ZodBigInt>;
        code: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
        state: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
        stateDiff: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    }, z.core.$strict>>>;
    blockOverrideSet: z.ZodOptional<z.ZodObject<{
        number: z.ZodOptional<z.ZodBigInt>;
        time: z.ZodOptional<z.ZodBigInt>;
        gasLimit: z.ZodOptional<z.ZodBigInt>;
        coinbase: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
        baseFee: z.ZodOptional<z.ZodBigInt>;
        blobBaseFee: z.ZodOptional<z.ZodBigInt>;
    }, z.core.$strict>>;
    maxFeePerGas: z.ZodOptional<z.ZodBigInt>;
    maxPriorityFeePerGas: z.ZodOptional<z.ZodBigInt>;
    onStep: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onNewContract: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onBeforeMessage: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onAfterMessage: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
}, z.core.$strip>;

/**
 * TEVM parameters to execute a call on the VM.
 * `Call` is the lowest level method to interact with the VM, and other methods such as `contract` and `script` use `call` under the hood.
 *
 * @example
 * ```typescript
 * import { createClient } from 'viem'
 * import { createTevmTransport, tevmCall } from 'tevm'
 * import { optimism } from 'tevm/common'
 *
 * const client = createClient({
 *   transport: createTevmTransport({}),
 *   chain: optimism,
 * })
 *
 * const callParams = {
 *   data: '0x...',
 *   bytecode: '0x...',
 *   gasLimit: 420n,
 * }
 *
 * await tevmCall(client, callParams)
 * ```
 *
 * @see [BaseCallParams](https://tevm.sh/reference/tevm/actions/type-aliases/basecallparams-1/)
 * @see [tevmCall](https://tevm.sh/reference/tevm/memory-client/functions/tevmCall/)
 */
type CallParams<TThrowOnFail extends boolean = boolean> = BaseCallParams<TThrowOnFail> & {
    /**
     * An optional CREATE2 salt.
     *
     * @example
     * ```typescript
     * import { createClient } from 'viem'
     * import { createTevmTransport, tevmCall } from 'tevm'
     * import { optimism } from 'tevm/common'
     *
     * const client = createClient({
     *   transport: createTevmTransport({}),
     *   chain: optimism,
     * })
     *
     * const callParams = {
     *   data: '0x...',
     *   bytecode: '0x...',
     *   gasLimit: 420n,
     *   salt: '0x1234...',
     * }
     *
     * await tevmCall(client, callParams)
     * ```
     *
     * @see [CREATE2](https://eips.ethereum.org/EIPS/eip-1014)
     */
    readonly salt?: Hex;
    /**
     * The input data for the call.
     */
    readonly data?: Hex;
    /**
     * The encoded code to deploy with for a deployless call. Code is encoded with constructor arguments, unlike `deployedBytecode`.
     *
     * @example
     * ```typescript
     * import { createClient } from 'viem'
     * import { createTevmTransport, tevmCall, encodeDeployData } from 'tevm'
     * import { optimism } from 'tevm/common'
     *
     * const client = createClient({
     *   transport: createTevmTransport({}),
     *   chain: optimism,
     * })
     *
     * const callParams = {
     *   createTransaction: true,
     *   data: encodeDeployData({
     *     bytecode: '0x...',
     *     data: '0x...',
     *     abi: [{...}],
     *     args: [1, 2, 3],
     *   })
     * }
     *
     * await tevmCall(client, callParams)
     * ```
     * Code is also automatically created if using TEVM contracts via the `script` method.
     *
     * @example
     * ```typescript
     * import { createClient } from 'viem'
     * import { createTevmTransport, tevmContract } from 'tevm'
     * import { optimism } from 'tevm/common'
     * import { SimpleContract } from 'tevm/contracts'
     *
     * const client = createClient({
     *   transport: createTevmTransport({}),
     *   chain: optimism,
     * })
     *
     * const script = SimpleContract.script({ constructorArgs: [420n] })
     *
     * await tevmContract(client, script.read.get()) // 420n
     * ```
     */
    readonly code?: Hex;
    /**
     * The code to put into the state before executing the call. If you wish to call the constructor, use `code` instead.
     *
     * @example
     * ```typescript
     * import { createClient } from 'viem'
     * import { createTevmTransport, tevmCall } from 'tevm'
     * import { optimism } from 'tevm/common'
     *
     * const client = createClient({
     *   transport: createTevmTransport({}),
     *   chain: optimism,
     * })
     *
     * const callParams = {
     *   data: '0x...',
     *   deployedBytecode: '0x...',
     * }
     *
     * await tevmCall(client, callParams)
     * ```
     */
    readonly deployedBytecode?: Hex;
};

declare function callHandlerOpts(client: _tevm_node.TevmNode, params: CallParams): Promise<{
    data: Parameters<_tevm_evm.Evm["runCall"]>[0];
    errors?: never;
} | {
    data?: never;
    errors: Array<CallHandlerOptsError>;
}>;
type CallHandlerOptsError = UnknownBlockError | UnknownBlockError | InvalidParamsError;

declare function handleRunTxError(e: unknown): HandleRunTxError;
type EvmErrorConstructor = (typeof evmErrors)[number];
type TevmEvmError = AuthCallUnsetError | BLS12381FpNotInFieldError | BLS12381InputEmptyError | BLS12381InvalidInputLengthError | BLS12381PointNotOnCurveError | CodeStoreOutOfGasError | CodeSizeExceedsMaximumError | CreateCollisionError | InvalidCommitmentError | EvmRevertError | InitcodeSizeViolationError | InsufficientBalanceError | InternalEvmError | InvalidBeginSubError | InvalidBytecodeResultError | InvalidEofFormatError | InvalidInputLengthError | InvalidJumpError | InvalidJumpSubError | InvalidKzgInputsError | InvalidOpcodeError | InvalidProofError | InvalidReturnSubError | OutOfGasError | OutOfRangeError | RefundExhaustedError | StackOverflowError | StackUnderflowError | StaticStateChangeError | StopError | ValueOverflowError;
type HandleRunTxError = TevmEvmError | InvalidGasPriceError | InvalidAddressError | InvalidGasLimitError;
/**
 * @internal
 * Array of every error EVM can throw
 * @type {[typeof AuthCallUnsetError, typeof CodeSizeExceedsMaximumError, typeof CreateCollisionError, typeof InvalidCommitmentError, typeof EvmRevertError, typeof InitcodeSizeViolationError, typeof InsufficientBalanceError, typeof InternalEvmError, typeof InvalidBeginSubError, typeof InvalidBytecodeResultError, typeof InvalidEofFormatError, typeof InvalidInputLengthError, typeof InvalidJumpError, typeof InvalidJumpSubError, typeof InvalidKzgInputsError, typeof InvalidOpcodeError, typeof InvalidProofError, typeof InvalidReturnSubError, typeof OutOfGasError, typeof OutOfRangeError, typeof RefundExhaustedError, typeof StackOverflowError, typeof StackUnderflowError, typeof StaticStateChangeError, typeof StopError, typeof ValueOverflowError, typeof BLS12381InputEmptyError, typeof BLS12381FpNotInFieldError, typeof BLS12381InvalidInputLengthError, typeof BLS12381PointNotOnCurveError, typeof CodeStoreOutOfGasError]}
 */
declare const evmErrors: [typeof AuthCallUnsetError, typeof CodeSizeExceedsMaximumError, typeof CreateCollisionError, typeof InvalidCommitmentError, typeof EvmRevertError, typeof InitcodeSizeViolationError, typeof InsufficientBalanceError, typeof InternalEvmError, typeof InvalidBeginSubError, typeof InvalidBytecodeResultError, typeof InvalidEofFormatError, typeof InvalidInputLengthError, typeof InvalidJumpError, typeof InvalidJumpSubError, typeof InvalidKzgInputsError, typeof InvalidOpcodeError, typeof InvalidProofError, typeof InvalidReturnSubError, typeof OutOfGasError, typeof OutOfRangeError, typeof RefundExhaustedError, typeof StackOverflowError, typeof StackUnderflowError, typeof StaticStateChangeError, typeof StopError, typeof ValueOverflowError, typeof BLS12381InputEmptyError, typeof BLS12381FpNotInFieldError, typeof BLS12381InvalidInputLengthError, typeof BLS12381PointNotOnCurveError, typeof CodeStoreOutOfGasError];

declare function executeCall(client: _tevm_node.TevmNode, evmInput: _tevm_evm.EvmRunCallOpts, params: CallParams, events?: CallEvents): Promise<(ExecuteCallResult & {
    errors?: [ExecuteCallError];
}) | {
    errors: [ExecuteCallError];
}>;
/**
 * The error returned by executeCall
 */
type ExecuteCallError = HandleRunTxError;
/**
 * The return value of executeCall
 */
type ExecuteCallResult = {
    runTxResult: _tevm_vm.RunTxResult;
    trace: TraceResult | undefined;
    accessList: undefined | Map<string, Set<string>>;
};

declare function validateCallParams(action: CallParams): ValidateCallParamsError[];
type ValidateCallParamsError = InvalidSaltError | InvalidDataError | InvalidBytecodeError | ValidateBaseCallParamsError;

/**
 * All errors that can occur during a TEVM call.
 * This type is strongly typed if using `throwOnFail: false`.
 *
 * @example
 * ```typescript
 * import { TevmCallError } from 'tevm/errors'
 * import { createMemoryClient, tevmCall } from 'tevm'
 *
 * const client = createMemoryClient()
 *
 * const result = await tevmCall(client, {
 *   throwOnFail: false,
 *   to: '0x...',
 *   data: '0x...',
 * })
 *
 * const errors = result.errors satisfies Array<TevmCallError> | undefined
 * if (errors) {
 *   errors.forEach((error) => console.error(error))
 * }
 * ```
 *
 * If `throwOnFail: true` is used (the default), the errors are thrown directly. This type can then be used to catch the errors.
 *
 * @example
 * ```typescript
 * import { TevmCallError } from 'tevm/errors'
 * import { createMemoryClient, tevmCall } from 'tevm'
 *
 * const client = createMemoryClient()
 *
 * try {
 *   await tevmCall(client, {
 *     to: '0x...',
 *     data: '0x...',
 *   })
 * } catch (error) {
 *   const typedError = error as TevmCallError
 *   switch (typedError.name) {
 *     case 'ValidateCallParamsError':
 *     case 'CallHandlerOptsError':
 *     case 'InternalError':
 *     case 'ExecutionError':
 *     case 'Revert':
 *     case 'HandleRunTxError':
 *     case 'ExecuteCallError':
 *       handleIt(typedError)
 *       break
 *     default:
 *       throw error
 *   }
 * }
 * ```
 */
type TevmCallError = ValidateCallParamsError | CallHandlerOptsError | InternalError | ExecutionError | RevertError | HandleRunTxError | ExecuteCallError;

/**
 * Result of a TEVM VM Call method.
 *
 * @example
 * ```typescript
 * import { createClient } from 'viem'
 * import { createTevmTransport, tevmCall } from 'tevm'
 * import { optimism } from 'tevm/common'
 * import { CallResult } from 'tevm/actions'
 *
 * const client = createClient({
 *   transport: createTevmTransport({}),
 *   chain: optimism,
 * })
 *
 * const callParams = {
 *   data: '0x...',
 *   bytecode: '0x...',
 *   gasLimit: 420n,
 * }
 *
 * const result: CallResult = await tevmCall(client, callParams)
 * console.log(result)
 * ```
 *
 * @see [tevmCall](https://tevm.sh/reference/tevm/memory-client/functions/tevmCall/)
 */
type CallResult<ErrorType = TevmCallError> = {
    /**
     * The call trace if tracing is enabled on call.
     *
     * @example
     * ```typescript
     * const trace = result.trace
     * trace.structLogs.forEach(console.log)
     * ```
     */
    trace?: TraceResult;
    /**
     * The access list if enabled on call.
     * Mapping of addresses to storage slots.
     *
     * @example
     * ```typescript
     * const accessList = result.accessList
     * console.log(accessList) // { "0x...": Set(["0x..."]) }
     * ```
     */
    accessList?: Record<Address, Set<Hex>>;
    /**
     * Preimages mapping of the touched accounts from the transaction (see `reportPreimages` option).
     */
    preimages?: Record<Hex, Hex>;
    /**
     * The returned transaction hash if the call was included in the chain.
     * Will not be defined if the call was not included in the chain.
     * Whether a call is included in the chain depends on the `createTransaction` option and the result of the call.
     *
     * @example
     * ```typescript
     * const txHash = result.txHash
     * if (txHash) {
     *   console.log(`Transaction included in the chain with hash: ${txHash}`)
     * }
     * ```
     */
    txHash?: Hex;
    /**
     * The transaction receipt status when the call was included in the chain.
     * Will be '0x1' for success or '0x0' for failure.
     * Only present when the call creates a transaction (createTransaction option is enabled).
     *
     * @example
     * ```typescript
     * const status = result.status
     * if (status === '0x1') {
     *   console.log('Transaction succeeded')
     * } else if (status === '0x0') {
     *   console.log('Transaction failed')
     * }
     * ```
     */
    status?: Hex;
    /**
     * Amount of gas left after execution.
     */
    gas?: bigint;
    /**
     * Amount of gas the code used to run within the EVM.
     * This only includes gas spent on the EVM execution itself and doesn't account for gas spent on other factors such as data storage.
     */
    executionGasUsed: bigint;
    /**
     * Array of logs that the contract emitted.
     *
     * @example
     * ```typescript
     * const logs = result.logs
     * logs?.forEach(log => console.log(log))
     * ```
     */
    logs?: Log[];
    /**
     * The gas refund counter as a uint256.
     */
    gasRefund?: bigint;
    /**
     * Amount of blob gas consumed by the transaction.
     */
    blobGasUsed?: bigint;
    /**
     * Address of created account during the transaction, if any.
     */
    createdAddress?: Address;
    /**
     * A set of accounts to selfdestruct.
     */
    selfdestruct?: Set<Address>;
    /**
     * Map of addresses which were created (used in EIP 6780).
     * Note the addresses are not actually created until the transaction is mined.
     */
    createdAddresses?: Set<Address>;
    /**
     * Encoded return value from the contract as a hex string.
     *
     * @example
     * ```typescript
     * const rawData = result.rawData
     * console.log(`Raw data returned: ${rawData}`)
     * ```
     */
    rawData: Hex;
    /**
     * Description of the exception, if any occurred.
     */
    errors?: ErrorType[];
    /**
     * Priority fee set by the transaction.
     */
    priorityFee?: bigint;
    /**
     * The base fee of the transaction.
     */
    baseFee?: bigint;
    /**
     * L1 fee that should be paid for the transaction.
     * Only included when an OP-Stack common is provided.
     *
     * @see [OP-Stack docs](https://docs.optimism.io/stack/transactions/fees)
     */
    l1Fee?: bigint;
    /**
     * Amount of L1 gas used to publish the transaction.
     * Only included when an OP-Stack common is provided.
     *
     * @see [OP-Stack docs](https://docs.optimism.io/stack/transactions/fees)
     */
    l1GasUsed?: bigint;
    /**
     * Current blob base fee known by the L2 chain.
     *
     * @see [OP-Stack docs](https://docs.optimism.io/stack/transactions/fees)
     */
    l1BlobFee?: bigint;
    /**
     * Latest known L1 base fee known by the L2 chain.
     * Only included when an OP-Stack common is provided.
     *
     * @see [OP-Stack docs](https://docs.optimism.io/stack/transactions/fees)
     */
    l1BaseFee?: bigint;
    /**
     * The amount of gas used in this transaction, which is paid for.
     * This contains the gas units that have been used on execution, plus the upfront cost,
     * which consists of calldata cost, intrinsic cost, and optionally the access list costs.
     * This is analogous to what `eth_estimateGas` would return. Does not include L1 fees.
     */
    totalGasSpent?: bigint;
    /**
     * The amount of ether used by this transaction. Does not include L1 fees.
     */
    amountSpent?: bigint;
    /**
     * The value that accrues to the miner by this transaction.
     */
    minerValue?: bigint;
};

/**
 * Parameters for the call handler, extending CallParams with event handlers
 * These event handlers are not JSON-serializable, so they are kept separate from the base CallParams
 */
type CallHandlerParams = CallParams & CallEvents;
/**
 * Executes a call against the VM, similar to `eth_call` but with more options for controlling the execution environment.
 *
 * This low-level function is used internally by higher-level functions like `contract` and `script`, which are designed to interact with deployed contracts or undeployed scripts, respectively.
 *
 * @param {CallHandlerParams} action - The parameters for the call, including optional event handlers.
 * @returns {Promise<CallResult>} The result of the call, including execution details and any returned data.
 * @throws {TevmCallError} If `throwOnFail` is true, returns `TevmCallError` as value.
 *
 * @example
 * ```typescript
 * import { createTevmNode } from 'tevm/node'
 * import { callHandler } from 'tevm/actions'
 *
 * const client = createTevmNode()
 *
 * const call = callHandler(client)
 *
 * const res = await call({
 *   to: '0x123...',
 *   data: '0x123...',
 *   from: '0x123...',
 *   gas: 1000000n,
 *   gasPrice: 1n,
 *   skipBalance: true,
 *   // Optional event handlers
 *   onStep: (step, next) => {
 *     console.log(`Executing ${step.opcode.name} at PC=${step.pc}`)
 *     next?.()
 *   }
 * })
 *
 * console.log(res)
 * ```
 *
 * @see {@link https://tevm.sh/reference/tevm/memory-client/functions/tevmCall | tevmCall}
 * @see {@link CallParams}
 * @see {@link CallResult}
 */
type CallHandler = (action: CallHandlerParams) => Promise<CallResult>;

/**
 * JSON-RPC request for `tevm_call`
 */
type CallJsonRpcRequest = JsonRpcRequest<'tevm_call', [
    params: SerializeToJson<Omit<CallParams, 'stateOverrideSet' | 'blockOverrideSet'>>,
    stateOverrideSet?: SerializeToJson<CallParams['stateOverrideSet']>,
    blockOverrideSet?: SerializeToJson<CallParams['blockOverrideSet']>
]>;

/**
 * JSON-RPC response for `tevm_call` procedure
 */
type CallJsonRpcResponse = JsonRpcResponse<'tevm_call', SerializeToJson<CallResult>, TevmCallError['code']>;

/**
 * Call JSON-RPC procedure executes a call against the tevm EVM
 */
type CallJsonRpcProcedure = (request: CallJsonRpcRequest) => Promise<CallJsonRpcResponse>;

declare function callHandler(client: _tevm_node.TevmNode, { throwOnFail: defaultThrowOnFail }?: {
    throwOnFail?: boolean | undefined;
}): CallHandler;

declare function callHandlerResult(evmResult: _tevm_vm.RunTxResult & _tevm_evm.EvmResult, txHash: _tevm_utils.Hex | undefined, trace: TraceResult | undefined, accessList: Map<string, Set<string>> | undefined): CallResult;

declare function callProcedure(client: _tevm_node.TevmNode): CallJsonRpcProcedure;

declare function cloneVmWithBlockTag(client: _tevm_node.TevmNode, block: _tevm_block.Block): Promise<_tevm_vm.Vm | ForkError | InternalError>;

type TevmMineError = InternalError | InvalidAddressError | InvalidParamsError | InvalidRequestError;

declare function handleAutomining(client: _tevm_node.TevmNode, txHash?: viem.Hex, isGasMining?: boolean, mineAllTx?: boolean): Promise<{
    blockHashes?: undefined;
    errors?: TevmMineError[];
} | undefined>;

declare function handlePendingTransactionsWarning(client: _tevm_node.TevmNode, params: CallParams, code: string | undefined, deployedBytecode: string | undefined): Promise<void>;

declare function handleTransactionCreation(client: _tevm_node.TevmNode, params: CallParams, executedCall: ExecuteCallResult, evmInput: _tevm_evm.EvmRunCallOpts): Promise<{
    hash: _tevm_utils.Hex | undefined;
    errors?: never;
} | {
    hash?: never;
    errors: Array<TevmCallError>;
}>;

declare function shouldCreateTransaction(params: CallParams, runTxResult: _tevm_vm.RunTxResult): boolean;
declare function shouldAddToBlockchain(params: CallParams, runTxResult: _tevm_vm.RunTxResult): boolean;

/**
 * @internal
 * Zod validator for a valid call action
 */
declare const zCallParams: z.ZodIntersection<z.ZodObject<{
    throwOnFail: z.ZodOptional<z.ZodBoolean>;
    createTrace: z.ZodOptional<z.ZodBoolean>;
    createAccessList: z.ZodOptional<z.ZodBoolean>;
    createTransaction: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    addToMempool: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    addToBlockchain: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    skipBalance: z.ZodOptional<z.ZodBoolean>;
    gasRefund: z.ZodOptional<z.ZodBigInt>;
    blockTag: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"latest">, z.ZodLiteral<"earliest">, z.ZodLiteral<"pending">, z.ZodLiteral<"safe">, z.ZodLiteral<"finalized">, z.ZodBigInt, z.ZodPipe<z.ZodNumber, z.ZodTransform<bigint, number>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>]>>;
    gasPrice: z.ZodOptional<z.ZodBigInt>;
    origin: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    caller: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    gas: z.ZodOptional<z.ZodBigInt>;
    value: z.ZodOptional<z.ZodBigInt>;
    depth: z.ZodOptional<z.ZodNumber>;
    selfdestruct: z.ZodOptional<z.ZodSet<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>>;
    to: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    blobVersionedHashes: z.ZodOptional<z.ZodArray<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    stateOverrideSet: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>, z.ZodObject<{
        balance: z.ZodOptional<z.ZodBigInt>;
        nonce: z.ZodOptional<z.ZodBigInt>;
        code: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
        state: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
        stateDiff: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    }, z.core.$strict>>>;
    blockOverrideSet: z.ZodOptional<z.ZodObject<{
        number: z.ZodOptional<z.ZodBigInt>;
        time: z.ZodOptional<z.ZodBigInt>;
        gasLimit: z.ZodOptional<z.ZodBigInt>;
        coinbase: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
        baseFee: z.ZodOptional<z.ZodBigInt>;
        blobBaseFee: z.ZodOptional<z.ZodBigInt>;
    }, z.core.$strict>>;
    maxFeePerGas: z.ZodOptional<z.ZodBigInt>;
    maxPriorityFeePerGas: z.ZodOptional<z.ZodBigInt>;
    onStep: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onNewContract: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onBeforeMessage: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onAfterMessage: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
}, z.core.$strip>, z.ZodObject<{
    data: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
    salt: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
    code: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
    deployedBytecode: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
}, z.core.$strip>>;

/**
 * Parameters to execute a call on a contract with TEVM.
 *
 * This type combines the parameters required for encoding function data with additional call parameters.
 *
 * @template TAbi - The ABI type.
 * @template TFunctionName - The function name type from the ABI.
 * @template TThrowOnFail - The type indicating whether to throw on failure.
 *
 * @example
 * ```typescript
 * import { createClient } from 'viem'
 * import { contractHandler } from 'tevm/actions'
 * import { Abi } from 'viem/utils'
 *
 * const client = createClient({ transport: http('https://mainnet.optimism.io')({}) })
 *
 * const params: ContractParams<Abi, 'myFunction'> = {
 *   abi: [...], // ABI array
 *   functionName: 'myFunction',
 *   args: [arg1, arg2],
 *   to: '0x123...',
 *   from: '0x123...',
 *   gas: 1000000n,
 *   gasPrice: 1n,
 *   skipBalance: true,
 * }
 *
 * const contractCall = contractHandler(client)
 * const res = await contractCall(params)
 * console.log(res)
 * ```
 *
 * @see {@link https://tevm.sh/reference/tevm/memory-client/functions/tevmContract | tevmContract}
 * @see {@link BaseCallParams}
 * @see {@link EncodeFunctionDataParameters}
 */
type ContractParams<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends ContractFunctionName<TAbi> = ContractFunctionName<TAbi>, TThrowOnFail extends boolean = boolean> = EncodeFunctionDataParameters<TAbi, TFunctionName> & BaseCallParams<TThrowOnFail> & ({
    /**
     * The address of the contract to call.
     */
    readonly to: Address;
    /**
     * The deployed bytecode to execute at the contract address.
     * If not provided, the code will be fetched from state.
     */
    readonly deployedBytecode?: Hex$1;
    /**
     * Alias for deployedBytecode.
     */
    readonly code?: Hex$1;
} | {
    /**
     * The address of the contract to call.
     */
    readonly to?: Address;
    /**
     * The deployed bytecode to execute at the contract address.
     * If not provided, the code will be fetched from state.
     */
    readonly deployedBytecode?: Hex$1;
    /**
     * Alias for deployedBytecode.
     */
    readonly code: Hex$1;
} | {
    /**
     * The address of the contract to call.
     */
    readonly to?: Address;
    /**
     * The deployed bytecode to execute at the contract address.
     * If not provided, the code will be fetched from state.
     */
    readonly deployedBytecode: Hex$1;
    /**
     * Alias for deployedBytecode.
     */
    readonly code?: Hex$1;
});

/**
 * TEVM Contract Error type.
 *
 * This type represents all errors that can occur during a TEVM contract call.
 * It extends from the `TevmCallError` type, inheriting all possible call errors.
 *
 * @example
 * ```typescript
 * import { createClient } from 'viem'
 * import { contractHandler } from 'tevm/actions'
 * import { Abi } from 'viem/utils'
 * import { TevmContractError } from 'tevm/errors'
 *
 * const client = createClient({ transport: http('https://mainnet.optimism.io')({}) })
 *
 * try {
 *   const contractCall = contractHandler(client)
 *   const result = await contractCall({
 *     abi: [...], // ABI array
 *     functionName: 'myFunction',
 *     args: [arg1, arg2],
 *     to: '0x123...',
 *     from: '0x123...',
 *     gas: 1000000n,
 *     gasPrice: 1n,
 *     skipBalance: true,
 *   })
 * } catch (error) {
 *   const typedError = error as TevmContractError
 *   console.error('Contract call failed with error:', typedError)
 * }
 * ```
 *
 * @see {@link TevmCallError}
 */
type TevmContractError = TevmCallError;

/**
 * The result type for a TEVM contract call.
 *
 * This type extends the `CallResult` type with additional contract-specific fields, and it supports both success and error states.
 *
 * @template TAbi - The ABI type.
 * @template TFunctionName - The function name type from the ABI.
 * @template ErrorType - The error type.
 *
 * @example
 * ```typescript
 * import { createClient } from 'viem'
 * import { contractHandler } from 'tevm/actions'
 * import { Abi } from 'viem/utils'
 *
 * const client = createClient({ transport: http('https://mainnet.optimism.io')({}) })
 *
 * const params: ContractParams<Abi, 'myFunction'> = {
 *   abi: [...], // ABI array
 *   functionName: 'myFunction',
 *   args: [arg1, arg2],
 *   to: '0x123...',
 *   from: '0x123...',
 *   gas: 1000000n,
 *   gasPrice: 1n,
 *   skipBalance: true,
 * }
 *
 * const contractCall = contractHandler(client)
 * const result: ContractResult<Abi, 'myFunction'> = await contractCall(params)
 *
 * if (result.errors) {
 *   console.error('Contract call failed:', result.errors)
 * } else {
 *   console.log('Contract call succeeded:', result.data)
 * }
 * ```
 *
 * @see {@link CallResult}
 */
type ContractResult<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends ContractFunctionName<TAbi> = ContractFunctionName<TAbi>, ErrorType = TevmContractError> = (Omit<CallResult, 'errors'> & {
    errors?: never;
    /**
     * The parsed data returned from the contract function call.
     */
    data: DecodeFunctionResultReturnType<TAbi, TFunctionName>;
}) | (CallResult<ErrorType> & {
    data?: never;
});

/**
 * Handler for executing contract interactions with the TEVM.
 *
 * This handler is adapted from viem and is designed to closely match the viem `contractRead`/`contractWrite` API.
 * It encodes the ABI, function name, and arguments to perform the contract call.
 *
 * @param {ContractParams<TAbi, TFunctionName> & CallEvents} action - The parameters for the contract call, including ABI, function name, and arguments, with optional event handlers.
 * @returns {Promise<ContractResult<TAbi, TFunctionName>>} The result of the contract call, including execution details and any returned data.
 * @throws {TevmCallError} If `throwOnFail` is true, returns `TevmCallError` as value.
 *
 * @example
 * ```typescript
 * import { createTevmNode } from 'tevm/node'
 * import { contractHandler } from 'tevm/actions'
 *
 * const client = createTevmNode()
 *
 * const contractCall = contractHandler(client)
 *
 * const res = await contractCall({
 *   abi: [...], // ABI array
 *   functionName: 'myFunction',
 *   args: [arg1, arg2],
 *   to: '0x123...',
 *   from: '0x123...',
 *   gas: 1000000n,
 *   gasPrice: 1n,
 *   skipBalance: true,
 *   // Optional event handlers
 *   onStep: (step, next) => {
 *     console.log(`Executing ${step.opcode.name} at PC=${step.pc}`)
 *     next?.()
 *   }
 * })
 *
 * console.log(res)
 * ```
 *
 * @see {@link https://tevm.sh/reference/tevm/memory-client/functions/tevmContract | tevmContract}
 * @see {@link ContractParams}
 * @see {@link ContractResult}
 * @template TAbi - The ABI type.
 * @template TFunctionName - The function name type from the ABI.
 */
type ContractHandler = <TAbi extends Abi$1 | readonly unknown[] = Abi$1, TFunctionName extends ContractFunctionName<TAbi> = ContractFunctionName<TAbi>>(action: ContractParams<TAbi, TFunctionName> & CallEvents) => Promise<ContractResult<TAbi, TFunctionName>>;

declare function contractHandler(client: _tevm_node.TevmNode, { throwOnFail: throwOnFailDefault }?: {
    throwOnFail?: boolean | undefined;
}): ContractHandler;

declare function validateContractParams(action: ContractParams): Array<ValidateContractParamsError>;
type ValidateContractParamsError = InvalidAbiError | InvalidAddressError | InvalidArgsError | InvalidFunctionNameError | ValidateBaseCallParamsError;

/**
 * Zod validator for a valid contract action
 */
declare const zContractParams: z.ZodIntersection<z.ZodObject<{
    throwOnFail: z.ZodOptional<z.ZodBoolean>;
    createTrace: z.ZodOptional<z.ZodBoolean>;
    createAccessList: z.ZodOptional<z.ZodBoolean>;
    createTransaction: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    addToMempool: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    addToBlockchain: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    skipBalance: z.ZodOptional<z.ZodBoolean>;
    gasRefund: z.ZodOptional<z.ZodBigInt>;
    blockTag: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"latest">, z.ZodLiteral<"earliest">, z.ZodLiteral<"pending">, z.ZodLiteral<"safe">, z.ZodLiteral<"finalized">, z.ZodBigInt, z.ZodPipe<z.ZodNumber, z.ZodTransform<bigint, number>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>]>>;
    gasPrice: z.ZodOptional<z.ZodBigInt>;
    origin: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    caller: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    gas: z.ZodOptional<z.ZodBigInt>;
    value: z.ZodOptional<z.ZodBigInt>;
    depth: z.ZodOptional<z.ZodNumber>;
    selfdestruct: z.ZodOptional<z.ZodSet<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>>;
    to: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    blobVersionedHashes: z.ZodOptional<z.ZodArray<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    stateOverrideSet: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>, z.ZodObject<{
        balance: z.ZodOptional<z.ZodBigInt>;
        nonce: z.ZodOptional<z.ZodBigInt>;
        code: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
        state: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
        stateDiff: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    }, z.core.$strict>>>;
    blockOverrideSet: z.ZodOptional<z.ZodObject<{
        number: z.ZodOptional<z.ZodBigInt>;
        time: z.ZodOptional<z.ZodBigInt>;
        gasLimit: z.ZodOptional<z.ZodBigInt>;
        coinbase: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
        baseFee: z.ZodOptional<z.ZodBigInt>;
        blobBaseFee: z.ZodOptional<z.ZodBigInt>;
    }, z.core.$strict>>;
    maxFeePerGas: z.ZodOptional<z.ZodBigInt>;
    maxPriorityFeePerGas: z.ZodOptional<z.ZodBigInt>;
    onStep: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onNewContract: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onBeforeMessage: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onAfterMessage: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
}, z.core.$strip>, z.ZodObject<{
    to: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    abi: z.ZodReadonly<any>;
    args: z.ZodOptional<z.ZodArray<z.ZodAny>>;
    functionName: z.ZodString;
    code: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
    deployedBytecode: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
}, z.core.$strip>>;

/**
 * Defines the parameters used for deploying a contract on TEVM.
 * This type extends the base call parameters used for typical TEVM calls,
 * with the addition of deployment-specific settings. By default, `createTransaction`
 * is set to true, because deployments result in state changes that need to be mined.
 *
 * The `salt` parameter supports the use of CREATE2, allowing for deterministic address deployment.
 *
 * @example
 * ```typescript
 * import { createClient } from 'viem'
 * import { deployHandler } from 'tevm/actions'
 *
 * const client = createClient({
 *   transport: createTevmTransport({
 *     fork: { transport: http('https://mainnet.optimism.io')({}) }
 *   })
 * })
 *
 * const deployParams = {
 *   bytecode: '0x6000366000...',
 *   abi: [{
 *     inputs: [],
 *     stateMutability: 'nonpayable',
 *     type: 'constructor'
 *   }],
 *   args: [],
 *   salt: '0x0000...0001',  // Optional CREATE2 salt for deterministic deployment
 *   from: '0xYourAccountAddress',
 *   gas: 1000000n,
 *   createTransaction: true
 * }
 *
 * const result = await deployHandler(client)(deployParams)
 * console.log('Deployed contract address:', result.createdAddress)
 * ```
 *
 * @template TThrowOnFail - Indicates whether the function should throw on failure.
 * @template TAbi - The ABI type, typically including constructor definitions.
 * @template THasConstructor - Determines whether the ABI includes a constructor.
 * @template TAllArgs - Types of the constructor arguments for the deployment.
 */
type DeployParams<TThrowOnFail extends boolean = boolean, TAbi extends Abi$1 | readonly unknown[] = Abi$1, THasConstructor = TAbi extends Abi$1 ? Abi$1 extends TAbi ? true : [Extract<TAbi[number], {
    type: 'constructor';
}>] extends [never] ? false : true : true, TAllArgs = ContractConstructorArgs<TAbi>> = Omit<BaseCallParams<TThrowOnFail>, 'to'> & {
    /**
     * An optional CREATE2 salt, if deploying with CREATE2 for a predictable contract address.
     */
    readonly salt?: Hex;
} & EncodeDeployDataParameters<TAbi, THasConstructor, TAllArgs>;

/**
 * Represents the result of a contract deployment on TEVM.
 * This type extends the CallResult type, which includes properties like gas usage, logs, and errors.
 *
 * @example
 * ```typescript
 * import { createClient } from 'viem'
 * import { deployHandler } from 'tevm/actions'
 *
 * const client = createClient({
 *   transport: createTevmTransport({
 *     fork: { transport: http('https://mainnet.optimism.io')({}) }
 *   })
 * })
 *
 * const deployParams = {
 *   bytecode: '0x6000366000...',
 *   abi: [{
 *     inputs: [],
 *     stateMutability: 'nonpayable',
 *     type: 'constructor'
 *   }],
 *   args: [],
 *   from: '0xYourAccountAddress',
 *   gas: 1000000n,
 *   createTransaction: true
 * }
 *
 * const result: DeployResult = await deployHandler(client)(deployParams)
 * console.log('Deployed contract address:', result.createdAddress)
 * console.log('Gas used:', result.executionGasUsed)
 * ```
 *
 * @see CallResult for a detailed breakdown of the available properties.
 */
type DeployResult = CallResult;

/**
 * Handler for deploying contracts on TEVM.
 * This handler is used to deploy a contract by specifying the deployment parameters, ABI, and constructor arguments.
 *
 * @example
 * ```typescript
 * import { createClient } from 'viem'
 * import { deployHandler } from 'tevm/actions'
 *
 * const client = createClient({
 *   transport: createTevmTransport({ fork: { transport: http('https://mainnet.optimism.io')({}) } })
 * })
 *
 * const handler = deployHandler(client)
 *
 * const result = await handler({
 *   abi: [...], // ABI array
 *   bytecode: '0x...', // Contract bytecode
 *   args: [arg1, arg2], // Constructor arguments
 *   from: '0x123...',
 *   gas: 1000000n,
 *   gasPrice: 1n,
 *   // Optional event handlers
 *   onStep: (step, next) => {
 *     console.log(`Executing ${step.opcode.name} at PC=${step.pc}`)
 *     next?.()
 *   }
 * })
 * console.log(result)
 * ```
 *
 * @template TThrowOnFail - Indicates whether to throw an error on failure.
 * @template TAbi - The ABI type of the contract.
 * @template THasConstructor - Indicates whether the contract has a constructor.
 * @template TAllArgs - The types of the constructor arguments.
 *
 * @param {DeployParams<TThrowOnFail, TAbi, THasConstructor, TAllArgs> & CallEvents} action - The deployment parameters and optional event handlers.
 * @returns {Promise<DeployResult>} The result of the deployment.
 */
type DeployHandler = <TThrowOnFail extends boolean = boolean, TAbi extends Abi$1 | readonly unknown[] = Abi$1, THasConstructor = TAbi extends Abi$1 ? Abi$1 extends TAbi ? true : [Extract<TAbi[number], {
    type: 'constructor';
}>] extends [never] ? false : true : true, TAllArgs = ContractConstructorArgs<TAbi>>(action: DeployParams<TThrowOnFail, TAbi, THasConstructor, TAllArgs> & CallEvents) => Promise<DeployResult>;

declare function deployHandler(client: _tevm_node.TevmNode, { throwOnFail: throwOnFailDefault }?: {
    throwOnFail?: boolean | undefined;
}): DeployHandler;

type TevmDeployError = TevmCallError | InvalidRequestError;

type DumpStateParams<TThrowOnFail extends boolean = boolean> = BaseParams<TThrowOnFail> & {
    /**
     * Block tag to fetch account from
     * - bigint for block number
     * - hex string for block hash
     * - 'latest', 'earliest', 'pending', 'forked' etc. tags
     */
    readonly blockTag?: BlockParam;
};

/**
 * Errors that can occur during the dumpState method.
 *
 * This type represents the possible errors that can be encountered while executing the
 * `dumpState` method in TEVM. It includes internal errors, invalid address errors, and
 * invalid parameter errors.
 */
type TevmDumpStateError = InternalError | InvalidAddressError | InvalidParamsError;

/**
 * Result of the dumpState method.
 *
 * This type represents the possible results of executing the `dumpState` method in TEVM.
 * It includes the serialized TEVM state and any errors that may have occurred.
 */
type DumpStateResult<ErrorType = TevmDumpStateError> = {
    /**
     * The serialized TEVM state.
     *
     * This property contains the entire state of the TEVM, serialized into a JSON-compatible
     * format. This state can be used for debugging, analysis, or state persistence.
     */
    state: SerializableTevmState;
    /**
     * Description of the exception, if any occurred.
     *
     * This property contains an array of errors that may have occurred during the execution
     * of the `dumpState` method. Each error provides detailed information about what went wrong.
     */
    errors?: ErrorType[];
};

/**
 * Dumps the current state of the VM into a JSON-serializable object.
 *
 * This handler allows you to capture the entire state of the VM, which can be useful for
 * debugging, testing, or persisting the state across sessions.
 *
 * @example
 * ```typescript
 * // Dumping the state
 * const { state } = await tevm.dumpState()
 * fs.writeFileSync('state.json', JSON.stringify(state))
 * ```
 *
 * @example
 * ```typescript
 * // Loading the state
 * const state = JSON.parse(fs.readFileSync('state.json'))
 * await tevm.loadState({ state })
 * ```
 *
 * @param params - Optional parameters to customize the state dumping process.
 * @returns A promise that resolves to a `DumpStateResult` object containing the state data.
 *
 * @see LoadStateHandler for loading the dumped state back into the VM.
 */
type DumpStateHandler = (params?: DumpStateParams) => Promise<DumpStateResult>;

/**
 * The JSON-RPC request for the `tevm_dumpState` method
 */
type DumpStateJsonRpcRequest = JsonRpcRequest<'tevm_dumpState', []>;

/**
 * The response to the `tevm_dumpState` JSON-RPC request.
 */
type DumpStateJsonRpcResponse = JsonRpcResponse<'tevm_dumpState', SerializeToJson<{
    state: ParameterizedTevmState;
}>, TevmDumpStateError['code']>;

/**
 * Procedure for handling tevm_dumpState JSON-RPC requests
 * @returns the state as a JSON-RPC successful result
 * @example
 * const result = await tevm.request({
 *.   method: 'tevm_DumpState',
 *    params: [],
 *.   id: 1,
 *   jsonrpc: '2.0'
 *. }
 * console.log(result) // { jsonrpc: '2.0', id: 1, method: 'tevm_dumpState', result: {'0x...': '0x....', ...}}
 */
type DumpStateJsonRpcProcedure = (request: DumpStateJsonRpcRequest) => Promise<DumpStateJsonRpcResponse>;

declare function dumpStateHandler(client: _tevm_node.TevmNode, options?: {
    throwOnFail?: boolean | undefined;
}): DumpStateHandler;

declare function dumpStateProcedure(client: _tevm_node.TevmNode): DumpStateJsonRpcProcedure;

/**
 * Params taken by `eth_accounts` handler (no params)
 */
type EthAccountsParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_blockNumber` procedure (no params)
 */
type EthBlockNumberParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_call` procedure
 */
type EthCallParams = {
    /**
     * The address from which the transaction is sent. Defaults to zero address
     */
    readonly from?: Address;
    /**
     * The address to which the transaction is addressed. Defaults to zero address
     */
    readonly to?: Address;
    /**
     * The integer of gas provided for the transaction execution
     */
    readonly gas?: bigint;
    /**
     * The integer of gasPrice used for each paid gas
     */
    readonly gasPrice?: bigint;
    /**
     * The integer of value sent with this transaction
     */
    readonly value?: bigint;
    /**
     * The hash of the method signature and encoded parameters. For more information, see the Contract ABI description in the Solidity documentation
     * Defaults to zero data
     */
    readonly data?: Hex;
    /**
     * The block number hash or block tag
     */
    readonly blockTag?: BlockParam;
    /**
     * The state override set to provide different state values while executing the call
     */
    readonly stateOverrideSet?: StateOverrideSet;
    /**
     * The block override set to provide different block values while executing the call
     */
    readonly blockOverride?: BlockOverrideSet;
};
/**
 * Based on the JSON-RPC request for `eth_chainId` procedure
 */
type EthChainIdParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_coinbase` procedure
 */
type EthCoinbaseParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_estimateGas` procedure
 * This type is a placeholder
 */
type EthEstimateGasParams = CallParams;
/**
 * Based on the JSON-RPC request for `eth_hashrate` procedure
 */
type EthHashrateParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_gasPrice` procedure
 */
type EthGasPriceParams = EmptyParams;
/**
 *Based on the  JSON-RPC request for `eth_getBalance` procedure
 */
type EthGetBalanceParams = {
    address: Address;
    blockTag?: BlockParam;
};
/**
 * Based on the JSON-RPC request for `eth_getBlockByHash` procedure
 */
type EthGetBlockByHashParams = {
    readonly blockHash: Hex;
    readonly fullTransactionObjects: boolean;
};
/**
 * Based on the JSON-RPC request for `eth_getBlockByNumber` procedure
 */
type EthGetBlockByNumberParams = {
    readonly blockTag?: BlockParam;
    readonly fullTransactionObjects: boolean;
};
/**
 * Based on the JSON-RPC request for `eth_getBlockTransactionCountByHash` procedure
 */
type EthGetBlockTransactionCountByHashParams = {
    hash: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getBlockTransactionCountByNumber` procedure
 */
type EthGetBlockTransactionCountByNumberParams = {
    readonly blockTag?: BlockParam;
};
/**
 * Based on the JSON-RPC request for `eth_getCode` procedure
 */
type EthGetCodeParams = {
    readonly address: Address;
    readonly blockTag?: BlockParam;
};
/**
 * Based on the JSON-RPC request for `eth_getFilterChanges` procedure
 */
type EthGetFilterChangesParams = {
    readonly filterId: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getFilterLogs` procedure
 */
type EthGetFilterLogsParams = {
    readonly filterId: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getLogs` procedure
 */
type EthGetLogsParams = {
    readonly filterParams: FilterParams;
};
/**
 * Based on the JSON-RPC request for `eth_getStorageAt` procedure
 */
type EthGetStorageAtParams = {
    readonly address: Address;
    readonly position: Hex;
    readonly blockTag?: BlockParam;
};
/**
 * Based on the JSON-RPC request for `eth_getTransactionCount` procedure
 */
type EthGetTransactionCountParams = {
    readonly address: Address;
    readonly blockTag?: BlockParam;
};
/**
 * Based on the JSON-RPC request for `eth_getUncleCountByBlockHash` procedure
 */
type EthGetUncleCountByBlockHashParams = {
    readonly hash: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getUncleCountByBlockNumber` procedure
 */
type EthGetUncleCountByBlockNumberParams = {
    readonly blockTag?: BlockParam;
};
/**
 * Based on the JSON-RPC request for `eth_getTransactionByHash` procedure
 */
type EthGetTransactionByHashParams = {
    readonly data: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getTransactionByBlockHashAndIndex` procedure
 */
type EthGetTransactionByBlockHashAndIndexParams = {
    readonly blockTag?: Hex;
    readonly index: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getTransactionByBlockNumberAndIndex` procedure
 */
type EthGetTransactionByBlockNumberAndIndexParams = {
    readonly blockTag?: BlockParam;
    readonly index: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getTransactionReceipt` procedure
 */
type EthGetTransactionReceiptParams = {
    readonly hash: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getUncleByBlockHashAndIndex` procedure
 */
type EthGetUncleByBlockHashAndIndexParams = {
    readonly blockHash: Hex;
    readonly uncleIndex: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_getUncleByBlockNumberAndIndex` procedure
 */
type EthGetUncleByBlockNumberAndIndexParams = {
    readonly blockTag?: BlockParam;
    readonly uncleIndex: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_mining` procedure
 */
type EthMiningParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_protocolVersion` procedure
 */
type EthProtocolVersionParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_sendRawTransaction` procedure
 * This type is a placeholder
 */
type EthSendRawTransactionParams = {
    readonly data: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_sendTransaction` procedure
 * This type is a placeholder
 * @experimental
 */
type EthSendTransactionParams = CallParams;
/**
 * Based on the JSON-RPC request for `eth_sign` procedure
 * @experimental
 */
type EthSignParams = {
    readonly address: Address;
    readonly data: Hex;
};
/**
 * Based on the JSON-RPC request for `eth_signTransaction` procedure
 * @experimental
 */
type EthSignTransactionParams = {
    /**
     * The address from which the transaction is sent from
     */
    readonly from: Address;
    /**
     * The address the transaction is directed to. Optional if
     * creating a contract
     */
    readonly to?: Address;
    /**
     * The gas provded for transaction execution. It will return unused gas.
     * Default value is 90000
     */
    readonly gas?: bigint;
    /**
     * Integer of the gasPrice used for each paid gas, in Wei.
     * If not provided tevm will default to the eth_gasPrice value
     */
    readonly gasPrice?: bigint;
    /**
     * Integer of the value sent with this transaction, in Wei.
     */
    readonly value?: bigint;
    /**
     * The compiled code of a contract OR the hash of the invoked method signature and encoded parameters.
     * Optional if creating a contract.
     */
    readonly data?: Hex;
    /**
     * Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.
     */
    readonly nonce?: bigint;
};
/**
 * Based on the JSON-RPC request for `eth_syncing` procedure (no params)
 */
type EthSyncingParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_newFilter` procedure
 */
type EthNewFilterParams = FilterParams;
/**
 * Based on the JSON-RPC request for `eth_newBlockFilter` procedure (no params)
 */
type EthNewBlockFilterParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_newPendingTransactionFilter` procedure
 */
type EthNewPendingTransactionFilterParams = EmptyParams;
/**
 * Based on the JSON-RPC request for `eth_uninstallFilter` procedure
 */
type EthUninstallFilterParams = {
    readonly filterId: Hex;
};
type EthParams = EthAccountsParams | EthAccountsParams | EthBlockNumberParams | EthCallParams | EthChainIdParams | EthCoinbaseParams | EthEstimateGasParams | EthHashrateParams | EthGasPriceParams | EthGetBalanceParams | EthGetBlockByHashParams | EthGetBlockByNumberParams | EthGetBlockTransactionCountByHashParams | EthGetBlockTransactionCountByNumberParams | EthGetCodeParams | EthGetFilterChangesParams | EthGetFilterLogsParams | EthGetLogsParams | EthGetStorageAtParams | EthGetTransactionCountParams | EthGetUncleCountByBlockHashParams | EthGetUncleCountByBlockNumberParams | EthGetTransactionByHashParams | EthGetTransactionByBlockHashAndIndexParams | EthGetTransactionByBlockNumberAndIndexParams | EthGetTransactionReceiptParams | EthGetUncleByBlockHashAndIndexParams | EthGetUncleByBlockNumberAndIndexParams | EthMiningParams | EthProtocolVersionParams | EthSendRawTransactionParams | EthSendTransactionParams | EthSignParams | EthSignTransactionParams | EthSyncingParams | EthNewFilterParams | EthNewBlockFilterParams | EthNewPendingTransactionFilterParams | EthUninstallFilterParams;

/**
 * Helper type to ensure exactly one property from a set is provided
 */
type ExactlyOne<T, K extends keyof T> = {
    [P in K]: {
        [Q in P]: T[P];
    } & {
        [Q in Exclude<K, P>]?: never;
    };
}[K];

/**
 * Config params for trace calls
 */
type TraceParams<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean> = {
    /**
     * The type of tracer
     * Supported tracers: callTracer, prestateTracer, 4byteTracer
     */
    readonly tracer?: TTracer;
    /**
     * A duration string of decimal numbers that overrides the default timeout of 5 seconds for JavaScript-based tracing calls. Max timeout is "10s". Valid time units are "ns", "us", "ms", "s" each with optional fraction, such as "300ms" or "2s45ms".
     * @example "10s"
     */
    readonly timeout?: string;
    /**
     * object to specify configurations for the tracer
     */
    readonly tracerConfig?: {
        /**
         * boolean Setting this to true will only trace the main (top-level) call and none of the sub-calls. This avoids extra processing for each call frame if only the top-level call info are required (useful for getting revertReason).
         */
        /**
         * boolean Setting this to true will disable storage capture. This avoids extra processing for each call frame if storage is not required.
         */
        /**
         *
         */
        /**
         * boolean Setting this to true will disable stack capture. This avoids extra processing for each call frame if stack is not required.
         */
        /**
         * When using the prestateTracer, setting this to true will make the tracer return only the state difference between before and after execution.
         * Default is false which returns the full state of all touched accounts.
         */
        readonly diffMode?: TTracer extends 'prestateTracer' ? TDiffMode : never;
    };
};
/**
 * Params taken by `debug_traceTransaction` handler
 */
type DebugTraceTransactionParams<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean, TTTThrowOnError extends boolean = boolean> = BaseParams<TTTThrowOnError> & TraceParams<TTracer, TDiffMode> & {
    /**
     * The transaction hash
     */
    readonly transactionHash: Hex;
};
/**
 * Params taken by `debug_traceCall` handler
 */
type DebugTraceCallParams<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean> = TraceParams<TTracer, TDiffMode> & EthCallParams;
/**
 * Params taken by `debug_traceBlock` handler
 */
type DebugTraceBlockParams<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean> = TraceParams<TTracer, TDiffMode> & ExactlyOne<{
    /**
     * Block number or hash or tag to trace
     */
    readonly blockTag: Hex | Uint8Array | number | bigint | BlockTag;
    /**
     * Block number or hash or tag to trace
     */
    readonly block: Hex | Uint8Array | number | bigint | BlockTag;
    /**
     * Block hash to trace
     */
    readonly blockHash: Hex | Uint8Array | number | bigint;
    /**
     * Block number to trace
     */
    readonly blockNumber: Hex | Uint8Array | number | bigint;
}, 'block' | 'blockTag' | 'blockHash' | 'blockNumber'>;
/**
 * State filters
 */
declare const debugTraceStateFilters: readonly ["blockchain", "blockchain.blocksByNumber", "blockchain.initOptions", "evm", "evm.opcodes", "evm.precompiles", "evm.common", "evm.common.eips", "evm.common.hardfork", "evm.common.consensus", "node", "node.status", "node.mode", "node.miningConfig", "node.filters", "node.impersonatedAccount", "pool", "pool.pool", "pool.txsByHash", "pool.txsByNonce", "pool.txsInNonceOrder", "pool.txsInPool", "stateManager", "stateManager.storage", "stateManager.stateRoots"];
/**
 * Type for state filters
 */
type DebugTraceStateFilter = (typeof debugTraceStateFilters)[number];
/**
 * Params taken by `debug_traceState` handler
 */
type DebugTraceStateParams<TStateFilters extends readonly DebugTraceStateFilter[] = readonly DebugTraceStateFilter[]> = {
    /**
     * Filters to apply to the state
     */
    readonly filters?: TStateFilters;
    /**
     * Timeout for the state trace
     */
    readonly timeout?: string;
};

/**
 * Helper type to get a nested property from an object
 */
type GetPath<T, TPath extends string> = TPath extends `${infer A}.${infer Rest}` ? A extends keyof T ? {
    [K in A]: GetPath<T[A], Rest>;
} : never : TPath extends keyof T ? {
    [K in TPath]: T[TPath];
} : never;

/**
 * Helper type to convert a union to an intersection
 */
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

/**
 * Result from `debug_traceTransaction`
 */
type DebugTraceTransactionResult<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean> = TTracer extends 'callTracer' ? CallTraceResult : TTracer extends 'prestateTracer' ? PrestateTraceResult<TDiffMode> : TTracer extends '4byteTracer' ? FourbyteTraceResult : TraceResult;
/**
 * Result from `debug_traceCall`
 */
type DebugTraceCallResult<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean> = TTracer extends 'callTracer' ? CallTraceResult : TTracer extends 'prestateTracer' ? PrestateTraceResult<TDiffMode> : TTracer extends '4byteTracer' ? FourbyteTraceResult : TraceResult;
/**
 * Result from `debug_traceBlock`.
 *
 * Returns an array of transaction traces
 */
type DebugTraceBlockResult<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean> = Array<{
    /**
     * Transaction hash
     */
    txHash: Hex;
    /**
     * Transaction index in the block
     */
    txIndex: number;
    /**
     * Trace result for this transaction
     */
    result: DebugTraceTransactionResult<TTracer, TDiffMode>;
}>;
/**
 * Complete state object structure
 */
type DebugTraceStateObject = {
    readonly blockchain: {
        readonly blocksByNumber: Map<bigint, Block$1 | undefined>;
        readonly initOptions: ChainOptions;
    };
    readonly evm: {
        readonly opcodes: Map<number, {
            readonly code: number;
            readonly name: string;
            readonly fullName: string;
            readonly fee: number;
            readonly feeBigInt: bigint;
            readonly isAsync: boolean;
            readonly dynamicGas: boolean;
            readonly isInvalid: boolean;
        }>;
        readonly precompiles: Map<string, (input: PrecompileInput) => Promise<ExecResult> | ExecResult>;
        readonly common: {
            readonly eips: number[];
            readonly hardfork: string;
            readonly consensus: {
                readonly algorithm: string | ConsensusAlgorithm;
                readonly type: string | ConsensusType;
            };
        };
    };
    readonly node: {
        readonly status: TevmNode['status'];
        readonly mode: TevmNode['mode'];
        readonly miningConfig: TevmNode['miningConfig'];
        readonly filters: Map<Hex, Filter>;
        readonly impersonatedAccount: Address$1 | undefined;
    };
    readonly pool: {
        readonly pool: TxPool['pool'];
        readonly txsByHash: TxPool['txsByHash'];
        readonly txsByNonce: TxPool['txsByNonce'];
        readonly txsInNonceOrder: TxPool['txsInNonceOrder'];
        readonly txsInPool: TxPool['txsInPool'];
    };
    readonly stateManager: {
        readonly storage: TevmState;
        readonly stateRoots: StateRoots;
    };
};
/**
 * Result from `debug_traceState`
 */
type DebugTraceStateResult<TStateFilters extends readonly DebugTraceStateFilter[] = readonly DebugTraceStateFilter[]> = TStateFilters['length'] extends 0 ? DebugTraceStateObject : UnionToIntersection<{
    [I in keyof TStateFilters]: GetPath<DebugTraceStateObject, TStateFilters[I] & string>;
}[keyof TStateFilters]>;

type DebugTraceCallHandler = <TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' = 'callTracer' | 'prestateTracer' | '4byteTracer', TDiffMode extends boolean = boolean>(params: DebugTraceCallParams<TTracer, TDiffMode>) => Promise<DebugTraceCallResult<TTracer, TDiffMode>>;

type DebugJsonRpcRequest = DebugTraceTransactionJsonRpcRequest | DebugTraceCallJsonRpcRequest | DebugTraceBlockJsonRpcRequest | DebugTraceStateJsonRpcRequest;
/**
 * JSON-RPC request for `debug_traceTransaction` method
 */
type DebugTraceTransactionJsonRpcRequest<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean, TTTThrowOnError extends boolean = boolean> = JsonRpcRequest<'debug_traceTransaction', [
    SerializeToJson<DebugTraceTransactionParams<TTracer, TDiffMode, TTTThrowOnError>>
]>;
/**
 * JSON-RPC request for `debug_traceCall` method
 */
type DebugTraceCallJsonRpcRequest<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean> = JsonRpcRequest<'debug_traceCall', [SerializeToJson<DebugTraceCallParams<TTracer, TDiffMode>>]>;
/**
 * JSON-RPC request for `debug_traceBlock`
 */
type DebugTraceBlockJsonRpcRequest<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined = 'callTracer' | 'prestateTracer' | '4byteTracer' | undefined, TDiffMode extends boolean = boolean> = JsonRpcRequest<'debug_traceBlock', [SerializeToJson<DebugTraceBlockParams<TTracer, TDiffMode>>]>;
/**
 * JSON-RPC request for `debug_traceState`
 */
type DebugTraceStateJsonRpcRequest<TStateFilters extends readonly DebugTraceStateFilter[] = readonly DebugTraceStateFilter[]> = JsonRpcRequest<'debug_traceState', [SerializeToJson<DebugTraceStateParams<TStateFilters>>]>;

type DebugError = string;
/**
 * JSON-RPC response for `debug_traceTransaction` procedure
 */
type DebugTraceTransactionJsonRpcResponse<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' = 'callTracer' | 'prestateTracer' | '4byteTracer', TDiffMode extends boolean = boolean> = JsonRpcResponse<'debug_traceTransaction', SerializeToJson<DebugTraceTransactionResult<TTracer, TDiffMode>>, DebugError>;
/**
 * JSON-RPC response for `debug_traceCall` procedure
 */
type DebugTraceCallJsonRpcResponse<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' = 'callTracer' | 'prestateTracer' | '4byteTracer', TDiffMode extends boolean = boolean> = JsonRpcResponse<'debug_traceCall', SerializeToJson<DebugTraceCallResult<TTracer, TDiffMode>>, DebugError>;
/**
 * JSON-RPC response for `debug_traceBlock`
 */
type DebugTraceBlockJsonRpcResponse<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' = 'callTracer' | 'prestateTracer' | '4byteTracer', TDiffMode extends boolean = boolean> = JsonRpcResponse<'debug_traceBlock', SerializeToJson<DebugTraceBlockResult<TTracer, TDiffMode>>, DebugError>;
/**
 * JSON-RPC response for `debug_traceState`
 */
type DebugTraceStateJsonRpcResponse<TStateFilters extends readonly DebugTraceStateFilter[] = readonly DebugTraceStateFilter[]> = JsonRpcResponse<'debug_traceState', SerializeToJson<DebugTraceStateResult<TStateFilters>>, DebugError>;

/**
 * JSON-RPC procedure for `debug_traceTransaction`
 */
type DebugTraceTransactionProcedure<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' = 'callTracer' | 'prestateTracer' | '4byteTracer', TDiffMode extends boolean = boolean> = (request: DebugTraceTransactionJsonRpcRequest<TTracer, TDiffMode>) => Promise<DebugTraceTransactionJsonRpcResponse<TTracer, TDiffMode>>;
/**
 * JSON-RPC procedure for `debug_traceCall`
 */
type DebugTraceCallProcedure<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' = 'callTracer' | 'prestateTracer' | '4byteTracer', TDiffMode extends boolean = boolean> = (request: DebugTraceCallJsonRpcRequest<TTracer, TDiffMode>) => Promise<DebugTraceCallJsonRpcResponse<TTracer, TDiffMode>>;
/**
 * JSON-RPC procedure for `debug_traceBlock`
 */
type DebugTraceBlockProcedure<TTracer extends 'callTracer' | 'prestateTracer' | '4byteTracer' = 'callTracer' | 'prestateTracer' | '4byteTracer', TDiffMode extends boolean = boolean> = (request: DebugTraceBlockJsonRpcRequest<TTracer, TDiffMode>) => Promise<DebugTraceBlockJsonRpcResponse<TTracer, TDiffMode>>;
/**
 * JSON-RPC procedure for `debug_traceState`
 */
type DebugTraceStateProcedure<TStateFilters extends readonly DebugTraceStateFilter[] = readonly DebugTraceStateFilter[]> = (request: DebugTraceStateJsonRpcRequest<TStateFilters>) => Promise<DebugTraceStateJsonRpcResponse<TStateFilters>>;

declare function debugTraceBlockJsonRpcProcedure(client: _tevm_node.TevmNode): DebugTraceBlockProcedure;

declare function debugTraceCallJsonRpcProcedure(client: _tevm_node.TevmNode): DebugTraceCallProcedure;

declare function debugTraceStateJsonRpcProcedure(client: _tevm_node.TevmNode): DebugTraceStateProcedure;

declare function debugTraceTransactionJsonRpcProcedure(client: _tevm_node.TevmNode): DebugTraceTransactionProcedure;

declare function traceCallHandler(client: _tevm_node.TevmNode): DebugTraceCallHandler;

/***
 * TODO I didn't update any of these jsdocs
 * TODO some of these types are not deserialized and/or don't match viem types and will
 * need to be updated as t hey are implemented
 */

type EthAccountsResult = Array<Address>;
/**
 * JSON-RPC response for `eth_blockNumber` procedure
 */
type EthBlockNumberResult = bigint;
/**
 * JSON-RPC response for `eth_call` procedure
 */
type EthCallResult = Hex;
/**
 * JSON-RPC response for `eth_chainId` procedure
 */
type EthChainIdResult = bigint;
/**
 * JSON-RPC response for `eth_coinbase` procedure
 */
type EthCoinbaseResult = Address;
/**
 * JSON-RPC response for `eth_estimateGas` procedure
 */
type EthEstimateGasResult = bigint;
/**
 * JSON-RPC response for `eth_hashrate` procedure
 */
type EthHashrateResult = Hex;
/**
 * JSON-RPC response for `eth_gasPrice` procedure
 */
type EthGasPriceResult = bigint;
/**
 * JSON-RPC response for `eth_getBalance` procedure
 */
type EthGetBalanceResult = bigint;
/**
 * JSON-RPC response for `eth_getBlockByHash` procedure
 */
type EthGetBlockByHashResult = BlockResult;
/**
 * JSON-RPC response for `eth_getBlockByNumber` procedure
 */
type EthGetBlockByNumberResult = BlockResult;
/**
 * JSON-RPC response for `eth_getBlockTransactionCountByHash` procedure
 */
type EthGetBlockTransactionCountByHashResult = Hex;
/**
 * JSON-RPC response for `eth_getBlockTransactionCountByNumber` procedure
 */
type EthGetBlockTransactionCountByNumberResult = Hex;
/**
 * JSON-RPC response for `eth_getCode` procedure
 */
type EthGetCodeResult = Hex;
/**
 * JSON-RPC response for `eth_getFilterChanges` procedure
 */
type EthGetFilterChangesResult = Array<FilterLog>;
/**
 * JSON-RPC response for `eth_getFilterLogs` procedure
 */
type EthGetFilterLogsResult = Array<FilterLog>;
/**
 * JSON-RPC response for `eth_getLogs` procedure
 */
type EthGetLogsResult = Array<FilterLog>;
/**
 * JSON-RPC response for `eth_getStorageAt` procedure
 */
type EthGetStorageAtResult = Hex;
/**
 * JSON-RPC response for `eth_getTransactionCount` procedure
 */
type EthGetTransactionCountResult = Hex;
/**
 * JSON-RPC response for `eth_getUncleCountByBlockHash` procedure
 */
type EthGetUncleCountByBlockHashResult = Hex;
/**
 * JSON-RPC response for `eth_getUncleCountByBlockNumber` procedure
 */
type EthGetUncleCountByBlockNumberResult = Hex;
/**
 * JSON-RPC response for `eth_getTransactionByHash` procedure
 */
type EthGetTransactionByHashResult = TransactionResult;
/**
 * JSON-RPC response for `eth_getTransactionByBlockHashAndIndex` procedure
 */
type EthGetTransactionByBlockHashAndIndexResult = TransactionResult;
/**
 * JSON-RPC response for `eth_getTransactionByBlockNumberAndIndex` procedure
 */
type EthGetTransactionByBlockNumberAndIndexResult = TransactionResult;
/**
 * JSON-RPC response for `eth_getTransactionReceipt` procedure
 */
type EthGetTransactionReceiptResult = TransactionReceiptResult | null;
/**
 * JSON-RPC response for `eth_getUncleByBlockHashAndIndex` procedure
 */
type EthGetUncleByBlockHashAndIndexResult = Hex;
/**
 * JSON-RPC response for `eth_getUncleByBlockNumberAndIndex` procedure
 */
type EthGetUncleByBlockNumberAndIndexResult = Hex;
/**
 * JSON-RPC response for `eth_mining` procedure
 */
type EthMiningResult = boolean;
/**
 * JSON-RPC response for `eth_protocolVersion` procedure
 */
type EthProtocolVersionResult = Hex;
/**
 * JSON-RPC response for `eth_sendRawTransaction` procedure
 */
type EthSendRawTransactionResult = Hex;
/**
 * JSON-RPC response for `eth_sendTransaction` procedure
 */
type EthSendTransactionResult = Hex;
/**
 * JSON-RPC response for `eth_sign` procedure
 */
type EthSignResult = Hex;
/**
 * JSON-RPC response for `eth_signTransaction` procedure
 */
type EthSignTransactionResult = Hex;
/**
 * JSON-RPC response for `eth_syncing` procedure
 */
type EthSyncingResult = boolean | {
    startingBlock: Hex;
    currentBlock: Hex;
    highestBlock: Hex;
    headedBytecodebytes?: Hex;
    healedBytecodes?: Hex;
    healedTrienodes?: Hex;
    healingBytecode?: Hex;
    healingTrienodes?: Hex;
    syncedBytecodeBytes?: Hex;
    syncedBytecodes?: Hex;
    syncedStorage?: Hex;
    syncedStorageBytes?: Hex;
    pulledStates: Hex;
    knownStates: Hex;
};
/**
 * JSON-RPC response for `eth_newFilter` procedure
 */
type EthNewFilterResult = Hex;
/**
 * JSON-RPC response for `eth_newBlockFilter` procedure
 */
type EthNewBlockFilterResult = Hex;
/**
 * JSON-RPC response for `eth_newPendingTransactionFilter` procedure
 */
type EthNewPendingTransactionFilterResult = Hex;
/**
 * JSON-RPC response for `eth_uninstallFilter` procedure
 */
type EthUninstallFilterResult = boolean;

type EthAccountsHandler = (request?: EthAccountsParams) => Promise<EthAccountsResult>;
type EthBlockNumberHandler = (request?: EthBlockNumberParams) => Promise<EthBlockNumberResult>;
type EthCallHandler = (request: EthCallParams) => Promise<EthCallResult>;
type EthChainIdHandler = (request?: EthChainIdParams) => Promise<EthChainIdResult>;
type EthCoinbaseHandler = (request: EthCoinbaseParams) => Promise<EthCoinbaseResult>;
type EthEstimateGasHandler = (request: EthEstimateGasParams) => Promise<EthEstimateGasResult>;
type EthHashrateHandler = (request?: EthHashrateParams) => Promise<EthHashrateResult>;
type EthGasPriceHandler = (request?: EthGasPriceParams) => Promise<EthGasPriceResult>;
type EthGetBalanceHandler = (request: EthGetBalanceParams) => Promise<EthGetBalanceResult>;
type EthGetBlockByHashHandler = (request: EthGetBlockByHashParams) => Promise<EthGetBlockByHashResult>;
type EthGetBlockByNumberHandler = (request: EthGetBlockByNumberParams) => Promise<EthGetBlockByNumberResult>;
type EthGetBlockTransactionCountByHashHandler = (request: EthGetBlockTransactionCountByHashParams) => Promise<EthGetBlockTransactionCountByHashResult>;
type EthGetBlockTransactionCountByNumberHandler = (request: EthGetBlockTransactionCountByNumberParams) => Promise<EthGetBlockTransactionCountByNumberResult>;
type EthGetCodeHandler = (request: EthGetCodeParams) => Promise<EthGetCodeResult>;
type EthGetFilterChangesHandler = (request: EthGetFilterChangesParams) => Promise<EthGetFilterChangesResult>;
type EthGetFilterLogsHandler = (request: EthGetFilterLogsParams) => Promise<EthGetFilterLogsResult>;
type EthGetLogsHandler = (request: EthGetLogsParams) => Promise<EthGetLogsResult>;
type EthGetStorageAtHandler = (request: EthGetStorageAtParams) => Promise<EthGetStorageAtResult>;
type EthGetTransactionCountHandler = (request: EthGetTransactionCountParams) => Promise<EthGetTransactionCountResult>;
type EthGetUncleCountByBlockHashHandler = (request: EthGetUncleCountByBlockHashParams) => Promise<EthGetUncleCountByBlockHashResult>;
type EthGetUncleCountByBlockNumberHandler = (request: EthGetUncleCountByBlockNumberParams) => Promise<EthGetUncleCountByBlockNumberResult>;
type EthGetTransactionByHashHandler = (request: EthGetTransactionByHashParams) => Promise<EthGetTransactionByHashResult>;
type EthGetTransactionByBlockHashAndIndexHandler = (request: EthGetTransactionByBlockHashAndIndexParams) => Promise<EthGetTransactionByBlockHashAndIndexResult>;
type EthGetTransactionByBlockNumberAndIndexHandler = (request: EthGetTransactionByBlockNumberAndIndexParams) => Promise<EthGetTransactionByBlockNumberAndIndexResult>;
type EthGetTransactionReceiptHandler = (request: EthGetTransactionReceiptParams) => Promise<EthGetTransactionReceiptResult>;
type EthGetUncleByBlockHashAndIndexHandler = (request: EthGetUncleByBlockHashAndIndexParams) => Promise<EthGetUncleByBlockHashAndIndexResult>;
type EthGetUncleByBlockNumberAndIndexHandler = (request: EthGetUncleByBlockNumberAndIndexParams) => Promise<EthGetUncleByBlockNumberAndIndexResult>;
type EthMiningHandler = (request: EthMiningParams) => Promise<EthMiningResult>;
type EthProtocolVersionHandler = (request: EthProtocolVersionParams) => Promise<EthProtocolVersionResult>;
type EthSendRawTransactionHandler = (request: EthSendRawTransactionParams) => Promise<EthSendRawTransactionResult>;
type EthSendTransactionHandler = (request: EthSendTransactionParams) => Promise<EthSendTransactionResult>;
type EthSignHandler = (request: EthSignParams) => Promise<EthSignResult>;
type EthSignTransactionHandler = (request: EthSignTransactionParams) => Promise<EthSignTransactionResult>;
type EthSyncingHandler = (request: EthSyncingParams) => Promise<EthSyncingResult>;
type EthNewFilterHandler = (request: EthNewFilterParams) => Promise<EthNewFilterResult>;
type EthNewBlockFilterHandler = (request: EthNewBlockFilterParams) => Promise<EthNewBlockFilterResult>;
type EthNewPendingTransactionFilterHandler = (request: EthNewPendingTransactionFilterParams) => Promise<EthNewPendingTransactionFilterResult>;
type EthUninstallFilterHandler = (request: EthUninstallFilterParams) => Promise<EthUninstallFilterResult>;

declare function blockNumberHandler(client: _tevm_node.TevmNode): EthBlockNumberHandler;

/**
 * the transaction call object for methods like `eth_call`
 */
type JsonRpcTransaction = {
    /**
     * The address from which the transaction is sent
     */
    from?: Address$1;
    /**
     * The address to which the transaction is addressed
     */
    to?: Address$1;
    /**
     * The integer of gas provided for the transaction execution
     */
    gas?: Hex$1;
    /**
     * The integer of gasPrice used for each paid gas encoded as hexadecimal
     */
    gasPrice?: Hex$1;
    /**
     * The integer of value sent with this transaction encoded as hexadecimal
     */
    value?: Hex$1;
    /**
     * The hash of the method signature and encoded parameters. For more information, see the Contract ABI description in the Solidity documentation
     */
    data?: Hex$1;
    /**
     * The integer of the nonce. If not provided a nonce will automatically be generated
     */
    nonce?: Hex$1;
};
/**
 * JSON-RPC request for `eth_accounts` procedure
 */
type EthAccountsJsonRpcRequest = JsonRpcRequest<'eth_accounts', readonly []>;
/**
 * JSON-RPC request for `eth_blobBaseFee` procedure
 */
type EthBlobBaseFeeJsonRpcRequest = JsonRpcRequest<'eth_blobBaseFee', readonly []>;
/**
 * JSON-RPC request for `eth_blockNumber` procedure
 */
type EthBlockNumberJsonRpcRequest = JsonRpcRequest<'eth_blockNumber', readonly []>;
/**
 * JSON-RPC request for `eth_call` procedure
 */
type EthCallJsonRpcRequest = JsonRpcRequest<'eth_call', readonly [
    tx: JsonRpcTransaction,
    tag: BlockTag$1 | Hex$1,
    stateOverrideSet?: SerializeToJson<BaseCallParams['stateOverrideSet']>,
    blockOverrideSet?: SerializeToJson<BaseCallParams['blockOverrideSet']>
]>;
/**
 * JSON-RPC request for `eth_chainId` procedure
 */
type EthChainIdJsonRpcRequest = JsonRpcRequest<'eth_chainId', readonly []>;
/**
 * JSON-RPC request for `eth_coinbase` procedure
 */
type EthCoinbaseJsonRpcRequest = JsonRpcRequest<'eth_coinbase', readonly []>;
/**
 * JSON-RPC request for `eth_estimateGas` procedure
 */
type EthEstimateGasJsonRpcRequest = JsonRpcRequest<'eth_estimateGas', readonly [
    tx: JsonRpcTransaction,
    tag?: BlockTag$1 | Hex$1,
    stateOverrideSet?: SerializeToJson<BaseCallParams['stateOverrideSet']>,
    blockOverrideSet?: SerializeToJson<BaseCallParams['blockOverrideSet']>
]>;
/**
 * JSON-RPC request for `eth_hashrate` procedure
 */
type EthHashrateJsonRpcRequest = JsonRpcRequest<'eth_hashrate', readonly []>;
/**
 * JSON-RPC request for `eth_gasPrice` procedure
 */
type EthGasPriceJsonRpcRequest = JsonRpcRequest<'eth_gasPrice', readonly []>;
/**
 * JSON-RPC request for `eth_getBalance` procedure
 */
type EthGetBalanceJsonRpcRequest = JsonRpcRequest<'eth_getBalance', [address: Address$1, tag: BlockTag$1 | Hex$1]>;
/**
 * JSON-RPC request for `eth_getBlockByHash` procedure
 */
type EthGetBlockByHashJsonRpcRequest = JsonRpcRequest<'eth_getBlockByHash', readonly [blockHash: Hex$1, fullTransactionObjects: boolean]>;
/**
 * JSON-RPC request for `eth_getBlockByNumber` procedure
 */
type EthGetBlockByNumberJsonRpcRequest = JsonRpcRequest<'eth_getBlockByNumber', readonly [tag: BlockTag$1 | Hex$1, fullTransactionObjects: boolean]>;
/**
 * JSON-RPC request for `eth_getBlockTransactionCountByHash` procedure
 */
type EthGetBlockTransactionCountByHashJsonRpcRequest = JsonRpcRequest<'eth_getBlockTransactionCountByHash', readonly [hash: Hex$1]>;
/**
 * JSON-RPC request for `eth_getBlockTransactionCountByNumber` procedure
 */
type EthGetBlockTransactionCountByNumberJsonRpcRequest = JsonRpcRequest<'eth_getBlockTransactionCountByNumber', readonly [tag: BlockTag$1 | Hex$1]>;
/**
 * JSON-RPC request for `eth_getCode` procedure
 */
type EthGetCodeJsonRpcRequest = JsonRpcRequest<'eth_getCode', readonly [address: Address$1, tag: BlockTag$1 | Hex$1]>;
/**
 * JSON-RPC request for `eth_getFilterChanges` procedure
 */
type EthGetFilterChangesJsonRpcRequest = JsonRpcRequest<'eth_getFilterChanges', [filterId: Hex$1]>;
/**
 * JSON-RPC request for `eth_getFilterLogs` procedure
 */
type EthGetFilterLogsJsonRpcRequest = JsonRpcRequest<'eth_getFilterLogs', [filterId: Hex$1]>;
/**
 * JSON-RPC request for `eth_getLogs` procedure
 */
type EthGetLogsJsonRpcRequest = JsonRpcRequest<'eth_getLogs', [filterParams: FilterParams]>;
/**
 * JSON-RPC request for `eth_getStorageAt` procedure
 */
type EthGetStorageAtJsonRpcRequest = JsonRpcRequest<'eth_getStorageAt', readonly [address: Address$1, position: Hex$1, tag: BlockTag$1 | Hex$1]>;
/**
 * JSON-RPC request for `eth_getTransactionCount` procedure
 */
type EthGetTransactionCountJsonRpcRequest = JsonRpcRequest<'eth_getTransactionCount', readonly [address: Address$1, tag: BlockTag$1 | Hex$1]>;
/**
 * JSON-RPC request for `eth_getUncleCountByBlockHash` procedure
 */
type EthGetUncleCountByBlockHashJsonRpcRequest = JsonRpcRequest<'eth_getUncleCountByBlockHash', readonly [hash: Hex$1]>;
/**
 * JSON-RPC request for `eth_getUncleCountByBlockNumber` procedure
 */
type EthGetUncleCountByBlockNumberJsonRpcRequest = JsonRpcRequest<'eth_getUncleCountByBlockNumber', readonly [tag: BlockTag$1 | Hex$1]>;
/**
 * JSON-RPC request for `eth_getTransactionByHash` procedure
 */
type EthGetTransactionByHashJsonRpcRequest = JsonRpcRequest<'eth_getTransactionByHash', readonly [data: Hex$1]>;
/**
 * JSON-RPC request for `eth_getTransactionByBlockHashAndIndex` procedure
 */
type EthGetTransactionByBlockHashAndIndexJsonRpcRequest = JsonRpcRequest<'eth_getTransactionByBlockHashAndIndex', readonly [tag: Hex$1, index: Hex$1]>;
/**
 * JSON-RPC request for `eth_getTransactionByBlockNumberAndIndex` procedure
 */
type EthGetTransactionByBlockNumberAndIndexJsonRpcRequest = JsonRpcRequest<'eth_getTransactionByBlockNumberAndIndex', readonly [tag: BlockTag$1 | Hex$1, index: Hex$1]>;
/**
 * JSON-RPC request for `eth_getTransactionReceipt` procedure
 */
type EthGetTransactionReceiptJsonRpcRequest = JsonRpcRequest<'eth_getTransactionReceipt', readonly [txHash: Hex$1]>;
/**
 * JSON-RPC request for `eth_getUncleByBlockHashAndIndex` procedure
 */
type EthGetUncleByBlockHashAndIndexJsonRpcRequest = JsonRpcRequest<'eth_getUncleByBlockHashAndIndex', readonly [blockHash: Hex$1, uncleIndex: Hex$1]>;
/**
 * JSON-RPC request for `eth_getUncleByBlockNumberAndIndex` procedure
 */
type EthGetUncleByBlockNumberAndIndexJsonRpcRequest = JsonRpcRequest<'eth_getUncleByBlockNumberAndIndex', readonly [tag: BlockTag$1 | Hex$1, uncleIndex: Hex$1]>;
/**
 * JSON-RPC request for `eth_mining` procedure
 */
type EthMiningJsonRpcRequest = JsonRpcRequest<'eth_mining', readonly []>;
/**
 * JSON-RPC request for `eth_protocolVersion` procedure
 */
type EthProtocolVersionJsonRpcRequest = JsonRpcRequest<'eth_protocolVersion', readonly []>;
/**
 * JSON-RPC request for `eth_sendRawTransaction` procedure
 */
type EthSendRawTransactionJsonRpcRequest = JsonRpcRequest<'eth_sendRawTransaction', [data: Hex$1]>;
/**
 * JSON-RPC request for `eth_sendTransaction` procedure
 */
type EthSendTransactionJsonRpcRequest = JsonRpcRequest<'eth_sendTransaction', readonly [tx: JsonRpcTransaction]>;
/**
 * JSON-RPC request for `eth_sign` procedure
 */
type EthSignJsonRpcRequest = JsonRpcRequest<'eth_sign', readonly [address: Address$1, message: Hex$1]>;
/**
 * JSON-RPC request for `eth_signTransaction` procedure
 */
type EthSignTransactionJsonRpcRequest = JsonRpcRequest<'eth_signTransaction', readonly [
    {
        from: Address$1;
        to?: Address$1;
        gas?: Hex$1;
        gasPrice?: Hex$1;
        value?: Hex$1;
        data?: Hex$1;
        nonce?: Hex$1;
        chainId?: Hex$1;
    }
]>;
/**
 * JSON-RPC request for `eth_syncing` procedure
 */
type EthSyncingJsonRpcRequest = JsonRpcRequest<'eth_syncing', readonly []>;
/**
 * JSON-RPC request for `eth_newFilter` procedure
 */
type EthNewFilterJsonRpcRequest = JsonRpcRequest<'eth_newFilter', readonly [SerializeToJson<FilterParams>]>;
/**
 * JSON-RPC request for `eth_newBlockFilter` procedure
 */
type EthNewBlockFilterJsonRpcRequest = JsonRpcRequest<'eth_newBlockFilter', readonly []>;
/**
 * JSON-RPC request for `eth_newPendingTransactionFilter` procedure
 */
type EthNewPendingTransactionFilterJsonRpcRequest = JsonRpcRequest<'eth_newPendingTransactionFilter', readonly []>;
/**
 * JSON-RPC request for `eth_uninstallFilter` procedure
 */
type EthUninstallFilterJsonRpcRequest = JsonRpcRequest<'eth_uninstallFilter', readonly [filterId: Hex$1]>;
/**
 * JSON-RPC request for `eth_createAccessList` procedure
 */
type EthCreateAccessListJsonRpcRequest = JsonRpcRequest<'eth_createAccessList', readonly [tx: JsonRpcTransaction, tag?: BlockTag$1 | Hex$1]>;
type EthJsonRpcRequest = EthAccountsJsonRpcRequest | EthAccountsJsonRpcRequest | EthBlobBaseFeeJsonRpcRequest | EthBlockNumberJsonRpcRequest | EthCallJsonRpcRequest | EthChainIdJsonRpcRequest | EthCoinbaseJsonRpcRequest | EthEstimateGasJsonRpcRequest | EthHashrateJsonRpcRequest | EthGasPriceJsonRpcRequest | EthGetBalanceJsonRpcRequest | EthGetBlockByHashJsonRpcRequest | EthGetBlockByNumberJsonRpcRequest | EthGetBlockTransactionCountByHashJsonRpcRequest | EthGetBlockTransactionCountByNumberJsonRpcRequest | EthGetCodeJsonRpcRequest | EthGetFilterChangesJsonRpcRequest | EthGetFilterLogsJsonRpcRequest | EthGetLogsJsonRpcRequest | EthGetStorageAtJsonRpcRequest | EthGetTransactionCountJsonRpcRequest | EthGetUncleCountByBlockHashJsonRpcRequest | EthGetUncleCountByBlockNumberJsonRpcRequest | EthGetTransactionByHashJsonRpcRequest | EthGetTransactionByBlockHashAndIndexJsonRpcRequest | EthGetTransactionByBlockNumberAndIndexJsonRpcRequest | EthGetTransactionReceiptJsonRpcRequest | EthGetUncleByBlockHashAndIndexJsonRpcRequest | EthGetUncleByBlockNumberAndIndexJsonRpcRequest | EthMiningJsonRpcRequest | EthProtocolVersionJsonRpcRequest | EthSendRawTransactionJsonRpcRequest | EthSendTransactionJsonRpcRequest | EthSignJsonRpcRequest | EthSignTransactionJsonRpcRequest | EthSyncingJsonRpcRequest | EthNewFilterJsonRpcRequest | EthNewBlockFilterJsonRpcRequest | EthNewPendingTransactionFilterJsonRpcRequest | EthUninstallFilterJsonRpcRequest | EthCreateAccessListJsonRpcRequest;

/**
 * JSON-RPC response for `eth_accounts` procedure
 */
type EthAccountsJsonRpcResponse = JsonRpcResponse<'eth_accounts', Address$1[], string | number>;
/**
 * JSON-RPC response for `eth_blobBaseFee` procedure
 */
type EthBlobBaseFeeJsonRpcResponse = JsonRpcResponse<'eth_blobBaseFee', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_blockNumber` procedure
 */
type EthBlockNumberJsonRpcResponse = JsonRpcResponse<'eth_blockNumber', SerializeToJson<EthBlockNumberResult>, string | number>;
/**
 * JSON-RPC response for `eth_call` procedure
 */
type EthCallJsonRpcResponse = JsonRpcResponse<'eth_call', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_chainId` procedure
 */
type EthChainIdJsonRpcResponse = JsonRpcResponse<'eth_chainId', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_coinbase` procedure
 */
type EthCoinbaseJsonRpcResponse = JsonRpcResponse<'eth_coinbase', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_estimateGas` procedure
 */
type EthEstimateGasJsonRpcResponse = JsonRpcResponse<'eth_estimateGas', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_hashrate` procedure
 */
type EthHashrateJsonRpcResponse = JsonRpcResponse<'eth_hashrate', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_gasPrice` procedure
 */
type EthGasPriceJsonRpcResponse = JsonRpcResponse<'eth_gasPrice', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getBalance` procedure
 */
type EthGetBalanceJsonRpcResponse = JsonRpcResponse<'eth_getBalance', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getBlockByHash` procedure
 */
type EthGetBlockByHashJsonRpcResponse = JsonRpcResponse<'eth_getBlockByHash', BlockResult, string | number>;
/**
 * JSON-RPC response for `eth_getBlockByNumber` procedure
 */
type EthGetBlockByNumberJsonRpcResponse = JsonRpcResponse<'eth_getBlockByNumber', BlockResult, string | number>;
/**
 * JSON-RPC response for `eth_getBlockTransactionCountByHash` procedure
 */
type EthGetBlockTransactionCountByHashJsonRpcResponse = JsonRpcResponse<'eth_getBlockTransactionCountByHash', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getBlockTransactionCountByNumber` procedure
 */
type EthGetBlockTransactionCountByNumberJsonRpcResponse = JsonRpcResponse<'eth_getBlockTransactionCountByNumber', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getCode` procedure
 */
type EthGetCodeJsonRpcResponse = JsonRpcResponse<'eth_getCode', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getFilterChanges` procedure
 */
type EthGetFilterChangesJsonRpcResponse = JsonRpcResponse<'eth_getFilterChanges', Array<SerializeToJson<FilterLog>>, string | number>;
/**
 * JSON-RPC response for `eth_getFilterLogs` procedure
 */
type EthGetFilterLogsJsonRpcResponse = JsonRpcResponse<'eth_getFilterLogs', Array<SerializeToJson<FilterLog>>, string | number>;
/**
 * JSON-RPC response for `eth_getLogs` procedure
 */
type EthGetLogsJsonRpcResponse = JsonRpcResponse<'eth_getLogs', Array<SerializeToJson<SerializeToJson<FilterLog>>>, string | number>;
/**
 * JSON-RPC response for `eth_getStorageAt` procedure
 */
type EthGetStorageAtJsonRpcResponse = JsonRpcResponse<'eth_getStorageAt', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getTransactionCount` procedure
 */
type EthGetTransactionCountJsonRpcResponse = JsonRpcResponse<'eth_getTransactionCount', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getUncleCountByBlockHash` procedure
 */
type EthGetUncleCountByBlockHashJsonRpcResponse = JsonRpcResponse<'eth_getUncleCountByBlockHash', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getUncleCountByBlockNumber` procedure
 */
type EthGetUncleCountByBlockNumberJsonRpcResponse = JsonRpcResponse<'eth_getUncleCountByBlockNumber', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getTransactionByHash` procedure
 */
type EthGetTransactionByHashJsonRpcResponse = JsonRpcResponse<'eth_getTransactionByHash', TransactionResult, string | number>;
/**
 * JSON-RPC response for `eth_getTransactionByBlockHashAndIndex` procedure
 */
type EthGetTransactionByBlockHashAndIndexJsonRpcResponse = JsonRpcResponse<'eth_getTransactionByBlockHashAndIndex', TransactionResult, string | number>;
/**
 * JSON-RPC response for `eth_getTransactionByBlockNumberAndIndex` procedure
 */
type EthGetTransactionByBlockNumberAndIndexJsonRpcResponse = JsonRpcResponse<'eth_getTransactionByBlockNumberAndIndex', TransactionResult, string | number>;
/**
 * JSON-RPC response for `eth_getTransactionReceipt` procedure
 */
type EthGetTransactionReceiptJsonRpcResponse = JsonRpcResponse<'eth_getTransactionReceipt', SerializeToJson<TransactionReceiptResult> | null, string | number>;
/**
 * JSON-RPC response for `eth_getUncleByBlockHashAndIndex` procedure
 */
type EthGetUncleByBlockHashAndIndexJsonRpcResponse = JsonRpcResponse<'eth_getUncleByBlockHashAndIndex', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_getUncleByBlockNumberAndIndex` procedure
 */
type EthGetUncleByBlockNumberAndIndexJsonRpcResponse = JsonRpcResponse<'eth_getUncleByBlockNumberAndIndex', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_mining` procedure
 */
type EthMiningJsonRpcResponse = JsonRpcResponse<'eth_mining', boolean, string | number>;
/**
 * JSON-RPC response for `eth_protocolVersion` procedure
 */
type EthProtocolVersionJsonRpcResponse = JsonRpcResponse<'eth_protocolVersion', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_sendRawTransaction` procedure
 */
type EthSendRawTransactionJsonRpcResponse = JsonRpcResponse<'eth_sendRawTransaction', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_sendTransaction` procedure
 */
type EthSendTransactionJsonRpcResponse = JsonRpcResponse<'eth_sendTransaction', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_sign` procedure
 */
type EthSignJsonRpcResponse = JsonRpcResponse<'eth_sign', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_signTransaction` procedure
 */
type EthSignTransactionJsonRpcResponse = JsonRpcResponse<'eth_signTransaction', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_syncing` procedure
 */
type EthSyncingJsonRpcResponse = JsonRpcResponse<'eth_syncing', boolean | {
    startingBlock: Hex$1;
    currentBlock: Hex$1;
    highestBlock: Hex$1;
    headedBytecodebytes?: Hex$1;
    healedBytecodes?: Hex$1;
    healedTrienodes?: Hex$1;
    healingBytecode?: Hex$1;
    healingTrienodes?: Hex$1;
    syncedBytecodeBytes?: Hex$1;
    syncedBytecodes?: Hex$1;
    syncedStorage?: Hex$1;
    syncedStorageBytes?: Hex$1;
    pulledStates: Hex$1;
    knownStates: Hex$1;
}, string | number>;
/**
 * JSON-RPC response for `eth_newFilter` procedure
 */
type EthNewFilterJsonRpcResponse = JsonRpcResponse<'eth_newFilter', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_newBlockFilter` procedure
 */
type EthNewBlockFilterJsonRpcResponse = JsonRpcResponse<'eth_newBlockFilter', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_newPendingTransactionFilter` procedure
 */
type EthNewPendingTransactionFilterJsonRpcResponse = JsonRpcResponse<'eth_newPendingTransactionFilter', Hex$1, string | number>;
/**
 * JSON-RPC response for `eth_uninstallFilter` procedure
 */
type EthUninstallFilterJsonRpcResponse = JsonRpcResponse<'eth_uninstallFilter', boolean, string | number>;
/**
 * JSON-RPC response for `eth_createAccessList` procedure
 */
type EthCreateAccessListJsonRpcResponse = JsonRpcResponse<'eth_createAccessList', {
    accessList: Array<{
        address: Address$1;
        storageKeys: Hex$1[];
    }>;
    gasUsed: Hex$1;
}, string | number>;

type EthAccountsJsonRpcProcedure = (request: EthAccountsJsonRpcRequest) => Promise<EthAccountsJsonRpcResponse>;
type EthBlobBaseFeeJsonRpcProcedure = (request: EthBlobBaseFeeJsonRpcRequest) => Promise<EthBlobBaseFeeJsonRpcResponse>;
type EthBlockNumberJsonRpcProcedure = (request: EthBlockNumberJsonRpcRequest) => Promise<EthBlockNumberJsonRpcResponse>;
type EthCallJsonRpcProcedure = (request: EthCallJsonRpcRequest) => Promise<EthCallJsonRpcResponse>;
type EthChainIdJsonRpcProcedure = (request: EthChainIdJsonRpcRequest) => Promise<EthChainIdJsonRpcResponse>;
type EthCoinbaseJsonRpcProcedure = (request: EthCoinbaseJsonRpcRequest) => Promise<EthCoinbaseJsonRpcResponse>;
type EthEstimateGasJsonRpcProcedure = (request: EthEstimateGasJsonRpcRequest) => Promise<EthEstimateGasJsonRpcResponse>;
type EthHashrateJsonRpcProcedure = (request: EthHashrateJsonRpcRequest) => Promise<EthHashrateJsonRpcResponse>;
type EthGasPriceJsonRpcProcedure = (request: EthGasPriceJsonRpcRequest) => Promise<EthGasPriceJsonRpcResponse>;
type EthGetBalanceJsonRpcProcedure = (request: EthGetBalanceJsonRpcRequest) => Promise<EthGetBalanceJsonRpcResponse>;
type EthGetBlockByHashJsonRpcProcedure = (request: EthGetBlockByHashJsonRpcRequest) => Promise<EthGetBlockByHashJsonRpcResponse>;
type EthGetBlockByNumberJsonRpcProcedure = (request: EthGetBlockByNumberJsonRpcRequest) => Promise<EthGetBlockByNumberJsonRpcResponse>;
type EthGetBlockTransactionCountByHashJsonRpcProcedure = (request: EthGetBlockTransactionCountByHashJsonRpcRequest) => Promise<EthGetBlockTransactionCountByHashJsonRpcResponse>;
type EthGetBlockTransactionCountByNumberJsonRpcProcedure = (request: EthGetBlockTransactionCountByNumberJsonRpcRequest) => Promise<EthGetBlockTransactionCountByNumberJsonRpcResponse>;
type EthGetCodeJsonRpcProcedure = (request: EthGetCodeJsonRpcRequest) => Promise<EthGetCodeJsonRpcResponse>;
type EthGetFilterChangesJsonRpcProcedure = (request: EthGetFilterChangesJsonRpcRequest) => Promise<EthGetFilterChangesJsonRpcResponse>;
type EthGetFilterLogsJsonRpcProcedure = (request: EthGetFilterLogsJsonRpcRequest) => Promise<EthGetFilterLogsJsonRpcResponse>;
type EthGetLogsJsonRpcProcedure = (request: EthGetLogsJsonRpcRequest) => Promise<EthGetLogsJsonRpcResponse>;
type EthGetStorageAtJsonRpcProcedure = (request: EthGetStorageAtJsonRpcRequest) => Promise<EthGetStorageAtJsonRpcResponse>;
type EthGetTransactionCountJsonRpcProcedure = (request: EthGetTransactionCountJsonRpcRequest) => Promise<EthGetTransactionCountJsonRpcResponse>;
type EthGetUncleCountByBlockHashJsonRpcProcedure = (request: EthGetUncleCountByBlockHashJsonRpcRequest) => Promise<EthGetUncleCountByBlockHashJsonRpcResponse>;
type EthGetUncleCountByBlockNumberJsonRpcProcedure = (request: EthGetUncleCountByBlockNumberJsonRpcRequest) => Promise<EthGetUncleCountByBlockNumberJsonRpcResponse>;
type EthGetTransactionByHashJsonRpcProcedure = (request: EthGetTransactionByHashJsonRpcRequest) => Promise<EthGetTransactionByHashJsonRpcResponse>;
type EthGetTransactionByBlockHashAndIndexJsonRpcProcedure = (request: EthGetTransactionByBlockHashAndIndexJsonRpcRequest) => Promise<EthGetTransactionByBlockHashAndIndexJsonRpcResponse>;
type EthGetTransactionByBlockNumberAndIndexJsonRpcProcedure = (request: EthGetTransactionByBlockNumberAndIndexJsonRpcRequest) => Promise<EthGetTransactionByBlockNumberAndIndexJsonRpcResponse>;
type EthGetTransactionReceiptJsonRpcProcedure = (request: EthGetTransactionReceiptJsonRpcRequest) => Promise<EthGetTransactionReceiptJsonRpcResponse>;
type EthGetUncleByBlockHashAndIndexJsonRpcProcedure = (request: EthGetUncleByBlockHashAndIndexJsonRpcRequest) => Promise<EthGetUncleByBlockHashAndIndexJsonRpcResponse>;
type EthGetUncleByBlockNumberAndIndexJsonRpcProcedure = (request: EthGetUncleByBlockNumberAndIndexJsonRpcRequest) => Promise<EthGetUncleByBlockNumberAndIndexJsonRpcResponse>;
type EthMiningJsonRpcProcedure = (request: EthMiningJsonRpcRequest) => Promise<EthMiningJsonRpcResponse>;
type EthProtocolVersionJsonRpcProcedure = (request: EthProtocolVersionJsonRpcRequest) => Promise<EthProtocolVersionJsonRpcResponse>;
type EthSendRawTransactionJsonRpcProcedure = (request: EthSendRawTransactionJsonRpcRequest) => Promise<EthSendRawTransactionJsonRpcResponse>;
type EthSendTransactionJsonRpcProcedure = (request: EthSendTransactionJsonRpcRequest) => Promise<EthSendTransactionJsonRpcResponse>;
type EthSignJsonRpcProcedure = (request: EthSignJsonRpcRequest) => Promise<EthSignJsonRpcResponse>;
type EthSignTransactionJsonRpcProcedure = (request: EthSignTransactionJsonRpcRequest) => Promise<EthSignTransactionJsonRpcResponse>;
type EthSyncingJsonRpcProcedure = (request: EthSyncingJsonRpcRequest) => Promise<EthSyncingJsonRpcResponse>;
type EthNewFilterJsonRpcProcedure = (request: EthNewFilterJsonRpcRequest) => Promise<EthNewFilterJsonRpcResponse>;
type EthNewBlockFilterJsonRpcProcedure = (request: EthNewBlockFilterJsonRpcRequest) => Promise<EthNewBlockFilterJsonRpcResponse>;
type EthNewPendingTransactionFilterJsonRpcProcedure = (request: EthNewPendingTransactionFilterJsonRpcRequest) => Promise<EthNewPendingTransactionFilterJsonRpcResponse>;
type EthUninstallFilterJsonRpcProcedure = (request: EthUninstallFilterJsonRpcRequest) => Promise<EthUninstallFilterJsonRpcResponse>;
type EthCreateAccessListJsonRpcProcedure = (request: EthCreateAccessListJsonRpcRequest) => Promise<EthCreateAccessListJsonRpcResponse>;

declare function blockNumberProcedure(client: _tevm_node.TevmNode): EthBlockNumberJsonRpcProcedure;

declare function chainIdHandler(client: _tevm_node.TevmNode): EthChainIdHandler;

declare function chainIdProcedure(baseClient: _tevm_node.TevmNode): EthChainIdJsonRpcProcedure;

declare function ethAccountsHandler({ accounts }: {
    accounts: ReadonlyArray<_tevm_utils.Account>;
}): EthAccountsHandler;

declare function ethAccountsProcedure(accounts: ReadonlyArray<_tevm_utils.Account>): EthAccountsJsonRpcProcedure;

declare function ethBlobBaseFeeJsonRpcProcedure(client: _tevm_node.TevmNode): EthBlobBaseFeeJsonRpcProcedure;

declare function ethCallHandler(client: _tevm_node.TevmNode): EthCallHandler;

declare function ethCallProcedure(client: _tevm_node.TevmNode): EthCallJsonRpcProcedure;

declare function ethCoinbaseJsonRpcProcedure(client: _tevm_node.TevmNode): EthCoinbaseJsonRpcProcedure;

declare function ethCreateAccessListProcedure(client: _tevm_node.TevmNode): EthCreateAccessListJsonRpcProcedure;

declare function ethEstimateGasJsonRpcProcedure(client: _tevm_node.TevmNode): EthEstimateGasJsonRpcProcedure;

declare function ethGetBlockByHashJsonRpcProcedure(client: _tevm_node.TevmNode): EthGetBlockByHashJsonRpcProcedure;

declare function ethGetBlockByNumberJsonRpcProcedure(client: _tevm_node.TevmNode): EthGetBlockByNumberJsonRpcProcedure;

declare function ethGetBlockTransactionCountByHashJsonRpcProcedure(client: _tevm_node.TevmNode): EthGetBlockTransactionCountByHashJsonRpcProcedure;

declare function ethGetBlockTransactionCountByNumberJsonRpcProcedure(client: _tevm_node.TevmNode): EthGetBlockTransactionCountByNumberJsonRpcProcedure;

declare function ethGetFilterChangesProcedure(client: _tevm_node.TevmNode): EthGetFilterChangesJsonRpcProcedure;

declare function ethGetFilterLogsProcedure(client: _tevm_node.TevmNode): EthGetFilterLogsJsonRpcProcedure;

declare function ethGetLogsHandler(client: _tevm_node.TevmNode): EthGetLogsHandler;

declare function ethGetLogsProcedure(client: _tevm_node.TevmNode): EthGetLogsJsonRpcProcedure;

declare function ethGetTransactionByBlockHashAndIndexJsonRpcProcedure(client: _tevm_node.TevmNode): EthGetTransactionByBlockHashAndIndexJsonRpcProcedure;

declare function ethGetTransactionByBlockNumberAndIndexJsonRpcProcedure(client: _tevm_node.TevmNode): EthGetTransactionByBlockNumberAndIndexJsonRpcProcedure;

declare function ethGetTransactionByHashJsonRpcProcedure(client: _tevm_node.TevmNode): EthGetTransactionByHashJsonRpcProcedure;

declare function ethGetTransactionCountProcedure(node: _tevm_node.TevmNode): EthGetTransactionCountJsonRpcProcedure;

declare function ethGetTransactionReceiptHandler(client: _tevm_node.TevmNode): EthGetTransactionReceiptHandler;

declare function ethGetTransactionReceiptJsonRpcProcedure(client: _tevm_node.TevmNode): EthGetTransactionReceiptJsonRpcProcedure;

declare function ethNewBlockFilterProcedure(client: _tevm_node.TevmNode): EthNewBlockFilterJsonRpcProcedure;

declare function ethNewFilterHandler(tevmNode: _tevm_node.TevmNode): EthNewFilterHandler;
type EthNewFilterError = UnknownBlockError | InvalidBlockError;

declare function ethNewFilterJsonRpcProcedure(tevmNode: _tevm_node.TevmNode): EthNewFilterJsonRpcProcedure;

declare function ethNewPendingTransactionFilterProcedure(client: _tevm_node.TevmNode): EthNewPendingTransactionFilterJsonRpcProcedure;

declare function ethProtocolVersionJsonRpcProcedure(): EthProtocolVersionJsonRpcProcedure;

declare function ethSendRawTransactionHandler(client: _tevm_node.TevmNode): EthSendRawTransactionHandler;

declare function ethSendRawTransactionJsonRpcProcedure(client: _tevm_node.TevmNode): EthSendRawTransactionJsonRpcProcedure;

declare function ethSendTransactionHandler(client: _tevm_node.TevmNode): EthSendTransactionHandler;

declare function ethSendTransactionJsonRpcProcedure(client: _tevm_node.TevmNode): EthSendTransactionJsonRpcProcedure;

declare class MissingAccountError extends Error {
    /**
     * @type {'MissingAccountError'}
     */
    _tag: "MissingAccountError";
    /**
     * @type {'MissingAccountError'}
     * @override
     */
    override name: "MissingAccountError";
}
declare function ethSignHandler({ accounts }: {
    accounts: ReadonlyArray<_tevm_utils.HDAccount>;
}): EthSignHandler;

declare function ethSignProcedure(accounts: ReadonlyArray<_tevm_utils.HDAccount>): EthSignJsonRpcProcedure;

declare function ethSignTransactionHandler({ getChainId, accounts }: {
    accounts: ReadonlyArray<_tevm_utils.HDAccount>;
    getChainId: () => Promise<number>;
}): EthSignTransactionHandler;

declare function ethSignTransactionProcedure(options: Parameters<typeof ethSignTransactionHandler>[0]): EthSignTransactionJsonRpcProcedure;

declare function ethUninstallFilterJsonRpcProcedure(client: _tevm_node.TevmNode): EthUninstallFilterJsonRpcProcedure;

declare function gasPriceHandler({ forkTransport, getVm, ...client }: _tevm_node.TevmNode): EthGasPriceHandler;

declare function gasPriceProcedure({ getVm, forkTransport }: Parameters<typeof gasPriceHandler>[0]): EthGasPriceJsonRpcProcedure;

declare function getBalanceHandler(baseClient: _tevm_node.TevmNode): EthGetBalanceHandler;

declare function getBalanceProcedure(baseClient: Parameters<typeof getBalanceHandler>[0]): EthGetBalanceJsonRpcProcedure;

declare function getCodeHandler(baseClient: _tevm_node.TevmNode): EthGetCodeHandler;

declare function getCodeProcedure(baseClient: Parameters<typeof getCodeHandler>[0]): EthGetCodeJsonRpcProcedure;

declare function getStorageAtHandler(client: _tevm_node.TevmNode): EthGetStorageAtHandler;

declare function getStorageAtProcedure(client: _tevm_node.TevmNode): EthGetStorageAtJsonRpcProcedure;

/**
 * Tevm params to get an account
 * @example
 * const getAccountParams: import('@tevm/api').GetAccountParams = {
 *   address: '0x...',
 * }
 */
type GetAccountParams<TThrowOnFail extends boolean = boolean> = BaseParams<TThrowOnFail> & {
    /**
     * Address of account
     */
    readonly address: Address;
    /**
     * If true the handler will return the contract storage
     * It only returns storage that happens to be cached in the vm
     * In fork mode if storage hasn't yet been cached it will not be returned
     * This defaults to false
     * Be aware that this can be very expensive if a contract has a lot of storage
     */
    readonly returnStorage?: boolean;
    /**
     * Block tag to fetch account from
     * - bigint for block number
     * - hex string for block hash
     * - 'latest', 'earliest', 'pending', 'forked' etc. tags
     */
    readonly blockTag?: BlockParam;
};

declare function validateGetAccountParams(action: GetAccountParams): Array<ValidateGetAccountParamsError>;
type ValidateGetAccountParamsError = InvalidRequestError;

type TevmGetAccountError = AccountNotFoundError | ValidateGetAccountParamsError;

/**
 * Result of GetAccount Action
 */
type GetAccountResult<ErrorType = TevmGetAccountError> = {
    /**
     * Description of the exception, if any occurred
     */
    errors?: ErrorType[];
    /**
     * Address of account
     */
    address: Address;
    /**
     * Nonce to set account to
     */
    nonce: bigint;
    /**
     * Balance to set account to
     */
    balance: bigint;
    /**
     * Contract bytecode to set account to
     */
    deployedBytecode: Hex;
    /**
     * Storage root to set account to
     */
    storageRoot: Hex;
    /**
     * Code hash to set account to
     */
    codeHash: Hex;
    /**
     * True if account is a contract
     */
    isContract: boolean;
    /**
     * True if account is empty
     */
    isEmpty: boolean;
    /**
     * Contract storage for the account
     * only included if `returnStorage` is set to true in the request
     */
    storage?: {
        [key: Hex]: Hex;
    };
};

/**
 * Gets the state of a specific Ethereum address.
 * This handler is for use with a low-level TEVM `TevmNode`, unlike `tevmGetAccount`.
 * @example
 * ```typescript
 * import { createClient } from 'tevm'
 * import { getAccountHandler } from 'tevm/actions'
 *
 * const client = createClient()
 * const getAccount = getAccountHandler(client)
 *
 * const res = await getAccount({ address: '0x123...' })
 * console.log(res.deployedBytecode)
 * console.log(res.nonce)
 * console.log(res.balance)
 * ```
 */
type GetAccountHandler = (params: GetAccountParams) => Promise<GetAccountResult>;

/**
 * JSON-RPC request for `tevm_getAccount` method
 */
type GetAccountJsonRpcRequest = JsonRpcRequest<'tevm_getAccount', [SerializeToJson<GetAccountParams>]>;

/**
 * JSON-RPC response for `tevm_getAccount` method
 */
type GetAccountJsonRpcResponse = JsonRpcResponse<'tevm_getAccount', SerializeToJson<GetAccountResult>, TevmGetAccountError['code']>;

/**
 * GetAccount JSON-RPC tevm procedure puts an account or contract into the tevm state
 */
type GetAccountJsonRpcProcedure = (request: GetAccountJsonRpcRequest) => Promise<GetAccountJsonRpcResponse>;

declare function getAccountHandler(client: _tevm_node.TevmNode, options?: {
    throwOnFail?: boolean | undefined;
}): GetAccountHandler;

declare function getAccountProcedure(client: _tevm_node.TevmNode): GetAccountJsonRpcProcedure;

/**
 * Zod validator for a valid getAccount action
 */
declare const zGetAccountParams: z.ZodObject<{
    throwOnFail: z.ZodOptional<z.ZodBoolean>;
    address: z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>;
    blockTag: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"latest">, z.ZodLiteral<"earliest">, z.ZodLiteral<"pending">, z.ZodLiteral<"safe">, z.ZodLiteral<"finalized">, z.ZodBigInt, z.ZodPipe<z.ZodNumber, z.ZodTransform<bigint, number>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>]>>;
    returnStorage: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;

declare function forkAndCacheBlock(client: _tevm_node.TevmNode, block: _tevm_block.Block, executeBlock?: boolean): Promise<_tevm_vm.Vm>;

/**
 * Zod validator for a valid ABI
 */
declare const zAbi: zod.ZodReadonly<any>;

/**
 * Zod validator for a valid ethereum address
 */
declare const zAddress: z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>;

/**
 * Zod validator for a block header specification within actions
 */
declare const zBlock: z.ZodObject<{
    number: z.ZodBigInt;
    coinbase: z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>;
    timestamp: z.ZodBigInt;
    difficulty: z.ZodBigInt;
    gasLimit: z.ZodBigInt;
    baseFeePerGas: z.ZodOptional<z.ZodBigInt>;
    blobGasPrice: z.ZodOptional<z.ZodBigInt>;
}, z.core.$strict>;

declare const zBlockOverrideSet: z.ZodObject<{
    number: z.ZodOptional<z.ZodBigInt>;
    time: z.ZodOptional<z.ZodBigInt>;
    gasLimit: z.ZodOptional<z.ZodBigInt>;
    coinbase: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    baseFee: z.ZodOptional<z.ZodBigInt>;
    blobBaseFee: z.ZodOptional<z.ZodBigInt>;
}, z.core.$strict>;

declare const zBlockParam: z.ZodUnion<readonly [z.ZodLiteral<"latest">, z.ZodLiteral<"earliest">, z.ZodLiteral<"pending">, z.ZodLiteral<"safe">, z.ZodLiteral<"finalized">, z.ZodBigInt, z.ZodPipe<z.ZodNumber, z.ZodTransform<bigint, number>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>]>;

/**
 * Zod validator for valid Ethereum bytecode
 */
declare const zBytecode: zod.ZodPipe<zod.ZodString, zod.ZodTransform<`0x${string}`, string>>;

/**
 * Zod validator for a valid hex string
 */
declare const zHex: z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>;

declare const zStateOverrideSet: z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>, z.ZodObject<{
    balance: z.ZodOptional<z.ZodBigInt>;
    nonce: z.ZodOptional<z.ZodBigInt>;
    code: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
    state: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    stateDiff: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
}, z.core.$strict>>;

/**
 * Zod validator for valid ethereum storage root
 */
declare const zStorageRoot: z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>;

/**
 * Parameters for the `tevmLoadState` method.
 *
 * This method takes a {@link SerializableTevmState} object and loads it into the VM state.
 *
 * @example
 * ```typescript
 * import { createClient } from 'tevm'
 * import { loadStateHandler } from 'tevm/actions'
 * import fs from 'fs'
 *
 * const client = createClient()
 * const loadState = loadStateHandler(client)
 *
 * const state = JSON.parse(fs.readFileSync('state.json'))
 * await loadState({ state })
 * ```
 *
 * @param {BaseParams} TThrowOnFail - Optional parameter to throw an error on failure.
 * @param {SerializableTevmState} state - The TEVM state object to load.
 */
type LoadStateParams<TThrowOnFail extends boolean = boolean> = BaseParams<TThrowOnFail> & {
    /**
     * The TEVM state object to load.
     */
    readonly state: SerializableTevmState;
};

/**
 * Error type for `tevmLoadState`.
 *
 * This type represents the possible errors that can occur during the execution of the `tevmLoadState` method.
 *
 * @example
 * ```typescript
 * import { createClient } from 'tevm'
 * import { loadStateHandler } from 'tevm/actions'
 * import fs from 'fs'
 *
 * const client = createClient()
 * const loadState = loadStateHandler(client)
 *
 * const state = JSON.parse(fs.readFileSync('state.json'))
 * const result = await loadState({ state })
 * if (result.errors) {
 *   console.error('Failed to load state:', result.errors)
 * }
 * ```
 *
 * @see {@link InternalError}
 */
type TevmLoadStateError = InternalError;

/**
 * Result of the `tevmLoadState` method.
 *
 * This type represents the result returned by the `tevmLoadState` method. It includes any errors that might have occurred during the state loading process.
 *
 * @example
 * ```typescript
 * import { createClient } from 'tevm'
 * import { loadStateHandler } from 'tevm/actions'
 * import fs from 'fs'
 *
 * const client = createClient()
 * const loadState = loadStateHandler(client)
 *
 * const state = JSON.parse(fs.readFileSync('state.json'))
 * const result = await loadState({ state })
 * if (result.errors) {
 *   console.error('Failed to load state:', result.errors)
 * }
 * ```
 *
 * @see {@link TevmLoadStateError}
 */
type LoadStateResult<ErrorType = TevmLoadStateError> = {
    /**
     * Description of the exception, if any occurred.
     */
    errors?: ErrorType[];
};

/**
 * Loads a previously dumped state into the VM.
 *
 * State can be dumped as follows:
 * @example
 * ```typescript
 * import { dumpStateHandler } from 'tevm/actions'
 * import { createClient } from 'tevm'
 * import fs from 'fs'
 *
 * const client = createClient()
 * const dumpState = dumpStateHandler(client)
 *
 * const { state } = await dumpState()
 * fs.writeFileSync('state.json', JSON.stringify(state))
 * ```
 *
 * And then loaded as follows:
 * @example
 * ```typescript
 * import { loadStateHandler } from 'tevm/actions'
 * import { createClient } from 'tevm'
 * import fs from 'fs'
 *
 * const client = createClient()
 * const loadState = loadStateHandler(client)
 *
 * const state = JSON.parse(fs.readFileSync('state.json'))
 * await loadState({ state })
 * ```
 *
 * Note: This handler is intended for use with the low-level TEVM TevmNode, unlike `tevmLoadState` which is a higher-level API function.
 *
 * @param {LoadStateParams} params - The parameters for loading the state.
 * @returns {Promise<LoadStateResult>} The result of the load state operation.
 */
type LoadStateHandler = (params: LoadStateParams) => Promise<LoadStateResult>;

/**
 * The parameters for the `tevm_loadState` method
 */
type SerializedParams = {
    state: SerializeToJson<ParameterizedTevmState>;
};
/**
 * The JSON-RPC request for the `tevm_loadState` method
 */
type LoadStateJsonRpcRequest = JsonRpcRequest<'tevm_loadState', [SerializedParams]>;

/**
 * Response of the `tevm_loadState` RPC method.
 */
type LoadStateJsonRpcResponse = JsonRpcResponse<'tevm_loadState', SerializeToJson<LoadStateResult>, TevmLoadStateError['code']>;

/**
 * Procedure for handling script JSON-RPC requests
 * Procedure for handling tevm_loadState JSON-RPC requests
 * @returns jsonrpc error response if there are errors otherwise it returns a successful empty object result
 * @example
 * const result = await tevm.request({
 *.   method: 'tevm_loadState',
 *    params: { '0x..': '0x...', ...},
 *.   id: 1,
 *   jsonrpc: '2.0'
 *. }
 * console.log(result) // { jsonrpc: '2.0', id: 1, method: 'tevm_loadState', result: {}}
 */
type LoadStateJsonRpcProcedure = (request: LoadStateJsonRpcRequest) => Promise<LoadStateJsonRpcResponse>;

declare function loadStateHandler(client: _tevm_node.TevmNode, options?: {
    throwOnFail?: boolean | undefined;
}): LoadStateHandler;

declare function loadStateProcedure(client: _tevm_node.TevmNode): LoadStateJsonRpcProcedure;

declare function validateLoadStateParams(action: LoadStateParams): Array<ValidateLoadStateParamsError>;
/**
 * Type for errors returned by validateLoadStateParams.
 */
type ValidateLoadStateParamsError = InvalidRequestError;

declare const zLoadStateParams: z.ZodObject<{
    state: z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodObject<{
        throwOnFail: z.ZodOptional<z.ZodBoolean>;
        nonce: z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>;
        balance: z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>;
        storageRoot: z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>;
        codeHash: z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>;
        storage: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    }, z.core.$strip>>;
}, z.core.$strip>;

/**
 * Event handlers for mining operations
 * @example
 * ```typescript
 * import { createMemoryClient } from 'tevm'
 * import { mine } from 'tevm/actions'
 *
 * const client = createMemoryClient()
 *
 * const result = await mine(client, {
 *   blockCount: 1,
 *   onBlock: (block, next) => {
 *     console.log(`New block mined: ${block.header.number}`)
 *     next?.()
 *   }
 * })
 * ```
 */
type MineEvents = {
    /**
     * Handler called for each new block mined
     * @param block The newly mined block
     * @param next Function to continue execution - must be called to proceed
     */
    onBlock?: (block: Block$1, next?: () => void) => void;
    /**
     * Handler called for each transaction receipt generated during mining
     * @param receipt The transaction receipt
     * @param blockHash The hash of the block containing the receipt
     * @param next Function to continue execution - must be called to proceed
     */
    onReceipt?: (receipt: TxReceipt, blockHash: Hex$1, next?: () => void) => void;
    /**
     * Handler called for each transaction log generated during mining
     * @param log The transaction log
     * @param receipt The receipt containing the log
     * @param next Function to continue execution - must be called to proceed
     */
    onLog?: (log: TxReceipt['logs'][number], receipt: TxReceipt, next?: () => void) => void;
};

/**
 * Tevm params to mine one or more blocks.
 * @example
 * ```typescript
 * const mineParams: import('@tevm/actions').MineParams = {
 *   blockCount: 5,
 *   onBlock: (block, next) => {
 *     console.log(`Block mined: ${block.header.number}`)
 *     next()
 *   }
 * }
 * ```
 * @property {number} [blockCount=1] - Number of blocks to mine. Defaults to 1.
 * @property {number} [interval=1] - Interval between block timestamps in seconds. Defaults to 1.
 * @extends {BaseParams}
 * @extends {MineEvents}
 */
type MineParams<TThrowOnFail extends boolean = boolean> = BaseParams<TThrowOnFail> & MineEvents & {
    /**
     * The txHash to mine if only mining one tx
     */
    readonly tx?: Hex;
    /**
     * Number of blocks to mine. Defaults to 1.
     */
    readonly blockCount?: number;
    /**
     * Interval between block timestamps. Defaults to 1.
     */
    readonly interval?: number;
};

/**
 * Result of Mine Method
 */
type MineResult = {
    /**
     * Array of mined block hashes
     */
    blockHashes: Array<Hex$1>;
    /**
     * No errors occurred
     */
    errors?: undefined;
} | {
    /**
     * No block hashes available
     */
    blockHashes?: undefined;
    /**
     * Description of the exception, if any occurred
     */
    errors: TevmMineError[];
};

/**
 * Mines a block including all transactions in the mempool.
 *
 * @example
 * ```typescript
 * const res = await tevmClient.mine({ blocks: 2, interval: 2 })
 * console.log(res.errors) // undefined
 * ```
 *
 * @param {MineParams} [params] - The parameters for the mine action.
 * @returns {Promise<MineResult>} - The result of the mine action.
 *
 * @see {@link MineParams} for details on the parameters.
 * @see {@link MineResult} for details on the result.
 */
type MineHandler = (params?: MineParams) => Promise<MineResult>;

/**
 * JSON-RPC request for `tevm_mine` method
 */
type MineJsonRpcRequest = JsonRpcRequest<'tevm_mine', [blockCount: Hex$1, interval: Hex$1]>;

/**
 * JSON-RPC response for `tevm_mine` method
 */
type MineJsonRpcResponse = JsonRpcResponse<'tevm_mine', SerializeToJson<MineResult>, TevmMineError['code']>;

/**
 * Mine JSON-RPC tevm procedure mines 1 or more blocks
 */
type MineJsonRpcProcedure = (request: MineJsonRpcRequest) => Promise<MineJsonRpcResponse>;

declare function mineHandler(client: _tevm_node.TevmNode, options?: {
    throwOnFail?: boolean | undefined;
}): MineHandler;

declare function mineProcedure(client: _tevm_node.TevmNode): MineJsonRpcProcedure;

declare function validateMineEvents(events: unknown): {
    isValid: boolean;
    errors: Array<{
        path: string;
        message: string;
    }>;
};

declare function validateMineParams(action: MineParams): Array<ValidateMineParamsError>;
type ValidateMineParamsError = InvalidAddressError | InvalidBalanceError | InvalidNonceError | InvalidRequestError;

/**
 * Zod validator for a valid mine action invocation
 */
declare const zMineParams: z.ZodObject<{
    throwOnFail: z.ZodOptional<z.ZodBoolean>;
    blockCount: z.ZodOptional<z.ZodNumber>;
    interval: z.ZodOptional<z.ZodNumber>;
    onBlock: z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>;
    onReceipt: z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>;
    onLog: z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>;
}, z.core.$strip>;

/**
 * Tevm params to set an account in the vm state
 * all fields are optional except address
 * @example
 * const accountParams: import('tevm/api').SetAccountParams = {
 *   account: '0x...',
 *   nonce: 5n,
 *   balance: 9000000000000n,
 *   storageRoot: '0x....',
 *   deployedBytecode: '0x....'
 * }
 */
type SetAccountParams<TThrowOnFail extends boolean = boolean> = BaseParams<TThrowOnFail> & {
    /**
     * Address of account
     */
    readonly address: Address$1;
    /**
     * Nonce to set account to
     */
    readonly nonce?: bigint;
    /**
     * Balance to set account to
     */
    readonly balance?: bigint;
    /**
     * Contract bytecode to set account to
     */
    readonly deployedBytecode?: Hex$1;
    /**
     * Storage root to set account to
     */
    readonly storageRoot?: Hex$1;
    /**
     * key-value mapping to override all slots in the account storage before executing the calls
     */
    readonly state?: Record<Hex$1, Hex$1>;
    /**
     * key-value mapping to override individual slots in the account storage before executing the calls
     */
    readonly stateDiff?: Record<Hex$1, Hex$1>;
};

/**
 * JSON-RPC request for `tevm_setAccount` method
 */
type SetAccountJsonRpcRequest = JsonRpcRequest<'tevm_setAccount', [SerializeToJson<SetAccountParams>]>;

/**
 * A Tevm JSON-RPC request
 * `tevm_account`, `tevm_call`, `tevm_contract`, `tevm_script`
 */
type TevmJsonRpcRequest = GetAccountJsonRpcRequest | SetAccountJsonRpcRequest | CallJsonRpcRequest | LoadStateJsonRpcRequest | DumpStateJsonRpcRequest | MineJsonRpcRequest;

/**
 * A mapping of `anvil_*` method names to their return type
 */
type AnvilReturnType = {
    anvil_impersonateAccount: AnvilImpersonateAccountJsonRpcResponse;
    anvil_stopImpersonatingAccount: AnvilStopImpersonatingAccountJsonRpcResponse;
    anvil_getAutomine: AnvilGetAutomineJsonRpcResponse;
    anvil_mine: AnvilMineJsonRpcResponse;
    anvil_reset: AnvilResetJsonRpcResponse;
    anvil_dropTransaction: AnvilDropTransactionJsonRpcResponse;
    anvil_setBalance: AnvilSetBalanceJsonRpcResponse;
    anvil_setCode: AnvilSetCodeJsonRpcResponse;
    anvil_setNonce: AnvilSetNonceJsonRpcResponse;
    anvil_setStorageAt: AnvilSetStorageAtJsonRpcResponse;
    anvil_setChainId: AnvilSetChainIdJsonRpcResponse;
    anvil_dumpState: AnvilDumpStateJsonRpcResponse;
    anvil_loadState: AnvilLoadStateJsonRpcResponse;
    anvil_setCoinbase: AnvilSetCoinbaseJsonRpcResponse;
    anvil_deal: AnvilDealJsonRpcResponse;
};

/**
 * A mapping of `debug_*` method names to their return type
 */
type DebugReturnType = {
    debug_traceTransaction: DebugTraceTransactionJsonRpcResponse;
    debug_traceCall: DebugTraceCallJsonRpcResponse;
    debug_traceBlock: DebugTraceBlockJsonRpcResponse;
    debug_traceState: DebugTraceStateJsonRpcResponse;
};

/**
 * A mapping of `eth_*` method names to their return type
 */
type EthReturnType = {
    eth_call: EthCallJsonRpcResponse;
    eth_gasPrice: EthGasPriceJsonRpcResponse;
    eth_sign: EthSignJsonRpcResponse;
    eth_newBlockFilter: EthNewBlockFilterJsonRpcResponse;
    eth_mining: EthMiningJsonRpcResponse;
    eth_blobBaseFee: EthBlobBaseFeeJsonRpcResponse;
    eth_chainId: EthChainIdJsonRpcResponse;
    eth_getCode: EthGetCodeJsonRpcResponse;
    eth_getLogs: EthGetLogsJsonRpcResponse;
    eth_syncing: EthSyncingJsonRpcResponse;
    eth_accounts: EthAccountsJsonRpcResponse;
    eth_coinbase: EthCoinbaseJsonRpcResponse;
    eth_hashrate: EthHashrateJsonRpcResponse;
    eth_newFilter: EthNewFilterJsonRpcResponse;
    eth_getBalance: EthGetBalanceJsonRpcResponse;
    eth_blockNumber: EthBlockNumberJsonRpcResponse;
    eth_estimateGas: EthEstimateGasJsonRpcResponse;
    eth_getStorageAt: EthGetStorageAtJsonRpcResponse;
    eth_getFilterLogs: EthGetFilterLogsJsonRpcResponse;
    eth_getBlockByHash: EthGetBlockByHashJsonRpcResponse;
    eth_protocolVersion: EthProtocolVersionJsonRpcResponse;
    eth_sendTransaction: EthSendTransactionJsonRpcResponse;
    eth_signTransaction: EthSignTransactionJsonRpcResponse;
    eth_uninstallFilter: EthUninstallFilterJsonRpcResponse;
    eth_getBlockByNumber: EthGetBlockByNumberJsonRpcResponse;
    eth_getFilterChanges: EthGetFilterChangesJsonRpcResponse;
    eth_sendRawTransaction: EthSendRawTransactionJsonRpcResponse;
    eth_getTransactionCount: EthGetTransactionCountJsonRpcResponse;
    eth_getTransactionByHash: EthGetTransactionByHashJsonRpcResponse;
    eth_getTransactionReceipt: EthGetTransactionReceiptJsonRpcResponse;
    eth_getUncleCountByBlockHash: EthGetUncleCountByBlockHashJsonRpcResponse;
    eth_getUncleCountByBlockNumber: EthGetUncleCountByBlockNumberJsonRpcResponse;
    eth_getUncleByBlockHashAndIndex: EthGetUncleByBlockHashAndIndexJsonRpcResponse;
    eth_newPendingTransactionFilter: EthNewPendingTransactionFilterJsonRpcResponse;
    eth_getUncleByBlockNumberAndIndex: EthGetUncleByBlockNumberAndIndexJsonRpcResponse;
    eth_getBlockTransactionCountByHash: EthGetBlockTransactionCountByHashJsonRpcResponse;
    eth_getBlockTransactionCountByNumber: EthGetBlockTransactionCountByNumberJsonRpcResponse;
    eth_getTransactionByBlockHashAndIndex: EthGetTransactionByBlockHashAndIndexJsonRpcResponse;
    eth_getTransactionByBlockNumberAndIndex: EthGetTransactionByBlockNumberAndIndexJsonRpcResponse;
    eth_createAccessList: EthCreateAccessListJsonRpcResponse;
};

declare function validateSetAccountParams(action: SetAccountParams): Array<ValidateSetAccountParamsError>;
type ValidateSetAccountParamsError = InvalidAddressError | InvalidBalanceError | InvalidDeployedBytecodeError | InvalidNonceError | InvalidRequestError | InvalidStorageRootError;

type TevmSetAccountError = ValidateSetAccountParamsError | InternalError | InvalidAddressError;

/**
 * Result of SetAccount Action
 */
type SetAccountResult<ErrorType = TevmSetAccountError> = {
    /**
     * Description of the exception, if any occurred
     */
    errors?: ErrorType[];
};

/**
 * JSON-RPC response for `tevm_setAccount` method
 */
type SetAccountJsonRpcResponse = JsonRpcResponse<'tevm_setAccount', SerializeToJson<SetAccountResult>, TevmSetAccountError['code']>;

/**
 * A mapping of `tevm_*` method names to their return type
 */
type TevmReturnType = {
    tevm_call: CallJsonRpcResponse;
    /**
     * @deprecated
     */
    tevm_loadState: LoadStateJsonRpcResponse;
    tevm_dumpState: DumpStateJsonRpcResponse;
    tevm_getAccount: GetAccountJsonRpcResponse;
    tevm_setAccount: SetAccountJsonRpcResponse;
    tevm_mine: MineJsonRpcResponse;
};

/**
 * Utility type to get the return type given a method name
 * @example
 * ```typescript
 * type BlockNumberReturnType = JsonRpcReturnTypeFromMethod<'eth_blockNumber'>
 * ```
 */
type JsonRpcReturnTypeFromMethod<TMethod extends keyof EthReturnType | keyof TevmReturnType | keyof AnvilReturnType | keyof DebugReturnType> = (EthReturnType & TevmReturnType & AnvilReturnType & DebugReturnType)[TMethod];

/**
 * @experimental
 * Bulk request handler for JSON-RPC requests. Takes an array of requests and returns an array of results.
 * Bulk requests are currently handled in parallel which can cause issues if the requests are expected to run
 * sequentially or interphere with each other. An option for configuring requests sequentially or in parallel
 * will be added in the future.
 *
 * Currently is not very generic with regard to input and output types.
 * @example
 * ```typescript
 * const [blockNumberResponse, gasPriceResponse] = await tevm.requestBulk([{
 *  method: 'eth_blockNumber',
 *  params: []
 *  id: 1
 *  jsonrpc: '2.0'
 * }, {
 *  method: 'eth_gasPrice',
 *  params: []
 *  id: 1
 *  jsonrpc: '2.0'
 * }])
 * ```
 *
 * ### tevm_* methods
 *
 * #### tevm_call
 *
 * request - {@link CallJsonRpcRequest}
 * response - {@link CallJsonRpcResponse}
 *
 * #### tevm_getAccount
 *
 * request - {@link GetAccountJsonRpcRequest}
 * response - {@link GetAccountJsonRpcResponse}
 *
 * #### tevm_setAccount
 *
 * request - {@link SetAccountJsonRpcRequest}
 * response - {@link SetAccountJsonRpcResponse}
 *
 * ### debug_* methods
 *
 * #### debug_traceCall
 *
 * request - {@link DebugTraceCallJsonRpcRequest}
 * response - {@link DebugTraceCallJsonRpcResponse}
 *
 * ### eth_* methods
 *
 * #### eth_blockNumber
 *
 * request - {@link EthBlockNumberJsonRpcRequest}
 * response - {@link EthBlockNumberJsonRpcResponse}
 *
 * #### eth_chainId
 *
 * request - {@link EthChainIdJsonRpcRequest}
 * response - {@link EthChainIdJsonRpcResponse}
 *
 * #### eth_getCode
 *
 * request - {@link EthGetCodeJsonRpcRequest}
 * response - {@link EthGetCodeJsonRpcResponse}
 *
 * #### eth_getStorageAt
 *
 * request - {@link EthGetStorageAtJsonRpcRequest}
 * response - {@link EthGetStorageAtJsonRpcResponse}
 *
 * #### eth_gasPrice
 *
 * request - {@link EthGasPriceJsonRpcRequest}
 * response - {@link EthGasPriceJsonRpcResponse}
 *
 * #### eth_getBalance
 *
 * request - {@link EthGetBalanceJsonRpcRequest}
 * response - {@link EthGetBalanceJsonRpcResponse}
 */
type TevmJsonRpcBulkRequestHandler = (requests: ReadonlyArray<TevmJsonRpcRequest | EthJsonRpcRequest | AnvilJsonRpcRequest | DebugJsonRpcRequest>) => Promise<Array<JsonRpcReturnTypeFromMethod<any>>>;

declare function requestBulkProcedure(client: _tevm_node.TevmNode): TevmJsonRpcBulkRequestHandler;

/**
 * Typesafe request handler for JSON-RPC requests. Most users will want to use the higher level
 * and more feature-rich `actions` api
 * @example
 * ```typescript
 * const blockNumberResponse = await tevm.request({
 *  method: 'eth_blockNumber',
 *  params: []
 *  id: 1
 *  jsonrpc: '2.0'
 * })
 * const accountResponse = await tevm.request({
 *  method: 'tevm_getAccount',
 *  params: [{address: '0x123...'}]
 *  id: 1
 *  jsonrpc: '2.0'
 * })
 * ```
 *
 * ### tevm_* methods
 *
 * #### tevm_call
 *
 * request - {@link CallJsonRpcRequest}
 * response - {@link CallJsonRpcResponse}
 *
 * #### tevm_getAccount
 *
 * request - {@link GetAccountJsonRpcRequest}
 * response - {@link GetAccountJsonRpcResponse}
 *
 * #### tevm_setAccount
 *
 * request - {@link SetAccountJsonRpcRequest}
 * response - {@link SetAccountJsonRpcResponse}
 *
 * ### debug_* methods
 *
 * #### debug_traceCall
 *
 * request - {@link DebugTraceCallJsonRpcRequest}
 * response - {@link DebugTraceCallJsonRpcResponse}
 *
 * ### eth_* methods
 *
 * #### eth_blockNumber
 *
 * request - {@link EthBlockNumberJsonRpcRequest}
 * response - {@link EthBlockNumberJsonRpcResponse}
 *
 * #### eth_chainId
 *
 * request - {@link EthChainIdJsonRpcRequest}
 * response - {@link EthChainIdJsonRpcResponse}
 *
 * #### eth_getCode
 *
 * request - {@link EthGetCodeJsonRpcRequest}
 * response - {@link EthGetCodeJsonRpcResponse}
 *
 * #### eth_getStorageAt
 *
 * request - {@link EthGetStorageAtJsonRpcRequest}
 * response - {@link EthGetStorageAtJsonRpcResponse}
 *
 * #### eth_gasPrice
 *
 * request - {@link EthGasPriceJsonRpcRequest}
 * response - {@link EthGasPriceJsonRpcResponse}
 *
 * #### eth_getBalance
 *
 * request - {@link EthGetBalanceJsonRpcRequest}
 * response - {@link EthGetBalanceJsonRpcResponse}
 *
 * #### eth_createAccessList
 *
 * Creates an access list for a transaction.
 * Returns list of addresses and storage keys that the transaction plans to access.
 *
 * request - {@link EthCreateAccessListJsonRpcRequest}
 * response - {@link EthCreateAccessListJsonRpcResponse}
 *
 * ```typescript
 * const response = await tevm.request({
 *   method: 'eth_createAccessList',
 *   params: [{
 *     to: '0x...',
 *     data: '0x...'
 *   }],
 *   id: 1,
 *   jsonrpc: '2.0'
 * })
 * ```
 */
type TevmJsonRpcRequestHandler = <TRequest extends TevmJsonRpcRequest | EthJsonRpcRequest | AnvilJsonRpcRequest | DebugJsonRpcRequest>(request: TRequest) => Promise<JsonRpcReturnTypeFromMethod<TRequest['method']>>;

declare function requestProcedure(client: _tevm_node.TevmNode): TevmJsonRpcRequestHandler;

/**
 * Sets the state of a specific ethereum address
 * @example
 * import {parseEther} from 'tevm'
 *
 * await tevm.setAccount({
 *  address: '0x123...',
 *  deployedBytecode: '0x6080604...',
 *  balance: parseEther('1.0')
 * })
 */
type SetAccountHandler = (params: SetAccountParams) => Promise<SetAccountResult>;

/**
 * SetAccount JSON-RPC tevm procedure sets an account into the tevm state
 */
type SetAccountJsonRpcProcedure = (request: SetAccountJsonRpcRequest) => Promise<SetAccountJsonRpcResponse>;

declare function setAccountHandler(client: _tevm_node.TevmNode, options?: {
    throwOnFail?: boolean | undefined;
}): SetAccountHandler;

declare function setAccountProcedure(client: _tevm_node.TevmNode): SetAccountJsonRpcProcedure;

/**
 * Zod validator for a valid setAccount action
 */
declare const zSetAccountParams: z.ZodObject<{
    throwOnFail: z.ZodOptional<z.ZodBoolean>;
    address: z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>;
    balance: z.ZodOptional<z.ZodBigInt>;
    nonce: z.ZodOptional<z.ZodBigInt>;
    deployedBytecode: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
    storageRoot: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    state: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    stateDiff: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
}, z.core.$strip>;

/**
 * A mapping of `anvil_*` method names to their request type
 */
type AnvilRequestType = {
    anvil_impersonateAccount: AnvilImpersonateAccountJsonRpcRequest;
    anvil_stopImpersonatingAccount: AnvilStopImpersonatingAccountJsonRpcRequest;
    anvil_getAutomine: AnvilGetAutomineJsonRpcRequest;
    anvil_mine: AnvilMineJsonRpcRequest;
    anvil_reset: AnvilResetJsonRpcRequest;
    anvil_dropTransaction: AnvilDropTransactionJsonRpcRequest;
    anvil_setBalance: AnvilSetBalanceJsonRpcRequest;
    anvil_setCode: AnvilSetCodeJsonRpcRequest;
    anvil_setNonce: AnvilSetNonceJsonRpcRequest;
    anvil_setStorageAt: AnvilSetStorageAtJsonRpcRequest;
    anvil_setChainId: AnvilSetChainIdJsonRpcRequest;
    anvil_dumpState: AnvilDumpStateJsonRpcRequest;
    anvil_loadState: AnvilLoadStateJsonRpcRequest;
    anvil_deal: AnvilDealJsonRpcRequest;
};

/**
 * A mapping of `debug_*` method names to their request type
 */
type DebugRequestType = {
    debug_traceTransaction: DebugTraceTransactionJsonRpcRequest;
    debug_traceCall: DebugTraceCallJsonRpcRequest;
    debug_traceBlock: DebugTraceBlockJsonRpcRequest;
    debug_traceState: DebugTraceStateJsonRpcRequest;
};

/**
 * A mapping of `eth_*` method names to their request type
 */
type EthRequestType = {
    eth_call: EthCallJsonRpcRequest;
    eth_gasPrice: EthGasPriceJsonRpcRequest;
    eth_sign: EthSignJsonRpcRequest;
    eth_newBlockFilter: EthNewBlockFilterJsonRpcRequest;
    eth_mining: EthMiningJsonRpcRequest;
    eth_chainId: EthChainIdJsonRpcRequest;
    eth_getCode: EthGetCodeJsonRpcRequest;
    eth_getLogs: EthGetLogsJsonRpcRequest;
    eth_syncing: EthSyncingJsonRpcRequest;
    eth_accounts: EthAccountsJsonRpcRequest;
    eth_coinbase: EthCoinbaseJsonRpcRequest;
    eth_hashrate: EthHashrateJsonRpcRequest;
    eth_newFilter: EthNewFilterJsonRpcRequest;
    eth_getBalance: EthGetBalanceJsonRpcRequest;
    eth_blockNumber: EthBlockNumberJsonRpcRequest;
    eth_estimateGas: EthEstimateGasJsonRpcRequest;
    eth_getStorageAt: EthGetStorageAtJsonRpcRequest;
    eth_getFilterLogs: EthGetFilterLogsJsonRpcRequest;
    eth_getBlockByHash: EthGetBlockByHashJsonRpcRequest;
    eth_protocolVersion: EthProtocolVersionJsonRpcRequest;
    eth_sendTransaction: EthSendTransactionJsonRpcRequest;
    eth_signTransaction: EthSignTransactionJsonRpcRequest;
    eth_uninstallFilter: EthUninstallFilterJsonRpcRequest;
    eth_getBlockByNumber: EthGetBlockByNumberJsonRpcRequest;
    eth_getFilterChanges: EthGetFilterChangesJsonRpcRequest;
    eth_sendRawTransaction: EthSendRawTransactionJsonRpcRequest;
    eth_getTransactionCount: EthGetTransactionCountJsonRpcRequest;
    eth_getTransactionByHash: EthGetTransactionByHashJsonRpcRequest;
    eth_getTransactionReceipt: EthGetTransactionReceiptJsonRpcRequest;
    eth_getUncleCountByBlockHash: EthGetUncleCountByBlockHashJsonRpcRequest;
    eth_getUncleCountByBlockNumber: EthGetUncleCountByBlockNumberJsonRpcRequest;
    eth_getUncleByBlockHashAndIndex: EthGetUncleByBlockHashAndIndexJsonRpcRequest;
    eth_newPendingTransactionFilter: EthNewPendingTransactionFilterJsonRpcRequest;
    eth_getUncleByBlockNumberAndIndex: EthGetUncleByBlockNumberAndIndexJsonRpcRequest;
    eth_getBlockTransactionCountByHash: EthGetBlockTransactionCountByHashJsonRpcRequest;
    eth_getBlockTransactionCountByNumber: EthGetBlockTransactionCountByNumberJsonRpcRequest;
    eth_getTransactionByBlockHashAndIndex: EthGetTransactionByBlockHashAndIndexJsonRpcRequest;
    eth_getTransactionByBlockNumberAndIndex: EthGetTransactionByBlockNumberAndIndexJsonRpcRequest;
};

/**
 * A mapping of `tevm_*` method names to their request type
 */
type TevmRequestType = {
    tevm_call: CallJsonRpcRequest;
    tevm_loadState: LoadStateJsonRpcRequest;
    tevm_dumpState: DumpStateJsonRpcRequest;
    tevm_getAccount: GetAccountJsonRpcRequest;
    tevm_setAccount: SetAccountJsonRpcRequest;
    tevm_mine: MineJsonRpcRequest;
};

/**
 * Utility type to get the request type given a method name
 * @example
 * ```typescript
 * type BlockNumberRequestType = JsonRpcRequestTypeFromMethod<'eth_blockNumber'>
 * ```
 */
type JsonRpcRequestTypeFromMethod<TMethod extends keyof EthRequestType | keyof TevmRequestType | keyof AnvilRequestType | keyof DebugRequestType> = (EthRequestType & TevmRequestType & AnvilRequestType & DebugRequestType)[TMethod];

export { type Abi, type AccountState, type Address, type AnvilDealHandler, type AnvilDealJsonRpcRequest, type AnvilDealJsonRpcResponse, type AnvilDealParams, type AnvilDealProcedure, type AnvilDealResult, type AnvilDropTransactionHandler, type AnvilDropTransactionJsonRpcRequest, type AnvilDropTransactionJsonRpcResponse, type AnvilDropTransactionParams, type AnvilDropTransactionProcedure, type AnvilDropTransactionResult, type AnvilDumpStateHandler, type AnvilDumpStateJsonRpcRequest, type AnvilDumpStateJsonRpcResponse, type AnvilDumpStateParams, type AnvilDumpStateProcedure, type AnvilDumpStateResult, type AnvilGetAutomineHandler, type AnvilGetAutomineJsonRpcRequest, type AnvilGetAutomineJsonRpcResponse, type AnvilGetAutomineParams, type AnvilGetAutomineProcedure, type AnvilGetAutomineResult, type AnvilImpersonateAccountHandler, type AnvilImpersonateAccountJsonRpcRequest, type AnvilImpersonateAccountJsonRpcResponse, type AnvilImpersonateAccountParams, type AnvilImpersonateAccountProcedure, type AnvilImpersonateAccountResult, type AnvilJsonRpcRequest, type AnvilLoadStateHandler, type AnvilLoadStateJsonRpcRequest, type AnvilLoadStateJsonRpcResponse, type AnvilLoadStateParams, type AnvilLoadStateProcedure, type AnvilLoadStateResult, type AnvilMineHandler, type AnvilMineJsonRpcRequest, type AnvilMineJsonRpcResponse, type AnvilMineParams, type AnvilMineProcedure, type AnvilMineResult, type AnvilProcedure, type AnvilRequestType, type AnvilResetHandler, type AnvilResetJsonRpcRequest, type AnvilResetJsonRpcResponse, type AnvilResetParams, type AnvilResetProcedure, type AnvilResetResult, type AnvilReturnType, type AnvilSetBalanceHandler, type AnvilSetBalanceJsonRpcRequest, type AnvilSetBalanceJsonRpcResponse, type AnvilSetBalanceParams, type AnvilSetBalanceProcedure, type AnvilSetBalanceResult, type AnvilSetChainIdHandler, type AnvilSetChainIdJsonRpcRequest, type AnvilSetChainIdJsonRpcResponse, type AnvilSetChainIdParams, type AnvilSetChainIdProcedure, type AnvilSetChainIdResult, type AnvilSetCodeHandler, type AnvilSetCodeJsonRpcRequest, type AnvilSetCodeJsonRpcResponse, type AnvilSetCodeParams, type AnvilSetCodeProcedure, type AnvilSetCodeResult, type AnvilSetCoinbaseJsonRpcRequest, type AnvilSetCoinbaseJsonRpcResponse, type AnvilSetCoinbaseProcedure, type AnvilSetNonceHandler, type AnvilSetNonceJsonRpcRequest, type AnvilSetNonceJsonRpcResponse, type AnvilSetNonceParams, type AnvilSetNonceProcedure, type AnvilSetNonceResult, type AnvilSetStorageAtHandler, type AnvilSetStorageAtJsonRpcRequest, type AnvilSetStorageAtJsonRpcResponse, type AnvilSetStorageAtParams, type AnvilSetStorageAtProcedure, type AnvilSetStorageAtResult, type AnvilStopImpersonatingAccountHandler, type AnvilStopImpersonatingAccountJsonRpcRequest, type AnvilStopImpersonatingAccountJsonRpcResponse, type AnvilStopImpersonatingAccountParams, type AnvilStopImpersonatingAccountProcedure, type AnvilStopImpersonatingAccountResult, type BaseCallParams, type BaseParams, type Block, type BlockOverrideSet, type BlockParam, type BlockResult, type BlockTag, type CallEvents, type CallHandler, type CallHandlerOptsError, type CallHandlerParams, type CallJsonRpcProcedure, type CallJsonRpcRequest, type CallJsonRpcResponse, type CallParams, type CallResult, type CallTraceResult, type ContractHandler, type ContractParams, type ContractResult, type DebugRequestType, type DebugReturnType, type DebugTraceBlockParams, type DebugTraceBlockResult, type DebugTraceCallHandler, type DebugTraceCallParams, type DebugTraceCallResult, type DebugTraceStateFilter, type DebugTraceStateObject, type DebugTraceStateParams, type DebugTraceStateResult, type DebugTraceTransactionParams, type DebugTraceTransactionResult, type DeployHandler, type DeployParams, type DeployResult, type DumpStateHandler, type DumpStateJsonRpcProcedure, type DumpStateJsonRpcRequest, type DumpStateJsonRpcResponse, type DumpStateParams, type DumpStateResult, type EmptyParams, type EthAccountsHandler, type EthAccountsJsonRpcProcedure, type EthAccountsJsonRpcRequest, type EthAccountsJsonRpcResponse, type EthAccountsParams, type EthAccountsResult, type EthBlobBaseFeeJsonRpcProcedure, type EthBlobBaseFeeJsonRpcRequest, type EthBlobBaseFeeJsonRpcResponse, type EthBlockNumberHandler, type EthBlockNumberJsonRpcProcedure, type EthBlockNumberJsonRpcRequest, type EthBlockNumberJsonRpcResponse, type EthBlockNumberParams, type EthBlockNumberResult, type EthCallHandler, type EthCallJsonRpcProcedure, type EthCallJsonRpcRequest, type EthCallJsonRpcResponse, type EthCallParams, type EthCallResult, type EthChainIdHandler, type EthChainIdJsonRpcProcedure, type EthChainIdJsonRpcRequest, type EthChainIdJsonRpcResponse, type EthChainIdParams, type EthChainIdResult, type EthCoinbaseHandler, type EthCoinbaseJsonRpcProcedure, type EthCoinbaseJsonRpcRequest, type EthCoinbaseJsonRpcResponse, type EthCoinbaseParams, type EthCoinbaseResult, type EthCreateAccessListJsonRpcProcedure, type EthCreateAccessListJsonRpcRequest, type EthCreateAccessListJsonRpcResponse, type EthEstimateGasHandler, type EthEstimateGasJsonRpcProcedure, type EthEstimateGasJsonRpcRequest, type EthEstimateGasJsonRpcResponse, type EthEstimateGasParams, type EthEstimateGasResult, type EthGasPriceHandler, type EthGasPriceJsonRpcProcedure, type EthGasPriceJsonRpcRequest, type EthGasPriceJsonRpcResponse, type EthGasPriceParams, type EthGasPriceResult, type EthGetBalanceHandler, type EthGetBalanceJsonRpcProcedure, type EthGetBalanceJsonRpcRequest, type EthGetBalanceJsonRpcResponse, type EthGetBalanceParams, type EthGetBalanceResult, type EthGetBlockByHashHandler, type EthGetBlockByHashJsonRpcProcedure, type EthGetBlockByHashJsonRpcRequest, type EthGetBlockByHashJsonRpcResponse, type EthGetBlockByHashParams, type EthGetBlockByHashResult, type EthGetBlockByNumberHandler, type EthGetBlockByNumberJsonRpcProcedure, type EthGetBlockByNumberJsonRpcRequest, type EthGetBlockByNumberJsonRpcResponse, type EthGetBlockByNumberParams, type EthGetBlockByNumberResult, type EthGetBlockTransactionCountByHashHandler, type EthGetBlockTransactionCountByHashJsonRpcProcedure, type EthGetBlockTransactionCountByHashJsonRpcRequest, type EthGetBlockTransactionCountByHashJsonRpcResponse, type EthGetBlockTransactionCountByHashParams, type EthGetBlockTransactionCountByHashResult, type EthGetBlockTransactionCountByNumberHandler, type EthGetBlockTransactionCountByNumberJsonRpcProcedure, type EthGetBlockTransactionCountByNumberJsonRpcRequest, type EthGetBlockTransactionCountByNumberJsonRpcResponse, type EthGetBlockTransactionCountByNumberParams, type EthGetBlockTransactionCountByNumberResult, type EthGetCodeHandler, type EthGetCodeJsonRpcProcedure, type EthGetCodeJsonRpcRequest, type EthGetCodeJsonRpcResponse, type EthGetCodeParams, type EthGetCodeResult, type EthGetFilterChangesHandler, type EthGetFilterChangesJsonRpcProcedure, type EthGetFilterChangesJsonRpcRequest, type EthGetFilterChangesJsonRpcResponse, type EthGetFilterChangesParams, type EthGetFilterChangesResult, type EthGetFilterLogsHandler, type EthGetFilterLogsJsonRpcProcedure, type EthGetFilterLogsJsonRpcRequest, type EthGetFilterLogsJsonRpcResponse, type EthGetFilterLogsParams, type EthGetFilterLogsResult, type EthGetLogsHandler, type EthGetLogsJsonRpcProcedure, type EthGetLogsJsonRpcRequest, type EthGetLogsJsonRpcResponse, type EthGetLogsParams, type EthGetLogsResult, type EthGetStorageAtHandler, type EthGetStorageAtJsonRpcProcedure, type EthGetStorageAtJsonRpcRequest, type EthGetStorageAtJsonRpcResponse, type EthGetStorageAtParams, type EthGetStorageAtResult, type EthGetTransactionByBlockHashAndIndexHandler, type EthGetTransactionByBlockHashAndIndexJsonRpcProcedure, type EthGetTransactionByBlockHashAndIndexJsonRpcRequest, type EthGetTransactionByBlockHashAndIndexJsonRpcResponse, type EthGetTransactionByBlockHashAndIndexParams, type EthGetTransactionByBlockHashAndIndexResult, type EthGetTransactionByBlockNumberAndIndexHandler, type EthGetTransactionByBlockNumberAndIndexJsonRpcProcedure, type EthGetTransactionByBlockNumberAndIndexJsonRpcRequest, type EthGetTransactionByBlockNumberAndIndexJsonRpcResponse, type EthGetTransactionByBlockNumberAndIndexParams, type EthGetTransactionByBlockNumberAndIndexResult, type EthGetTransactionByHashHandler, type EthGetTransactionByHashJsonRpcProcedure, type EthGetTransactionByHashJsonRpcRequest, type EthGetTransactionByHashJsonRpcResponse, type EthGetTransactionByHashParams, type EthGetTransactionByHashResult, type EthGetTransactionCountHandler, type EthGetTransactionCountJsonRpcProcedure, type EthGetTransactionCountJsonRpcRequest, type EthGetTransactionCountJsonRpcResponse, type EthGetTransactionCountParams, type EthGetTransactionCountResult, type EthGetTransactionReceiptHandler, type EthGetTransactionReceiptJsonRpcProcedure, type EthGetTransactionReceiptJsonRpcRequest, type EthGetTransactionReceiptJsonRpcResponse, type EthGetTransactionReceiptParams, type EthGetTransactionReceiptResult, type EthGetUncleByBlockHashAndIndexHandler, type EthGetUncleByBlockHashAndIndexJsonRpcProcedure, type EthGetUncleByBlockHashAndIndexJsonRpcRequest, type EthGetUncleByBlockHashAndIndexJsonRpcResponse, type EthGetUncleByBlockHashAndIndexParams, type EthGetUncleByBlockHashAndIndexResult, type EthGetUncleByBlockNumberAndIndexHandler, type EthGetUncleByBlockNumberAndIndexJsonRpcProcedure, type EthGetUncleByBlockNumberAndIndexJsonRpcRequest, type EthGetUncleByBlockNumberAndIndexJsonRpcResponse, type EthGetUncleByBlockNumberAndIndexParams, type EthGetUncleByBlockNumberAndIndexResult, type EthGetUncleCountByBlockHashHandler, type EthGetUncleCountByBlockHashJsonRpcProcedure, type EthGetUncleCountByBlockHashJsonRpcRequest, type EthGetUncleCountByBlockHashJsonRpcResponse, type EthGetUncleCountByBlockHashParams, type EthGetUncleCountByBlockHashResult, type EthGetUncleCountByBlockNumberHandler, type EthGetUncleCountByBlockNumberJsonRpcProcedure, type EthGetUncleCountByBlockNumberJsonRpcRequest, type EthGetUncleCountByBlockNumberJsonRpcResponse, type EthGetUncleCountByBlockNumberParams, type EthGetUncleCountByBlockNumberResult, type EthHashrateHandler, type EthHashrateJsonRpcProcedure, type EthHashrateJsonRpcRequest, type EthHashrateJsonRpcResponse, type EthHashrateParams, type EthHashrateResult, type EthJsonRpcRequest, type EthMiningHandler, type EthMiningJsonRpcProcedure, type EthMiningJsonRpcRequest, type EthMiningJsonRpcResponse, type EthMiningParams, type EthMiningResult, type EthNewBlockFilterHandler, type EthNewBlockFilterJsonRpcProcedure, type EthNewBlockFilterJsonRpcRequest, type EthNewBlockFilterJsonRpcResponse, type EthNewBlockFilterParams, type EthNewBlockFilterResult, type EthNewFilterError, type EthNewFilterHandler, type EthNewFilterJsonRpcProcedure, type EthNewFilterJsonRpcRequest, type EthNewFilterJsonRpcResponse, type EthNewFilterParams, type EthNewFilterResult, type EthNewPendingTransactionFilterHandler, type EthNewPendingTransactionFilterJsonRpcProcedure, type EthNewPendingTransactionFilterJsonRpcRequest, type EthNewPendingTransactionFilterJsonRpcResponse, type EthNewPendingTransactionFilterParams, type EthNewPendingTransactionFilterResult, type EthParams, type EthProtocolVersionHandler, type EthProtocolVersionJsonRpcProcedure, type EthProtocolVersionJsonRpcRequest, type EthProtocolVersionJsonRpcResponse, type EthProtocolVersionParams, type EthProtocolVersionResult, type EthRequestType, type EthReturnType, type EthSendRawTransactionHandler, type EthSendRawTransactionJsonRpcProcedure, type EthSendRawTransactionJsonRpcRequest, type EthSendRawTransactionJsonRpcResponse, type EthSendRawTransactionParams, type EthSendRawTransactionResult, type EthSendTransactionHandler, type EthSendTransactionJsonRpcProcedure, type EthSendTransactionJsonRpcRequest, type EthSendTransactionJsonRpcResponse, type EthSendTransactionParams, type EthSendTransactionResult, type EthSignHandler, type EthSignJsonRpcProcedure, type EthSignJsonRpcRequest, type EthSignJsonRpcResponse, type EthSignParams, type EthSignResult, type EthSignTransactionHandler, type EthSignTransactionJsonRpcProcedure, type EthSignTransactionJsonRpcRequest, type EthSignTransactionJsonRpcResponse, type EthSignTransactionParams, type EthSignTransactionResult, type EthSyncingHandler, type EthSyncingJsonRpcProcedure, type EthSyncingJsonRpcRequest, type EthSyncingJsonRpcResponse, type EthSyncingParams, type EthSyncingResult, type EthUninstallFilterHandler, type EthUninstallFilterJsonRpcProcedure, type EthUninstallFilterJsonRpcRequest, type EthUninstallFilterJsonRpcResponse, type EthUninstallFilterParams, type EthUninstallFilterResult, type EvmErrorConstructor, type ExecuteCallError, type ExecuteCallResult, type FilterLog, type FilterParams, type FourbyteTraceResult, type GetAccountHandler, type GetAccountJsonRpcProcedure, type GetAccountJsonRpcRequest, type GetAccountJsonRpcResponse, type GetAccountParams, type GetAccountResult, type HandleRunTxError, type Hex, type JsonRpcRequestTypeFromMethod, type JsonRpcReturnTypeFromMethod, type JsonRpcTransaction, type LoadStateHandler, type LoadStateJsonRpcProcedure, type LoadStateJsonRpcRequest, type LoadStateJsonRpcResponse, type LoadStateParams, type LoadStateResult, type Log, type Message, type MineEvents, type MineHandler, type MineJsonRpcProcedure, type MineJsonRpcRequest, type MineJsonRpcResponse, type MineParams, type MineResult, MissingAccountError, type NetworkConfig, type NewContractEvent, type PrestateTraceResult, type SerializedParams, type SetAccountHandler, type SetAccountJsonRpcProcedure, type SetAccountJsonRpcRequest, type SetAccountParams, type SetAccountResult, type StateOverrideSet, type StructLog, type TevmCallError, type TevmContractError, type TevmDeployError, type TevmDumpStateError, type TevmEvmError, type TevmGetAccountError, type TevmJsonRpcBulkRequestHandler, type TevmJsonRpcRequest, type TevmJsonRpcRequestHandler, type TevmLoadStateError, type TevmMineError, type TevmRequestType, type TevmReturnType, type TevmSetAccountError, type TraceCall, type TraceParams, type TraceResult, type TraceType, type TransactionParams, type TransactionReceiptResult, type TransactionResult, type ValidateCallParamsError, type ValidateContractParamsError, type ValidateGetAccountParamsError, type ValidateLoadStateParamsError, type ValidateMineParamsError, type ValidateSetAccountParamsError, anvilDealJsonRpcProcedure, anvilDropTransactionJsonRpcProcedure, anvilDumpStateJsonRpcProcedure, anvilGetAutomineJsonRpcProcedure, anvilImpersonateAccountJsonRpcProcedure, anvilLoadStateJsonRpcProcedure, anvilResetJsonRpcProcedure, anvilSetBalanceJsonRpcProcedure, anvilSetChainIdJsonRpcProcedure, anvilSetCodeJsonRpcProcedure, anvilSetCoinbaseJsonRpcProcedure, anvilSetNonceJsonRpcProcedure, anvilSetStorageAtJsonRpcProcedure, anvilStopImpersonatingAccountJsonRpcProcedure, blockNumberHandler, blockNumberProcedure, callHandler, callHandlerOpts, callHandlerResult, callProcedure, chainIdHandler, chainIdProcedure, cloneVmWithBlockTag, contractHandler, dealHandler, debugTraceBlockJsonRpcProcedure, debugTraceCallJsonRpcProcedure, debugTraceStateFilters, debugTraceStateJsonRpcProcedure, debugTraceTransactionJsonRpcProcedure, deployHandler, dumpStateHandler, dumpStateProcedure, ethAccountsHandler, ethAccountsProcedure, ethBlobBaseFeeJsonRpcProcedure, ethCallHandler, ethCallProcedure, ethCoinbaseJsonRpcProcedure, ethCreateAccessListProcedure, ethEstimateGasJsonRpcProcedure, ethGetBlockByHashJsonRpcProcedure, ethGetBlockByNumberJsonRpcProcedure, ethGetBlockTransactionCountByHashJsonRpcProcedure, ethGetBlockTransactionCountByNumberJsonRpcProcedure, ethGetFilterChangesProcedure, ethGetFilterLogsProcedure, ethGetLogsHandler, ethGetLogsProcedure, ethGetTransactionByBlockHashAndIndexJsonRpcProcedure, ethGetTransactionByBlockNumberAndIndexJsonRpcProcedure, ethGetTransactionByHashJsonRpcProcedure, ethGetTransactionCountProcedure, ethGetTransactionReceiptHandler, ethGetTransactionReceiptJsonRpcProcedure, ethNewBlockFilterProcedure, ethNewFilterHandler, ethNewFilterJsonRpcProcedure, ethNewPendingTransactionFilterProcedure, ethProtocolVersionJsonRpcProcedure, ethSendRawTransactionHandler, ethSendRawTransactionJsonRpcProcedure, ethSendTransactionHandler, ethSendTransactionJsonRpcProcedure, ethSignHandler, ethSignProcedure, ethSignTransactionHandler, ethSignTransactionProcedure, ethUninstallFilterJsonRpcProcedure, executeCall, forkAndCacheBlock, gasPriceHandler, gasPriceProcedure, getAccountHandler, getAccountProcedure, getBalanceHandler, getBalanceProcedure, getCodeHandler, getCodeProcedure, getStorageAtHandler, getStorageAtProcedure, handleAutomining, handlePendingTransactionsWarning, handleRunTxError, handleTransactionCreation, loadStateHandler, loadStateProcedure, mineHandler, mineProcedure, requestBulkProcedure, requestProcedure, setAccountHandler, setAccountProcedure, shouldAddToBlockchain, shouldCreateTransaction, traceCallHandler, validateBaseCallParams, validateCallParams, validateContractParams, validateGetAccountParams, validateLoadStateParams, validateMineEvents, validateMineParams, validateSetAccountParams, zAbi, zAddress, zBaseCallParams, zBlock, zBlockOverrideSet, zBlockParam, zBytecode, zCallParams, zContractParams, zGetAccountParams, zHex, zLoadStateParams, zMineParams, zSetAccountParams, zStateOverrideSet, zStorageRoot };
