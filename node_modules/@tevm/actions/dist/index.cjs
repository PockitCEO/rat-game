'use strict';

var contract = require('@tevm/contract');
var utils = require('@tevm/utils');
var viem = require('viem');
var address = require('@tevm/address');
var errors = require('@tevm/errors');
var node = require('@tevm/node');
var tx = require('@tevm/tx');
var vm = require('@tevm/vm');
var blockchain = require('@tevm/blockchain');
var state = require('@tevm/state');
var zod = require('zod');
var evm = require('@tevm/evm');
var zod$1 = require('abitype/zod');
var receiptManager = require('@tevm/receipt-manager');
var block = require('@tevm/block');
var jsonrpc = require('@tevm/jsonrpc');

// src/anvil/anvilDealHandler.js
var forkAndCacheBlock = async (client, block, executeBlock = false) => {
  client.logger.debug("Forking a new block based on block tag...");
  const vm = await client.getVm().then((vm2) => vm2.deepCopy());
  if (!client.forkTransport) {
    throw new errors.InternalError("Cannot forkAndCacheBlock without a fork url");
  }
  vm.stateManager = state.createStateManager({
    ...vm.evm.stateManager._baseState.options,
    fork: {
      transport: client.forkTransport,
      blockTag: block.header.number
    }
  });
  vm.evm.stateManager = vm.stateManager;
  vm.blockchain = await blockchain.createChain({
    fork: {
      transport: client.forkTransport,
      blockTag: block.header.number
    },
    common: vm.common,
    // TODO silent not being in this type is a bug
    loggingLevel: (
      /** @type {any}*/
      client.logger.level
    )
  });
  vm.evm.blockchain = vm.blockchain;
  await Promise.all([vm.stateManager.ready(), vm.blockchain.ready()]);
  if (executeBlock) {
    const transactions = (
      /** @type {import('@tevm/block').Block}*/
      block.transactions
    );
    client.logger.debug({ count: transactions.length }, "Processing transactions");
    await Promise.all(
      transactions.map(async (tx, i) => {
        client.logger.debug({ txNumber: i, tx }, "Processing transaction");
        await vm.evm.shallowCopy().runCall(tx);
      })
    );
    client.logger.debug("Finished processing block transactions and saving state root");
  }
  vm.stateManager.saveStateRoot(block.header.stateRoot, await vm.stateManager.dumpCanonicalGenesis());
  return vm;
};

// src/Call/cloneVmWithBlock.js
var cloneVmWithBlockTag = async (client, block) => {
  try {
    client.logger.debug("Preparing vm to execute a call with block...");
    const originalVm = await client.getVm();
    if (client.forkTransport && !await originalVm.stateManager.hasStateRoot(block.header.stateRoot)) {
      return await forkAndCacheBlock(client, block).catch((e) => {
        return new errors.ForkError(e instanceof Error ? e.message : "Unknown error", { cause: e });
      });
    }
    const vm = await originalVm.deepCopy();
    await vm.stateManager.setStateRoot(block.header.stateRoot);
    return vm;
  } catch (e) {
    return new errors.InternalError(e instanceof Error ? e.message : "unknown error", {
      cause: (
        /** @type {Error}*/
        e
      )
    });
  }
};

// src/internal/maybeThrowOnFail.js
var maybeThrowOnFail = (throwOnFail, result) => {
  if (!throwOnFail) {
    return (
      /** @type {any}*/
      result
    );
  }
  if ((result?.errors?.length ?? 0) === 1) {
    throw result.errors?.[0];
  }
  if ((result?.errors?.length ?? 0) > 1) {
    throw new AggregateError(result?.errors ?? []);
  }
  return (
    /** @type {any}*/
    result
  );
};
var callHandler = async (handler, data, secondParam) => {
  if (typeof handler === "function") {
    let hasCalledNext = false;
    const next = () => {
      hasCalledNext = true;
    };
    try {
      let result;
      if (secondParam !== void 0) {
        result = handler(data, secondParam, next);
      } else {
        result = handler(data, next);
      }
      if (result instanceof Promise) {
        await result;
      }
      if (!hasCalledNext) {
      }
    } catch (error) {
      console.error("Error in event handler:", error);
    }
  }
};
var emitEvents = async (client, newBlocks, newReceipts, params = {}) => {
  const { onBlock, onReceipt, onLog } = params;
  for (const block of newBlocks) {
    client.emit("newBlock", block);
    await callHandler(onBlock, block);
    const blockHash = utils.bytesToHex(block.hash());
    const receipts = newReceipts.get(blockHash);
    if (!receipts) {
      throw new Error(
        `InternalError: Receipts not found for block hash ${blockHash} in mineHandler. This indicates a bug in tevm.`
      );
    }
    for (const receipt of receipts) {
      client.emit("newReceipt", receipt);
      await callHandler(onReceipt, receipt, blockHash);
      for (const log of receipt.logs) {
        client.emit("newLog", log);
        await callHandler(onLog, log, receipt);
      }
    }
  }
};
var zBaseParams = zod.z.object({
  throwOnFail: zod.z.boolean().optional().describe(
    "If true the action handler will throw errors rather than returning errors an the `errors` property. Defaults to true."
  )
}).describe("Properties shared across actions");

// src/Mine/zMineParams.js
var zMineParams = zBaseParams.extend({
  blockCount: zod.z.number().int().gte(0).optional(),
  interval: zod.z.number().int().gte(0).optional(),
  onBlock: zod.z.function().optional(),
  onReceipt: zod.z.function().optional(),
  onLog: zod.z.function().optional()
});

// src/Mine/validateMineParams.js
var validateMineParams = (action) => {
  const errors$1 = [];
  const parsedParams = zMineParams.safeParse(action);
  if (parsedParams.success === false) {
    const formattedErrors = parsedParams.error.format();
    formattedErrors._errors.forEach((error) => {
      errors$1.push(new errors.InvalidRequestError(error));
    });
    if (formattedErrors.blockCount) {
      formattedErrors.blockCount._errors.forEach((error) => {
        errors$1.push(new errors.InvalidAddressError(error));
      });
    }
    if (formattedErrors.interval) {
      formattedErrors.interval._errors.forEach((error) => {
        errors$1.push(new errors.InvalidNonceError(error));
      });
    }
    if (formattedErrors.throwOnFail) {
      formattedErrors.throwOnFail._errors.forEach((error) => {
        errors$1.push(new errors.InvalidBalanceError(error));
      });
    }
  }
  return errors$1;
};

// src/Mine/mineHandler.js
var mineHandler = (client, options = {}) => async ({ throwOnFail = options.throwOnFail ?? true, tx, ...params } = {}) => {
  switch (client.status) {
    case "MINING": {
      const err = new errors.MisconfiguredClientError("Mining is already in progress");
      return maybeThrowOnFail(throwOnFail, { errors: [err] });
    }
    case "INITIALIZING": {
      await client.ready();
      client.status = "MINING";
      break;
    }
    case "SYNCING": {
      const err = new errors.MisconfiguredClientError("Syncing not currently implemented");
      return maybeThrowOnFail(throwOnFail, { errors: [err] });
    }
    case "STOPPED": {
      const err = new errors.MisconfiguredClientError("Client is stopped");
      return maybeThrowOnFail(throwOnFail, { errors: [err] });
    }
    case "READY": {
      client.status = "MINING";
      break;
    }
    default: {
      const err = new errors.UnreachableCodeError(client.status);
      return maybeThrowOnFail(throwOnFail, { errors: [err] });
    }
  }
  try {
    client.logger.debug({ throwOnFail, ...params }, "mineHandler called with params");
    const errors$1 = validateMineParams(params);
    if (errors$1.length > 0) {
      return maybeThrowOnFail(throwOnFail, { errors: errors$1 });
    }
    const { interval = 1, blockCount = 1 } = params;
    const newBlocks = [];
    const newReceipts = /* @__PURE__ */ new Map();
    client.logger.debug({ blockCount }, "processing txs");
    const pool = await client.getTxPool();
    const originalVm = await client.getVm();
    const vm = await originalVm.deepCopy();
    const receiptsManager = await client.getReceiptsManager();
    for (let count = 0; count < blockCount; count++) {
      const parentBlock = await vm.blockchain.getCanonicalHeadBlock();
      let timestamp = Math.max(Math.floor(Date.now() / 1e3), Number(parentBlock.header.timestamp));
      timestamp = count === 0 ? timestamp : timestamp + interval;
      const blockBuilder = await vm.buildBlock({
        parentBlock,
        headerData: {
          timestamp,
          number: parentBlock.header.number + 1n,
          // The following 2 are currently not supported
          // difficulty: undefined,
          // coinbase,
          gasLimit: parentBlock.header.gasLimit,
          baseFeePerGas: parentBlock.header.calcNextBaseFee()
        },
        blockOpts: {
          // Proof of authority not currently supported
          // cliqueSigner,
          // proof of work not currently supported
          //calcDifficultyFromHeader,
          //ck
          freeze: false,
          setHardfork: false,
          putBlockIntoBlockchain: false,
          common: vm.common
        }
      });
      const orderedTx = tx !== void 0 ? [
        (() => {
          const mempoolTx = pool.getByHash(tx);
          pool.removeByHash(tx);
          return mempoolTx;
        })()
      ] : await pool.txsByPriceAndNonce({
        baseFee: parentBlock.header.calcNextBaseFee()
      });
      let index = 0;
      const blockFull = false;
      const receipts = [];
      while (index < orderedTx.length && !blockFull) {
        const nextTx = (
          /** @type {import('@tevm/tx').TypedTransaction}*/
          orderedTx[index]
        );
        client.logger.debug({ hash: utils.bytesToHex(nextTx.hash()) }, "new tx added");
        const txResult = await blockBuilder.addTransaction(nextTx, {
          skipBalance: true,
          skipNonce: true,
          skipHardForkValidation: true
        });
        receipts.push(txResult.receipt);
        index++;
      }
      await vm.stateManager.checkpoint();
      const createNewStateRoot = true;
      await vm.stateManager.commit(createNewStateRoot);
      const block = await blockBuilder.build();
      await Promise.all([receiptsManager.saveReceipts(block, receipts), vm.blockchain.putBlock(block)]);
      pool.removeNewBlockTxs([block]);
      newBlocks.push(block);
      newReceipts.set(utils.bytesToHex(block.hash()), receipts);
      const value = vm.stateManager._baseState.stateRoots.get(utils.bytesToHex(block.header.stateRoot));
      if (!value) {
        return maybeThrowOnFail(throwOnFail, {
          errors: [
            new errors.InternalError(
              "InternalError: State root not found in mineHandler. This indicates a potential inconsistency in state management."
            )
          ]
        });
      }
      originalVm.stateManager.saveStateRoot(block.header.stateRoot, value);
    }
    originalVm.blockchain = vm.blockchain;
    originalVm.evm.blockchain = vm.evm.blockchain;
    receiptsManager.chain = vm.evm.blockchain;
    await originalVm.stateManager.setStateRoot(utils.hexToBytes(vm.stateManager._baseState.getCurrentStateRoot()));
    await emitEvents(client, newBlocks, newReceipts, params);
    return { blockHashes: newBlocks.map((b) => utils.bytesToHex(b.hash())) };
  } catch (e) {
    return maybeThrowOnFail(throwOnFail, {
      errors: [new errors.InternalError(
        /** @type {Error} */
        e.message,
        { cause: e }
      )]
    });
  } finally {
    client.status = "READY";
  }
};

// src/internal/getPendingClient.js
var getPendingClient = async (client) => {
  const pendingClient = await client.deepCopy();
  const txPool = await pendingClient.getTxPool();
  const blockHashes = [];
  while (txPool.txsInPool > 0) {
    const { errors, blockHashes: newBlockHashes } = await mineHandler(pendingClient)({ throwOnFail: false });
    if (errors !== void 0) {
      return { errors };
    }
    blockHashes.push(...newBlockHashes);
  }
  return { pendingClient, blockHashes };
};
var zAddress = zod.z.string().transform((val, ctx) => {
  const regex = /^0x[a-fA-F0-9]{40}$/;
  if (!regex.test(val)) {
    ctx.addIssue({
      code: "custom",
      message: `Invalid Address ${val}`
    });
  }
  return val;
}).describe("A valid ethereum address");
var hexRegex = /^0x[0-9a-fA-F]*$/;
var zHex = zod.z.string().transform((value, ctx) => {
  if (!hexRegex.test(value)) {
    ctx.addIssue({
      code: zod.z.ZodIssueCode.custom,
      message: "value must be a hex string"
    });
  }
  return (
    /** @type {import('@tevm/utils').Hex}*/
    value
  );
}).describe("A hex string");

// src/internal/zod/zBlockParam.js
var zBlockParam = zod.z.union([
  zod.z.literal("latest"),
  zod.z.literal("earliest"),
  zod.z.literal("pending"),
  zod.z.literal("safe"),
  zod.z.literal("finalized"),
  zod.z.bigint(),
  zod.z.number().transform((n) => BigInt(n)),
  // Add number support with transformation
  zHex
]);

// src/GetAccount/zGetAccountParams.js
var zGetAccountParams = zBaseParams.extend({
  address: zAddress,
  blockTag: zBlockParam.optional().describe('Block tag to execute call on. defaults to "latest"'),
  returnStorage: zod.z.boolean().optional().describe("If true will return storage. Defaults to false. This can be expensive")
}).describe("Params to create an account or contract");

// src/GetAccount/validateGetAccountParams.js
var validateGetAccountParams = (action) => {
  const errors$1 = [];
  const parsedParams = zGetAccountParams.safeParse(action);
  if (parsedParams.success === false) {
    const formattedErrors = parsedParams.error.format();
    if (formattedErrors.throwOnFail) {
      for (const err of formattedErrors.throwOnFail._errors) {
        errors$1.push(
          new errors.InvalidRequestError(`Invalid throwOnFail param. throwOnFail must be a boolean or not provided. ${err}`)
        );
      }
    }
    if (formattedErrors.returnStorage) {
      for (const err of formattedErrors.returnStorage._errors) {
        errors$1.push(
          new errors.InvalidRequestError(
            `Invalid returnStorage param. returnStorage must be a boolean or not provided. ${err}`
          )
        );
      }
    }
    if (formattedErrors.address) {
      for (const err of formattedErrors.address._errors) {
        errors$1.push(new errors.InvalidAddressError(`Invalid address param. ${err}`));
      }
    }
    if (formattedErrors.blockTag) {
      for (const err of formattedErrors.blockTag._errors) {
        errors$1.push(new errors.InvalidRequestError(`Invalid blockTag param. ${err}`));
      }
    }
    formattedErrors._errors.forEach((error) => {
      errors$1.push(new errors.InvalidRequestError(error));
    });
  }
  return errors$1;
};

// src/GetAccount/getAccountHandler.js
var getAccountHandler = (client, options = {}) => async ({ throwOnFail = options.throwOnFail ?? true, ...params }) => {
  const vm = await client.getVm();
  const errors$1 = validateGetAccountParams(params);
  if (errors$1.length > 0) {
    return maybeThrowOnFail(throwOnFail, {
      errors: errors$1,
      address: params.address,
      balance: 0n,
      /**
       * @type {`0x${string}`}
       */
      storageRoot: "0x",
      nonce: 0n,
      /**
       * @type {`0x${string}`}
       */
      deployedBytecode: "0x",
      /**
       * @type {`0x${string}`}
       */
      codeHash: "0x",
      isContract: false,
      isEmpty: true
    });
  }
  const address$1 = address.createAddress(params.address);
  try {
    if (params.blockTag === "pending") {
      const mineResult = await getPendingClient(client);
      if (mineResult.errors) {
        return maybeThrowOnFail(throwOnFail, {
          errors: mineResult.errors,
          address: params.address,
          balance: 0n,
          /**
           * @type {`0x${string}`}
           */
          storageRoot: "0x",
          nonce: 0n,
          /**
           * @type {`0x${string}`}
           */
          deployedBytecode: "0x",
          /**
           * @type {`0x${string}`}
           */
          codeHash: "0x",
          isContract: false,
          isEmpty: true
        });
      }
      return getAccountHandler(mineResult.pendingClient, options)({ throwOnFail, ...params, blockTag: "latest" });
    }
    if (params.blockTag !== "latest" && params.blockTag !== void 0) {
      const block = await vm.blockchain.getBlockByTag(params.blockTag);
      const clonedVm = await cloneVmWithBlockTag(client, block);
      if (clonedVm instanceof errors.ForkError || clonedVm instanceof errors.InternalError) {
        return maybeThrowOnFail(throwOnFail, {
          errors: [clonedVm],
          address: params.address,
          balance: 0n,
          /**
           * @type {`0x${string}`}
           */
          storageRoot: "0x",
          nonce: 0n,
          /**
           * @type {`0x${string}`}
           */
          deployedBytecode: "0x",
          /**
           * @type {`0x${string}`}
           */
          codeHash: "0x",
          isContract: false,
          isEmpty: true
        });
      }
      return getAccountHandler(
        { ...client, getVm: () => Promise.resolve(clonedVm) },
        options
      )({ throwOnFail, ...params, blockTag: "latest" });
    }
    const res = await vm.stateManager.getAccount(address$1);
    if (!res) {
      return maybeThrowOnFail(throwOnFail, {
        address: params.address,
        balance: 0n,
        /**
         * @type {`0x${string}`}
         */
        storageRoot: "0x",
        nonce: 0n,
        /**
         * @type {`0x${string}`}
         */
        deployedBytecode: "0x",
        errors: [new errors.AccountNotFoundError(`account ${params.address} not found`)],
        /**
         * @type {`0x${string}`}
         */
        codeHash: "0x",
        isContract: false,
        isEmpty: true
      });
    }
    const code = res?.codeHash !== void 0 ? utils.bytesToHex(await vm.stateManager.getCode(address$1)) : "0x";
    return {
      // TODO some of these fields are not in the api and should be added to @tevm/actions
      address: params.address,
      balance: res.balance,
      codeHash: utils.bytesToHex(res.codeHash),
      isContract: res.isContract(),
      isEmpty: res.isEmpty(),
      deployedBytecode: code,
      nonce: res.nonce,
      storageRoot: utils.bytesToHex(res.storageRoot),
      ...params.returnStorage ? {
        storage: Object.fromEntries(
          Object.entries(await vm.stateManager.dumpStorage(address$1)).map(([key, value]) => [
            `0x${key}`,
            /** @type {import('../common/Hex.js').Hex}*/
            value
          ])
        )
      } : {}
    };
  } catch (e) {
    let err = e;
    if (typeof e !== "object" || e === null || !("_tag" in e)) {
      err = new errors.InternalError("UnexpectedError in getAccountHandler", { cause: (
        /** @type {any}*/
        e
      ) });
    }
    errors$1.push(
      /** @type any*/
      err
    );
    return maybeThrowOnFail(throwOnFail, {
      errors: errors$1,
      address: params.address,
      balance: 0n,
      /**
       * @type {`0x${string}`}
       */
      storageRoot: "0x",
      /**
       * @type {`0x${string}`}
       */
      codeHash: "0x",
      nonce: 0n,
      /**
       * @type {`0x${string}`}
       */
      deployedBytecode: "0x",
      isContract: false,
      isEmpty: true
    });
  }
};

// src/internal/zod/zBytecode.js
var isValidEthereumBytecode = (bytecode) => {
  const rawBytecode = bytecode.slice(2);
  if (rawBytecode.length === 0 || rawBytecode.length % 2 !== 0) {
    return false;
  }
  return true;
};
var zBytecode = zHex.refine(isValidEthereumBytecode, { message: "InvalidLength" }).describe("Valid bytecode");
var storageRootRegex = /^0x[0-9a-fA-F]{64}$/;
var zStorageRoot = zod.z.string().transform((value, ctx) => {
  if (!storageRootRegex.test(value)) {
    ctx.addIssue({
      code: zod.z.ZodIssueCode.custom,
      message: "Value must be a 32-byte hex string (64 hex characters with a 0x prefix)"
    });
  }
  return value;
}).describe("Valid ethereum storage root");

// src/SetAccount/zSetAccountParams.js
var zSetAccountParams = zBaseParams.extend({
  address: zAddress.describe("The ethereum address of the account"),
  balance: zod.z.bigint().nonnegative().optional().describe("The balance to give the account"),
  nonce: zod.z.bigint().nonnegative().optional().describe("The nonce to give the account"),
  deployedBytecode: zBytecode.optional().describe("The contract bytecode to set at the account address as a >0 byte hex string"),
  storageRoot: zStorageRoot.optional().describe("The storage root to set at the account address as a 32 byte hex strign"),
  state: zod.z.record(zHex, zHex).optional().describe("Overrides entire state with provided state"),
  stateDiff: zod.z.record(zHex, zHex).optional().describe("Patches the state with the provided state")
}).refine(
  (data) => {
    if (data.state && data.stateDiff) {
      return false;
    }
    return true;
  },
  { message: "Cannot have both state and stateDiff" }
).describe("Params to create an account or contract");

// src/SetAccount/validateSetAccountParams.js
var validateSetAccountParams = (action) => {
  const errors$1 = [];
  const parsedParams = zSetAccountParams.safeParse(action);
  if (parsedParams.success === false) {
    const formattedErrors = parsedParams.error.format();
    formattedErrors._errors.forEach((error) => {
      errors$1.push(new errors.InvalidRequestError(error));
    });
    if (formattedErrors.address) {
      formattedErrors.address._errors.forEach((error) => {
        errors$1.push(new errors.InvalidAddressError(error));
      });
    }
    if (formattedErrors.nonce) {
      formattedErrors.nonce._errors.forEach((error) => {
        errors$1.push(new errors.InvalidNonceError(error));
      });
    }
    if (formattedErrors.balance) {
      formattedErrors.balance._errors.forEach((error) => {
        errors$1.push(new errors.InvalidBalanceError(error));
      });
    }
    if (formattedErrors.deployedBytecode) {
      formattedErrors.deployedBytecode._errors.forEach((error) => {
        errors$1.push(new errors.InvalidDeployedBytecodeError(error));
      });
    }
    if (formattedErrors.storageRoot) {
      formattedErrors.storageRoot._errors.forEach((error) => {
        errors$1.push(new errors.InvalidStorageRootError(error));
      });
    }
    if (formattedErrors.state) {
      formattedErrors.state._errors.forEach((error) => {
        errors$1.push(new errors.InvalidRequestError(error));
      });
    }
    if (formattedErrors.stateDiff) {
      formattedErrors.stateDiff._errors.forEach((error) => {
        errors$1.push(new errors.InvalidRequestError(error));
      });
    }
    if (formattedErrors.throwOnFail) {
      formattedErrors.throwOnFail._errors.forEach((error) => {
        errors$1.push(new errors.InvalidRequestError(error));
      });
    }
  }
  return errors$1;
};

// src/SetAccount/setAccountHandler.js
var setAccountHandler = (client, options = {}) => async (params) => {
  const { throwOnFail = options.throwOnFail ?? true } = params;
  const errors$1 = validateSetAccountParams(params);
  if (errors$1.length > 0) {
    return maybeThrowOnFail(throwOnFail, { errors: errors$1 });
  }
  const address$1 = address.createAddress(params.address);
  const promises = [];
  try {
    const vm = await client.getVm();
    const account = await getAccountHandler(client)({ ...params, throwOnFail: false });
    if (account.errors?.length && !(account.errors[0] instanceof errors.AccountNotFoundError)) {
      client.logger.error({ errors: account.errors }, "there was an unexpected error getting account");
      throw account.errors.length > 1 ? new AggregateError(account.errors) : account.errors[0];
    }
    const accountData = {
      nonce: params.nonce ?? account?.nonce,
      balance: params.balance ?? account?.balance
    };
    const storageRoot = (params.storageRoot && utils.hexToBytes(params.storageRoot)) ?? (account?.storageRoot !== void 0 && account?.storageRoot !== "0x" ? utils.hexToBytes(account.storageRoot) : void 0);
    const codeHash = (params.deployedBytecode && utils.hexToBytes(utils.keccak256(params.deployedBytecode))) ?? (account?.deployedBytecode !== void 0 ? utils.hexToBytes(utils.keccak256(account.deployedBytecode)) : void 0);
    if (storageRoot !== void 0) {
      accountData.storageRoot = storageRoot;
    }
    if (codeHash !== void 0) {
      accountData.codeHash = codeHash;
    }
    promises.push(vm.stateManager.putAccount(address$1, utils.createAccount(accountData)));
    if (params.deployedBytecode) {
      promises.push(vm.stateManager.putCode(address$1, utils.hexToBytes(params.deployedBytecode)));
    }
    if (params.state) {
      await vm.stateManager.clearStorage(address$1);
    }
    const state = params.state ?? params.stateDiff;
    if (state) {
      for (const [key, value] of Object.entries(state)) {
        promises.push(
          vm.stateManager.putStorage(
            address$1,
            utils.hexToBytes(
              /** @type {import('@tevm/utils').Hex}*/
              key,
              { size: 32 }
            ),
            utils.hexToBytes(value)
          )
        );
      }
    }
    const results = await Promise.allSettled(promises);
    for (const result of results) {
      if (result.status === "rejected") {
        errors$1.push(new errors.InternalError("Unable to put storage", { cause: result.reason }));
      }
    }
    if (errors$1.length > 0) {
      return maybeThrowOnFail(throwOnFail, { errors: errors$1 });
    }
    await vm.stateManager.checkpoint();
    await vm.stateManager.commit(false);
    return {};
  } catch (e) {
    errors$1.push(new errors.InternalError("Unexpected error setting account", { cause: e }));
    return maybeThrowOnFail(throwOnFail, { errors: errors$1 });
  }
};

// src/Contract/createScript.js
var createScript = async (client, code, deployedBytecode, to) => {
  const scriptAddress = to ?? (() => {
    const randomBigInt = BigInt(Math.floor(Math.random() * 1e15));
    return utils.getAddress(address.createContractAddress(address.createAddress(`0x${"6969".repeat(10)}`), randomBigInt).toString());
  })();
  const vm$1 = await client.getVm();
  if (deployedBytecode) {
    const setAccountRes = await setAccountHandler(client)({
      address: scriptAddress,
      deployedBytecode,
      throwOnFail: false
    });
    if (setAccountRes.errors) {
      return {
        errors: setAccountRes.errors
      };
    }
    return {
      address: scriptAddress
    };
  }
  if (!code) {
    return {
      errors: [new errors.InternalError("Cannot create script without code or deployedBytecode")]
    };
  }
  const parentBlock = await vm$1.blockchain.getCanonicalHeadBlock();
  const priorityFee = 0n;
  const sender = address.createAddress(
    /** @type {import('@tevm/utils').Address}*/
    node.prefundedAccounts[0]
  );
  let _maxFeePerGas = parentBlock.header.calcNextBaseFee() + priorityFee;
  const baseFeePerGas = parentBlock.header.baseFeePerGas ?? 0n;
  if (_maxFeePerGas < baseFeePerGas) {
    _maxFeePerGas = baseFeePerGas;
  }
  const dataFee = (() => {
    let out = 0n;
    for (const entry of utils.hexToBytes(code) ?? []) {
      out += entry === 0 ? 4n : 16n;
    }
    return out;
  })();
  const baseFee = (() => {
    let out = dataFee;
    const txFee = 21000n;
    out += txFee;
    if (vm$1.common.ethjsCommon.gteHardfork("homestead")) {
      const txCreationFee = 32000n;
      out += txCreationFee;
    }
    return out;
  })();
  const minimumGasLimit = baseFee + BigInt(4294967295);
  const gasLimitWithExecutionBuffer = minimumGasLimit * 11n / 10n;
  try {
    const res = await vm.runTx(vm$1)({
      block: parentBlock,
      tx: tx.createImpersonatedTx({
        maxFeePerGas: _maxFeePerGas,
        maxPriorityFeePerGas: 0n,
        gasLimit: gasLimitWithExecutionBuffer,
        data: code,
        impersonatedAddress: sender
      }),
      skipNonce: true,
      skipBalance: true,
      skipBlockGasLimitValidation: true,
      skipHardForkValidation: true
    });
    if (res.execResult.exceptionError?.error) {
      client.logger.error("Failed to create script because deployment of script bytecode failed");
      throw new errors.InvalidBytecodeError(res.execResult.exceptionError.error, {
        cause: (
          /** @type {any}*/
          res.execResult.exceptionError
        )
      });
    }
    const deployedAddress = res.createdAddress;
    if (!deployedAddress) {
      return {
        errors: [new errors.InternalEvmError("Failed to create script")]
      };
    }
    const account = await getAccountHandler(client)({
      throwOnFail: false,
      address: (
        /** @type {import('@tevm/utils').Address}*/
        deployedAddress.toString()
      ),
      returnStorage: true
    });
    if (account.errors) {
      return {
        errors: account.errors
      };
    }
    const setAccountRes = await setAccountHandler(client)({
      ...account,
      address: scriptAddress,
      throwOnFail: false,
      stateDiff: account.storage ?? {},
      deployedBytecode: account.deployedBytecode
    });
    if (setAccountRes.errors) {
      return {
        errors: setAccountRes.errors
      };
    }
    await vm$1.stateManager.deleteAccount(deployedAddress);
    return {
      address: to ?? scriptAddress
    };
  } catch (e) {
    return {
      errors: [
        /** @type any*/
        e
      ]
    };
  }
};
var abi = utils.parseAbi([
  "function getL1GasUsed(bytes memory _data) public view returns (uint256)",
  "function getL1Fee(bytes memory _data) external view returns (uint256)",
  "function l1BaseFee() public view returns (uint256)",
  "function blobBaseFee() public view returns (uint256)"
]);
var getL1FeeInformationOpStack = async (data, vm) => {
  const opstackChain = (
    /** @type {any}*/
    vm.common
  );
  const serializedTx = utils.serializeTransaction({
    chainId: opstackChain.id,
    data: utils.bytesToHex(data ?? new Uint8Array()),
    type: "eip1559"
  });
  const to = address.createAddress(opstackChain.contracts.gasPriceOracle.address);
  const [l1GasUsed, l1Fee, l1BlobFee, l1BaseFee] = await Promise.all([
    vm.evm.runCall({
      to,
      data: utils.hexToBytes(
        viem.encodeFunctionData({
          functionName: "getL1GasUsed",
          args: [serializedTx],
          abi
        })
      )
    }),
    vm.evm.runCall({
      to,
      data: utils.hexToBytes(
        viem.encodeFunctionData({
          functionName: "getL1Fee",
          args: [serializedTx],
          abi
        })
      )
    }),
    vm.evm.runCall({
      to,
      data: utils.hexToBytes(
        viem.encodeFunctionData({
          functionName: "blobBaseFee",
          args: [],
          abi
        })
      )
    }),
    vm.evm.runCall({
      to,
      data: utils.hexToBytes(
        viem.encodeFunctionData({
          functionName: "l1BaseFee",
          args: [],
          abi
        })
      )
    })
  ]);
  return {
    l1GasUsed: viem.decodeFunctionResult({
      abi,
      functionName: "getL1GasUsed",
      data: utils.bytesToHex(l1GasUsed.execResult.returnValue)
    }),
    l1Fee: viem.decodeFunctionResult({
      abi,
      functionName: "getL1Fee",
      data: utils.bytesToHex(l1Fee.execResult.returnValue)
    }),
    l1BlobFee: viem.decodeFunctionResult({
      abi,
      functionName: "blobBaseFee",
      data: utils.bytesToHex(l1BlobFee.execResult.returnValue)
    }),
    l1BaseFee: viem.decodeFunctionResult({
      abi,
      functionName: "l1BaseFee",
      data: utils.bytesToHex(l1BaseFee.execResult.returnValue)
    })
  };
};
var callHandlerOpts = async (client, params) => {
  const opts = {};
  const vm = await client.getVm();
  const block = await (async () => {
    try {
      if (params.blockTag === void 0) {
        return vm.blockchain.blocksByTag.get("latest");
      }
      if (typeof params.blockTag === "bigint") {
        return await vm.blockchain.getBlock(params.blockTag);
      }
      if (typeof params.blockTag === "string" && params.blockTag.startsWith("0x")) {
        return await vm.blockchain.getBlock(utils.hexToBytes(
          /** @type {import('@tevm/utils').Hex}*/
          params.blockTag
        ));
      }
      if (params.blockTag === "latest" || params.blockTag === "safe" || params.blockTag === "pending" || params.blockTag === "earliest" || params.blockTag === "finalized") {
        return vm.blockchain.blocksByTag.get(
          /** */
          params.blockTag
        );
      }
      return new errors.InvalidBlockError(`Unknown blocktag ${params.blockTag}`);
    } catch (e) {
      return new errors.UnknownBlockError(e instanceof Error ? e.message : `Unable to find block ${params.blockTag}`);
    }
  })();
  if (block instanceof errors.UnknownBlockError || block instanceof errors.InvalidBlockError || block === void 0) {
    return { errors: [block ?? new errors.UnknownBlockError(`Unable to find block ${params.blockTag}`)] };
  }
  client.logger.debug({ block: block.header }, "Using block");
  opts.block = block;
  if (params.blockOverrideSet) {
    client.logger.debug(params.blockOverrideSet, "callHandlerOpts: Detected a block override set");
    const { header } = await vm.blockchain.getCanonicalHeadBlock();
    opts.block = {
      ...opts.block,
      header: {
        // this isn't in the type but it needs to be here or else block overrides will fail
        ...{ stateRoot: block.header.stateRoot },
        coinbase: params.blockOverrideSet.coinbase !== void 0 ? address.createAddress(params.blockOverrideSet.coinbase) : header.coinbase,
        number: params.blockOverrideSet.number !== void 0 ? BigInt(params.blockOverrideSet.number) : header.number,
        difficulty: header.difficulty,
        prevRandao: header.prevRandao,
        gasLimit: params.blockOverrideSet.gasLimit !== void 0 ? BigInt(params.blockOverrideSet.gasLimit) : header.gasLimit,
        timestamp: params.blockOverrideSet.time !== void 0 ? BigInt(params.blockOverrideSet.time) : header.timestamp,
        baseFeePerGas: params.blockOverrideSet.baseFee !== void 0 ? BigInt(params.blockOverrideSet.baseFee) : header.baseFeePerGas ?? BigInt(0),
        getBlobGasPrice() {
          if (params.blockOverrideSet?.blobBaseFee !== void 0) {
            return BigInt(params.blockOverrideSet.blobBaseFee);
          }
          return header.getBlobGasPrice();
        }
      }
    };
  }
  if (params.to) {
    opts.to = address.createAddress(params.to);
  }
  if (params.data) {
    opts.data = utils.hexToBytes(params.data);
  }
  if (params.salt) {
    opts.salt = utils.hexToBytes(params.salt);
  }
  if (params.depth) {
    opts.depth = params.depth;
  }
  if (params.blobVersionedHashes) {
    opts.blobVersionedHashes = params.blobVersionedHashes;
  }
  if (params.selfdestruct) {
    opts.selfdestruct = params.selfdestruct;
  }
  if (params.gasRefund) {
    opts.gasRefund = BigInt(params.gasRefund);
  }
  if (params.gasPrice) {
    opts.gasPrice = BigInt(params.gasPrice);
  }
  if (params.value) {
    opts.value = BigInt(params.value);
  }
  const caller = params.caller || params.from || params.origin || (params.createTransaction || params.addToMempool || params.addToBlockchain ? "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" : `0x${"00".repeat(20)}`);
  if (caller) {
    opts.caller = address.createAddress(caller);
  }
  const origin = params.origin || params.from || params.caller || (params.createTransaction || params.addToMempool || params.addToBlockchain ? "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266" : `0x${"00".repeat(20)}`);
  if (origin) {
    if (params.skipBalance !== void 0) {
      opts.skipBalance = Boolean(params.skipBalance);
    } else {
      opts.skipBalance = caller === `0x${"00".repeat(20)}` && (params.createTransaction ?? params.addToMempool ?? params.addToBlockchain ?? false) === false;
    }
    opts.origin = address.createAddress(origin);
  }
  if (params.gas) {
    opts.gasLimit = BigInt(params.gas);
  }
  if ((params.createTransaction || params.addToMempool || params.addToBlockchain) && opts.block !== await vm.blockchain.getCanonicalHeadBlock()) {
    return { errors: [new errors.InvalidParamsError("Creating transactions on past blocks is not currently supported")] };
  }
  return { data: opts };
};
var createEvmError = (error) => {
  if (error instanceof errors.BaseError) {
    return (
      /** @type {never}*/
      error
    );
  }
  const errorMessage = error?.error;
  switch (errorMessage) {
    case "stop": {
      return new errors.StopError(errorMessage, { cause: error });
    }
    case "revert": {
      return new errors.RevertError(errorMessage, { cause: error });
    }
    case "out of gas": {
      return new errors.OutOfGasError(errorMessage, { cause: error });
    }
    case "invalid opcode": {
      return new errors.InvalidOpcodeError(errorMessage, { cause: error });
    }
    case "stack overflow": {
      return new errors.StackOverflowError(errorMessage, { cause: error });
    }
    case "stack underflow": {
      return new errors.StackUnderflowError(errorMessage, { cause: error });
    }
    case "invalid JUMP": {
      return new errors.InvalidJumpError(errorMessage, { cause: error });
    }
    case "value out of range": {
      return new errors.OutOfRangeError(errorMessage, { cause: error });
    }
    case "kzg proof invalid": {
      return new errors.InvalidProofError(errorMessage, { cause: error });
    }
    // @ts-expect-error - This error message is deprecated in ethereumjs v10
    case "attempting to AUTHCALL without AUTH set": {
      return new errors.AuthCallUnsetError(errorMessage, { cause: error });
    }
    case "internal error": {
      return new errors.InternalError(errorMessage, { cause: error });
    }
    case "kzg inputs invalid": {
      return new errors.InvalidKzgInputsError(errorMessage, { cause: error });
    }
    case "value overflow": {
      return new errors.ValueOverflowError(errorMessage, { cause: error });
    }
    // @ts-expect-error - This error message is deprecated in ethereumjs v10
    case "invalid JUMPSUB": {
      return new errors.InvalidJumpSubError(errorMessage, { cause: error });
    }
    case "create collision": {
      return new errors.CreateCollisionError(errorMessage, { cause: error });
    }
    // @ts-expect-error - This error message is deprecated in ethereumjs v10
    case "invalid BEGINSUB": {
      return new errors.InvalidBeginSubError(errorMessage, { cause: error });
    }
    case "refund exhausted": {
      return new errors.RefundExhaustedError(errorMessage, { cause: error });
    }
    // @ts-expect-error - This error message is deprecated in ethereumjs v10
    case "invalid RETURNSUB": {
      return new errors.InvalidReturnSubError(errorMessage, { cause: error });
    }
    case "kzg commitment does not match versioned hash": {
      return new errors.InvalidCommitmentError(errorMessage, { cause: error });
    }
    case "invalid EOF format": {
      return new errors.InvalidEofFormatError(errorMessage, { cause: error });
    }
    case "static state change": {
      return new errors.StaticStateChangeError(errorMessage, { cause: error });
    }
    case "code store out of gas": {
      return new errors.CodeStoreOutOfGasError(errorMessage, { cause: error });
    }
    case "insufficient balance": {
      return new errors.InsufficientBalanceError(errorMessage, { cause: error });
    }
    case "invalid input length": {
      return new errors.InvalidInputLengthError(errorMessage, { cause: error });
    }
    case "input is empty": {
      return new errors.BLS12381InputEmptyError(errorMessage, { cause: error });
    }
    case "initcode exceeds max initcode size": {
      return new errors.InitcodeSizeViolationError(errorMessage, { cause: error });
    }
    case "invalid bytecode deployed": {
      return new errors.InvalidBytecodeResultError(errorMessage, { cause: error });
    }
    case "code size to deposit exceeds maximum code size": {
      return new errors.CodeSizeExceedsMaximumError(errorMessage, { cause: error });
    }
    case "fp point not in field": {
      return new errors.BLS12381FpNotInFieldError(errorMessage, { cause: error });
    }
    case "point not on curve": {
      return new errors.BLS12381PointNotOnCurveError(errorMessage, { cause: error });
    }
    default: {
      return new errors.InternalError(errorMessage || "Unknown error", {
        cause: error
      });
    }
  }
};

// src/Call/callHandlerResult.js
var callHandlerResult = (evmResult, txHash, trace, accessList) => {
  const out = {
    rawData: utils.bytesToHex(
      /** @type {any} */
      evmResult.execResult.returnValue
    ),
    executionGasUsed: (
      /** @type {any} */
      evmResult.execResult.executionGasUsed
    )
  };
  if (trace) {
    out.trace = trace;
  }
  if (evmResult.totalGasSpent) {
    out.totalGasSpent = evmResult.totalGasSpent;
  }
  if (evmResult.minerValue) {
    out.minerValue = evmResult.minerValue;
  }
  if (evmResult.blobGasUsed) {
    out.blobGasUsed = evmResult.blobGasUsed;
  }
  if (evmResult.amountSpent) {
    out.amountSpent = evmResult.amountSpent;
  }
  if (accessList && evmResult.preimages) {
    out.preimages = Object.fromEntries(
      [...evmResult.preimages.entries()].map(([key, value]) => [key, utils.bytesToHex(value)])
    );
  }
  if (accessList) {
    out.accessList = /** @type {Record<import('@tevm/utils').Address, Set<import('@tevm/utils').Hex>>} */
    Object.fromEntries(
      [...accessList.entries()].map(([address, storageKeys]) => {
        const hexKeys = new Set([...storageKeys].map((key) => `0x${key}`));
        return [`0x${address}`, hexKeys];
      })
    );
  }
  if (txHash) {
    out.txHash = txHash;
  }
  if (
    /** @type {any} */
    evmResult.execResult.gasRefund
  ) {
    out.gasRefund = evmResult.gasRefund ?? /** @type {any} */
    evmResult.execResult.gasRefund;
  }
  if (
    /** @type {any} */
    evmResult.execResult.selfdestruct
  ) {
    out.selfdestruct = new Set(
      [.../** @type {any} */
      evmResult.execResult.selfdestruct].map((address) => utils.getAddress(address))
    );
  }
  if (
    /** @type {any} */
    evmResult.execResult.gas
  ) {
    out.gas = /** @type {any} */
    evmResult.execResult.gas;
  }
  if (
    /** @type {any} */
    evmResult.execResult.logs
  ) {
    out.logs = /** @type {any} */
    evmResult.execResult.logs.map(
      (log) => {
        const [address, topics, data] = log;
        return {
          address: utils.getAddress(utils.toHex(address)),
          topics: topics.map((topic) => utils.toHex(topic)),
          data: utils.toHex(data)
        };
      }
    );
  }
  if (
    /** @type {any} */
    evmResult.execResult.runState
  ) ;
  if (
    /** @type {any} */
    evmResult.execResult.blobGasUsed
  ) {
    out.blobGasUsed = /** @type {any} */
    evmResult.execResult.blobGasUsed;
  }
  if (
    /** @type {any} */
    evmResult.execResult.exceptionError
  ) {
    if (out.errors === void 0) {
      out.errors = [];
    }
    out.errors.push(createEvmError(
      /** @type {any} */
      evmResult.execResult.exceptionError
    ));
  }
  if (
    /** @type {any} */
    evmResult.execResult.createdAddresses
  ) {
    out.createdAddresses = new Set([.../** @type {any} */
    evmResult.execResult.createdAddresses].map(utils.getAddress));
  }
  if (
    /** @type {any} */
    evmResult.createdAddress
  ) {
    out.createdAddress = utils.getAddress(
      /** @type {any} */
      evmResult.createdAddress.toString()
    );
  }
  return out;
};
var evmInputToImpersonatedTx = (client) => {
  return async (evmInput, maxFeePerGas, maxPriorityFeePerGas) => {
    const vm = await client.getVm();
    const parentBlock = await vm.blockchain.getCanonicalHeadBlock();
    const priorityFee = 0n;
    const sender = evmInput.origin ?? evmInput.caller ?? address.createAddress(`0x${"00".repeat(20)}`);
    const txPool = await client.getTxPool();
    const txs = await txPool.getBySenderAddress(sender);
    const nonce = (await vm.stateManager.getAccount(sender) ?? { nonce: 0n }).nonce + BigInt(txs.length);
    client.logger.debug({ nonce, sender: sender.toString() }, "creating tx with nonce");
    let _maxFeePerGas = parentBlock.header.calcNextBaseFee() + priorityFee;
    const baseFeePerGas = parentBlock.header.baseFeePerGas ?? 0n;
    if (_maxFeePerGas < baseFeePerGas) {
      _maxFeePerGas = baseFeePerGas;
    }
    if (maxPriorityFeePerGas && _maxFeePerGas < maxPriorityFeePerGas) {
      _maxFeePerGas = maxPriorityFeePerGas;
    }
    return tx.createImpersonatedTx(
      {
        impersonatedAddress: sender,
        nonce,
        // just set to block max for now
        gasLimit: parentBlock.header.gasLimit,
        maxFeePerGas: maxFeePerGas ?? _maxFeePerGas,
        maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
        ...evmInput.to !== void 0 ? { to: evmInput.to } : {},
        ...evmInput.data !== void 0 ? { data: evmInput.data } : {},
        ...evmInput.value !== void 0 ? { value: evmInput.value } : {},
        gasPrice: null
      },
      {
        allowUnlimitedInitCodeSize: false,
        common: vm.common.ethjsCommon,
        // we don't want to freeze because there is a hack to set tx.hash when building a block
        freeze: false
      }
    );
  };
};
var runCallWithTrace = async (vm, logger, params, lazilyRun = false) => {
  const trace = {
    gas: 0n,
    returnValue: "0x0",
    failed: false,
    structLogs: []
  };
  vm.evm.events?.on("step", async (step, next) => {
    logger.debug(step, "runCallWithTrace: new evm step");
    trace.structLogs.push({
      pc: step.pc,
      op: step.opcode.name,
      gasCost: BigInt(step.opcode.fee) + (step.opcode.dynamicFee ?? 0n),
      gas: step.gasLeft,
      depth: step.depth,
      stack: step.stack.map((code) => utils.numberToHex(code))
    });
    next?.();
  });
  vm.evm.events?.on("afterMessage", (data, next) => {
    logger.debug(data.execResult, "runCallWithTrace: new message result");
    if (data.execResult.exceptionError !== void 0 && trace.structLogs.length > 0) {
      const nextLog = trace.structLogs[trace.structLogs.length - 1];
      utils.invariant(nextLog, new errors.DefensiveNullCheckError("No structLogs to mark as error"));
      Object.assign(nextLog, {
        error: data.execResult.exceptionError
      });
    }
    next?.();
  });
  if (lazilyRun) {
    return (
      /** @type any*/
      { trace }
    );
  }
  const runCallResult = await vm.evm.runCall(params);
  logger.debug(runCallResult, "runCallWithTrace: evm run call complete");
  trace.gas = runCallResult.execResult.executionGasUsed;
  trace.failed = runCallResult.execResult.exceptionError !== void 0;
  trace.returnValue = utils.bytesToHex(runCallResult.execResult.returnValue);
  return {
    ...runCallResult,
    trace
  };
};
var prefetchStorageFromAccessList = async (client, accessList) => {
  if (!accessList || accessList.size === 0) return;
  const vm = await client.getVm();
  const stateManager = vm.stateManager;
  const prefetchPromises = [];
  for (const [address$1, storageKeys] of accessList.entries()) {
    if (storageKeys.size === 0) continue;
    const addressObj = address.createAddress(address$1.startsWith("0x") ? address$1 : `0x${address$1}`);
    for (const storageKey of storageKeys) {
      const hexKey = (
        /** @type {`0x${string}`} */
        storageKey.startsWith("0x") ? storageKey : `0x${storageKey}`
      );
      const keyBytes = viem.hexToBytes(hexKey, { size: 32 });
      prefetchPromises.push(
        stateManager.getStorage(addressObj, keyBytes).catch((error) => {
          client.logger.debug(
            {
              error,
              address: address$1.startsWith("0x") ? address$1 : `0x${address$1}`,
              storageKey: storageKey.startsWith("0x") ? storageKey : `0x${storageKey}`
            },
            "Error prefetching storage slot from access list"
          );
        })
      );
    }
  }
  await Promise.all(prefetchPromises);
  client.logger.debug(
    { accessListSize: accessList.size, totalStorageSlotsPreloaded: prefetchPromises.length },
    "Prefetched storage slots from access list"
  );
};

// src/internal/setupPrefetchProxy.js
var setupPrefetchProxy = async (client, accessList) => {
  if (!client.forkTransport || !accessList || accessList.size === 0) return;
  let hasPrefetched = false;
  const originalRequest = client.forkTransport.request.bind(client.forkTransport);
  client.forkTransport.request = async (request) => {
    if (!hasPrefetched && (request.method === "eth_getStorageAt" || request.method === "eth_getProof")) {
      client.logger.debug({ method: request.method }, "First storage request detected, triggering prefetch");
      hasPrefetched = true;
      prefetchStorageFromAccessList(client, accessList).catch((error) => {
        client.logger.error({ error }, "Error during storage prefetching after first storage request");
      });
    }
    return originalRequest(request);
  };
};
var evmErrors = [
  errors.AuthCallUnsetError,
  errors.CodeSizeExceedsMaximumError,
  errors.CreateCollisionError,
  errors.InvalidCommitmentError,
  errors.EvmRevertError,
  errors.InitcodeSizeViolationError,
  errors.InsufficientBalanceError,
  errors.InternalEvmError,
  errors.InvalidBeginSubError,
  errors.InvalidBytecodeResultError,
  errors.InvalidEofFormatError,
  errors.InvalidInputLengthError,
  errors.InvalidJumpError,
  errors.InvalidJumpSubError,
  errors.InvalidKzgInputsError,
  errors.InvalidOpcodeError,
  errors.InvalidProofError,
  errors.InvalidReturnSubError,
  errors.OutOfGasError,
  errors.OutOfRangeError,
  errors.RefundExhaustedError,
  errors.StackOverflowError,
  errors.StackUnderflowError,
  errors.StaticStateChangeError,
  errors.StopError,
  errors.ValueOverflowError,
  errors.BLS12381InputEmptyError,
  errors.BLS12381FpNotInFieldError,
  errors.BLS12381InvalidInputLengthError,
  errors.BLS12381PointNotOnCurveError,
  errors.CodeStoreOutOfGasError
];
var handleRunTxError = (e) => {
  if (e instanceof Error) {
    if (e.message.includes("is less than the block's baseFeePerGas")) {
      return new errors.InvalidGasPriceError(e.message, { cause: e });
    }
    if (e.message.includes("invalid sender address, address is not an EOA (EIP-3607)")) {
      return new errors.InvalidAddressError(e.message, { cause: e });
    }
    if (e.message.includes("is lower than the minimum gas limit")) {
      return new errors.InvalidGasLimitError(e.message, { cause: e });
    }
    if (e.message.includes("tx has a higher gas limit than the block")) {
      return new errors.GasLimitExceededError(e.message, { cause: e });
    }
    if (e.message.includes("block has a different hardfork than the vm")) {
      return new errors.MisconfiguredClientError(e.message, { cause: (
        /** @type {any}*/
        e
      ) });
    }
    if (e.message.includes("the tx doesn't have the correct nonce.")) {
      return new errors.InvalidNonceError(e.message, { cause: e });
    }
    if (e.message.includes("sender doesn't have enough funds to send tx.")) {
      return new errors.InsufficientBalanceError(e.message, { cause: (
        /** @type {any}*/
        e
      ) });
    }
    return new errors.InternalEvmError(e.message, { cause: (
      /** @type {any}*/
      e
    ) });
  }
  if (!(e instanceof evm.EvmError)) {
    return new errors.InternalEvmError("Unknown error", { cause: (
      /** @type {any}*/
      e
    ) });
  }
  const ErrorConstructor = evmErrors.find((error) => "EVMErrorMessage" in error && error.EVMErrorMessage === e.error);
  if (!ErrorConstructor) {
    return new errors.InternalEvmError(`Unknown error: ${e.error}`, { cause: e });
  }
  return new ErrorConstructor(e.error, { cause: e });
};

// src/Call/executeCall.js
var executeCall = async (client, evmInput, params, events) => {
  let trace;
  let accessList;
  const vm$1 = await client.getVm();
  if (events?.onStep) vm$1.evm.events?.on("step", events.onStep);
  if (events?.onNewContract) vm$1.evm.events?.on("newContract", events.onNewContract);
  if (events?.onBeforeMessage) vm$1.evm.events?.on("beforeMessage", events.onBeforeMessage);
  if (events?.onAfterMessage) vm$1.evm.events?.on("afterMessage", events.onAfterMessage);
  try {
    const tx = await evmInputToImpersonatedTx({
      ...client,
      getVm: () => Promise.resolve(vm$1)
    })(evmInput, params.maxFeePerGas, params.maxPriorityFeePerGas);
    if (params.createTrace) {
      trace = await runCallWithTrace(vm$1, client.logger, evmInput, true).then(({ trace: trace2 }) => trace2);
    }
    const createAccessList = true;
    const runTxResult = await vm.runTx(vm$1)({
      reportAccessList: createAccessList,
      reportPreimages: createAccessList,
      skipHardForkValidation: true,
      skipBlockGasLimitValidation: true,
      // we currently set the nonce ourselves user can't set it
      skipNonce: true,
      // we must skipBalance for now because we have no clue what the gasLimit should be so this initial run we set it to block maximum
      skipBalance: true,
      ...evmInput.block !== void 0 ? { block: (
        /** @type any*/
        evmInput.block
      ) } : {},
      tx
    });
    if (trace) {
      trace.gas = /** @type {any} */
      runTxResult.execResult.executionGasUsed;
      trace.failed = false;
      trace.returnValue = viem.bytesToHex(
        /** @type {any} */
        runTxResult.execResult.returnValue
      );
    }
    client.logger.debug(
      {
        returnValue: viem.bytesToHex(
          /** @type {any} */
          runTxResult.execResult.returnValue
        ),
        exceptionError: (
          /** @type {any} */
          runTxResult.execResult.exceptionError
        ),
        executionGasUsed: (
          /** @type {any} */
          runTxResult.execResult.executionGasUsed
        )
      },
      "callHandler: runCall result"
    );
    if (runTxResult.accessList !== void 0) {
      accessList = new Map(
        runTxResult.accessList.map((item) => {
          return [item.address, new Set(item.storageKeys)];
        })
      );
      await setupPrefetchProxy(client, accessList);
      if (!params.createAccessList) {
        accessList = void 0;
      }
    }
    return {
      runTxResult,
      accessList,
      trace,
      .../** @type {any} */
      runTxResult.execResult.exceptionError !== void 0 ? { errors: [handleRunTxError(
        /** @type {any} */
        runTxResult.execResult.exceptionError
      )] } : {}
    };
  } catch (e) {
    return {
      trace,
      accessList,
      errors: [handleRunTxError(e)]
    };
  } finally {
    if (events?.onStep) vm$1.evm.events?.off("step", events.onStep);
    if (events?.onNewContract) vm$1.evm.events?.off("newContract", events.onNewContract);
    if (events?.onBeforeMessage) vm$1.evm.events?.off("beforeMessage", events.onBeforeMessage);
    if (events?.onAfterMessage) vm$1.evm.events?.off("afterMessage", events.onAfterMessage);
  }
};
var handlePendingTransactionsWarning = async (client, params, code, deployedBytecode) => {
  if (code === void 0 && deployedBytecode === void 0 && params.to !== void 0 && params.data !== void 0 && utils.hexToBytes(params.data).length > 0) {
    const vm = await client.getVm();
    const isCode = await vm.stateManager.getCode(address.createAddress(params.to)).then((code2) => code2.length > 0).catch(() => false);
    const txPool = await client.getTxPool();
    if (!isCode && txPool.txsInPool > 0) {
      client.logger.warn(
        `No code found for contract address ${params.to}. But there ${txPool.txsInPool === 1 ? "is" : "are"} ${txPool.txsInPool} pending tx in tx pool. Did you forget to mine a block?`
      );
    }
  }
};
async function handleStateOverrides(client, stateOverrideSet) {
  if (stateOverrideSet) {
    for (const [address, state] of Object.entries(stateOverrideSet)) {
      console.log("setting state", address, state);
      const res = await setAccountHandler(client)({
        address: (
          /** @type import('@tevm/utils').Address*/
          address
        ),
        ...state.nonce !== void 0 ? { nonce: state.nonce } : {},
        ...state.balance !== void 0 ? { balance: state.balance } : {},
        ...state.code !== void 0 ? { deployedBytecode: state.code } : {},
        ...state.state !== void 0 ? { state: state.state } : {},
        ...state.stateDiff !== void 0 ? { stateDiff: state.stateDiff } : {},
        throwOnFail: false
      });
      if (res.errors?.length) {
        return {
          errors: [
            new errors.InvalidParamsError("Invalid state override", {
              cause: (
                /** @type {Error} */
                res.errors.length === 1 ? res.errors[0] : new AggregateError(res.errors)
              )
            })
          ]
        };
      }
    }
  }
  return {};
}
var requireSig = false;
var createTransaction = (client, defaultThrowOnFail = true) => {
  return async ({ evmInput, evmOutput, throwOnFail = defaultThrowOnFail, nonceOverride, ...priorityFeeOpts }) => {
    const vm = await client.getVm();
    const pool = await client.getTxPool();
    const accountAddress = evmInput.origin ?? address.createAddress(0);
    const account = await vm.stateManager.getAccount(accountAddress).catch(() => new utils.EthjsAccount(0n, 0n));
    const hasEth = evmInput.skipBalance || (account?.balance ?? 0n) > 0n;
    if (!hasEth) {
      return maybeThrowOnFail(throwOnFail, {
        errors: [
          {
            _tag: "InsufficientBalance",
            name: "InsufficientBalance",
            message: `Insufficientbalance: Account ${accountAddress} attempted to create a transaction with zero eth. Consider adding eth to account or using a different from or origin address`
          }
        ]
      });
    }
    const parentBlock = await vm.blockchain.getCanonicalHeadBlock();
    const priorityFee = 0n;
    const dataFee = (() => {
      let out = 0n;
      for (const entry of evmInput.data ?? []) {
        out += entry === 0 ? 4n : 16n;
      }
      return out;
    })();
    const baseFee = (() => {
      let out = dataFee;
      const txFee = 21000n;
      out += txFee;
      const isCreation = (evmInput.to?.bytes.length ?? 0) === 0;
      if (vm.common.ethjsCommon.gteHardfork("homestead") && isCreation) {
        const txCreationFee = 32000n;
        out += txCreationFee;
      }
      return out;
    })();
    const minimumGasLimit = baseFee + evmOutput.execResult.executionGasUsed;
    const gasLimitWithExecutionBuffer = evmInput.gasLimit ?? minimumGasLimit * 11n / 10n;
    if (gasLimitWithExecutionBuffer < minimumGasLimit) {
      console.warn("The manually set gas limit set by tx is lower than the estimated cost. It may fail once mined.");
    }
    const sender = evmInput.origin ?? evmInput.caller ?? address.createAddress(`0x${"00".repeat(20)}`);
    const txPool = await client.getTxPool();
    const txs = await txPool.getBySenderAddress(sender);
    const accountNonce = (await vm.stateManager.getAccount(sender) ?? { nonce: 0n }).nonce;
    const nonce = nonceOverride !== void 0 ? nonceOverride : (() => {
      let highestPoolNonce = accountNonce - 1n;
      for (const tx2 of txs) {
        if (tx2.tx.nonce > highestPoolNonce) highestPoolNonce = tx2.tx.nonce;
      }
      return highestPoolNonce >= accountNonce ? highestPoolNonce + 1n : accountNonce;
    })();
    client.logger.debug({ nonce, sender: sender.toString() }, "creating tx with nonce");
    let maxFeePerGas = parentBlock.header.calcNextBaseFee() + priorityFee;
    const baseFeePerGas = parentBlock.header.baseFeePerGas ?? 0n;
    if (maxFeePerGas < baseFeePerGas) {
      maxFeePerGas = baseFeePerGas;
    }
    const tx$1 = tx.createImpersonatedTx(
      {
        impersonatedAddress: sender,
        nonce,
        gasLimit: gasLimitWithExecutionBuffer,
        maxFeePerGas: priorityFeeOpts.maxFeePerGas ?? maxFeePerGas,
        maxPriorityFeePerGas: priorityFeeOpts.maxPriorityFeePerGas ?? 0n,
        ...evmInput.to !== void 0 ? { to: evmInput.to } : {},
        ...evmInput.data !== void 0 ? { data: evmInput.data } : {},
        ...evmInput.value !== void 0 ? { value: evmInput.value } : {},
        // TODO we should handle non EIP-1559 txs here too
        gasPrice: null
      },
      {
        allowUnlimitedInitCodeSize: false,
        common: vm.common.ethjsCommon,
        // we don't want to freeze because there is a hack to set tx.hash when building a block
        freeze: false
      }
    );
    client.logger.debug(tx$1, "callHandler: Created a new transaction from transaction data");
    let poolPromise = (
      /**
       * @type {Promise<{error: null; hash: `0x${string}`;} | {error: string; hash: `0x${string}`;}>}
       */
      Promise.resolve({})
    );
    try {
      client.logger.debug({ requireSig, skipBalance: evmInput.skipBalance }, "callHandler: Adding tx to mempool");
      poolPromise = pool.add(tx$1, requireSig, evmInput.skipBalance ?? false);
      const txHash = utils.bytesToHex(tx$1.hash());
      client.logger.debug({ txHash }, "callHandler: received txHash");
      const account2 = await getAccountHandler(client)({
        address: (
          /** @type {import('@tevm/utils').Hex}*/
          sender.toString()
        )
      });
      const balanceNeeded = tx$1.value + gasLimitWithExecutionBuffer * tx$1.maxFeePerGas;
      const hasBalance = balanceNeeded <= account2.balance;
      if (evmInput?.skipBalance && !hasBalance) {
        await setAccountHandler(client)({
          address: (
            /** @type {import('@tevm/utils').Hex}*/
            sender.toString()
          ),
          balance: balanceNeeded
        });
      }
      await poolPromise;
      client.emit("newPendingTransaction", tx$1);
      return {
        txHash
      };
    } catch (e) {
      await poolPromise.catch(() => {
      });
      if (typeof e === "object" && e !== null && "_tag" in e && e._tag === "AccountNotFound") {
        return maybeThrowOnFail(throwOnFail ?? defaultThrowOnFail, {
          errors: [
            {
              name: "NoBalanceError",
              _tag: "NoBalanceError",
              message: "Attempting to create a transaction with an uninitialized account with no balance"
            }
          ],
          executionGasUsed: 0n,
          /**
           * @type {`0x${string}`}
           */
          rawData: "0x"
        });
      }
      client.logger.error(
        e,
        "callHandler: Unexpected error adding transaction to mempool and checkpointing state. Removing transaction from mempool and reverting state"
      );
      pool.removeByHash(utils.bytesToHex(tx$1.hash()));
      await vm.stateManager.revert();
      return maybeThrowOnFail(throwOnFail ?? defaultThrowOnFail, {
        errors: [
          {
            name: "UnexpectedError",
            _tag: "UnexpectedError",
            message: typeof e === "string" ? e : e instanceof Error ? e.message : typeof e === "object" && e !== null && "message" in e ? e.message : "unknown error"
          }
        ],
        executionGasUsed: 0n,
        /**
         * @type {`0x${string}`}
         */
        rawData: "0x"
      });
    }
  };
};

// src/Call/handleAutomining.js
var handleAutomining = async (client, txHash, isGasMining = false, mineAllTx = true) => {
  client.logger.debug(`${client.miningConfig.type === "auto" ? "Automining" : "Gas mining"} transaction ${txHash}...`);
  const blocks = 1;
  if (isGasMining && client.miningConfig.type === "gas" && client.miningConfig.limit) {
    client.logger.debug(`Gas mining mode with limit ${client.miningConfig.limit}`);
  }
  const mineRes = await mineHandler(client)({
    ...mineAllTx || txHash === void 0 ? {} : { tx: txHash },
    throwOnFail: false,
    blockCount: blocks
  });
  if (mineRes.errors?.length) {
    return mineRes;
  }
  client.logger.debug(mineRes, "Transaction successfully mined");
  return void 0;
};

// src/Call/shouldCreateTransaction.js
var shouldCreateTransaction = (params, runTxResult) => {
  const paramToUse = params.addToMempool ?? params.addToBlockchain ?? params.createTransaction;
  if (paramToUse === void 0) {
    return false;
  }
  if (paramToUse === "always") {
    return true;
  }
  if (paramToUse === true) {
    return true;
  }
  if (paramToUse === false || paramToUse === "never") {
    return false;
  }
  if (paramToUse === "on-success") {
    return runTxResult.execResult.exceptionError === void 0;
  }
  const invalidOption = paramToUse;
  throw new Error(`Invalid value for addToMempool/createTransaction: ${invalidOption}`);
};
var shouldAddToBlockchain = (params, runTxResult) => {
  if (params.addToBlockchain === void 0) {
    return false;
  }
  if (params.addToBlockchain === "always") {
    return true;
  }
  if (params.addToBlockchain === true) {
    return true;
  }
  if (params.addToBlockchain === false || params.addToBlockchain === "never") {
    return false;
  }
  if (params.addToBlockchain === "on-success") {
    return runTxResult.execResult.exceptionError === void 0;
  }
  const invalidOption = params.addToBlockchain;
  throw new Error(`Invalid addToBlockchain value: ${invalidOption}`);
};

// src/Call/handleTransactionCreation.js
var handleTransactionCreation = async (client, params, executedCall, evmInput) => {
  let txHash;
  const errors = [];
  if (params.createTransaction !== void 0) {
    client.logger.warn(
      "The createTransaction parameter is deprecated. Please use addToMempool or addToBlockchain instead."
    );
  }
  const shouldAutoMine = client.miningConfig.type === "auto" && [params.addToMempool, params.addToBlockchain, params.createTransaction].every(
    (param) => param !== false && param !== "never"
  );
  const shouldAddToChain = shouldAutoMine || shouldAddToBlockchain(params, executedCall.runTxResult);
  const shouldCreateTx = shouldAddToChain || shouldCreateTransaction(params, executedCall.runTxResult);
  if (shouldCreateTx) {
    try {
      const txRes = await createTransaction(client)({
        throwOnFail: false,
        evmOutput: executedCall.runTxResult,
        evmInput,
        maxPriorityFeePerGas: params.maxPriorityFeePerGas,
        maxFeePerGas: params.maxFeePerGas,
        nonceOverride: params.nonce
      });
      txHash = "txHash" in txRes ? txRes.txHash : void 0;
      const isGasMining = client.miningConfig.type === "gas";
      if (shouldAddToChain && txHash) {
        const autoMiningResult = await handleAutomining(client, txHash, isGasMining, false);
        if (autoMiningResult?.errors) {
          errors.push(.../** @type {any} */
          autoMiningResult.errors);
        }
      }
      if ("errors" in txRes && txRes.errors) {
        errors.push(.../** @type {any} */
        txRes.errors);
      }
    } catch (error) {
      errors.push(
        /** @type {any} */
        error
      );
    }
  }
  if (errors.length > 0) {
    return {
      errors
    };
  }
  return { hash: txHash };
};
var zCallEvents = zod.z.object({
  onStep: zod.z.function().optional().describe("Handler called on each EVM step (instruction execution)"),
  onNewContract: zod.z.function().optional().describe("Handler called when a new contract is created"),
  onBeforeMessage: zod.z.function().optional().describe("Handler called before a message (call) is processed"),
  onAfterMessage: zod.z.function().optional().describe("Handler called after a message (call) is processed")
}).partial();
var zBlockOverrideSet = zod.z.strictObject({
  number: zod.z.bigint().gte(0n).optional(),
  time: zod.z.bigint().gte(0n).optional(),
  gasLimit: zod.z.bigint().gte(0n).optional(),
  coinbase: zAddress.optional(),
  baseFee: zod.z.bigint().gte(0n).optional(),
  blobBaseFee: zod.z.bigint().gte(0n).optional()
});
var zStateOverrideSet = zod.z.record(
  zAddress,
  zod.z.strictObject({
    balance: zod.z.bigint().gte(0n).optional(),
    nonce: zod.z.bigint().gte(0n).optional(),
    code: zHex.optional(),
    state: zod.z.record(zHex, zHex).optional(),
    stateDiff: zod.z.record(zHex, zHex).optional()
  })
);

// src/BaseCall/zBaseCallParams.js
var zBaseCallParams = zBaseParams.extend({
  ...zCallEvents.shape,
  createTrace: zod.z.boolean().optional().describe("If true, the call will also return a `trace` on the trace property"),
  createAccessList: zod.z.boolean().optional().describe("If true, the call will also return a `accessList` on the accessList property"),
  createTransaction: zod.z.union([
    zod.z.boolean().optional().describe("If true, this call is a create transaction. Defaults to false."),
    zod.z.literal("on-success"),
    zod.z.literal("always"),
    zod.z.literal("never")
  ]),
  addToMempool: zod.z.union([
    zod.z.boolean().optional().describe("If true, this call adds the transaction to the mempool. Defaults to false."),
    zod.z.literal("on-success"),
    zod.z.literal("always"),
    zod.z.literal("never")
  ]),
  addToBlockchain: zod.z.union([
    zod.z.boolean().optional().describe("If true, this call adds the transaction to the blockchain. Defaults to false."),
    zod.z.literal("on-success"),
    zod.z.literal("always"),
    zod.z.literal("never")
  ]),
  skipBalance: zod.z.boolean().optional().describe("Set caller to msg.value of less than msg.value Defaults to false."),
  gasRefund: zod.z.bigint().nonnegative().optional().describe("Refund counter. Defaults to 0"),
  blockTag: zBlockParam.optional().describe('The block tag as a block number, block hash or one of "latest", "earliest", "pending" or "safe"'),
  gasPrice: zod.z.bigint().optional().describe("The gas price for the call. Defaults to `0`"),
  origin: zAddress.optional().describe("The address where the call originated from. Defaults to the zero address."),
  caller: zAddress.optional().describe("The address that ran this code (`msg.sender`). Defaults to the zero address."),
  gas: zod.z.bigint().nonnegative().optional().describe("The gas limit for the call. Defaults to `16777215` (`0xffffff`)"),
  value: zod.z.bigint().nonnegative().optional().describe("The value in ether that is being sent to `opts.address`. Defaults to `0`"),
  depth: zod.z.number().nonnegative().optional().describe("The call depth. Defaults to `0`"),
  selfdestruct: zod.z.set(zAddress).optional().describe("Addresses to selfdestruct. Defaults to the empty set."),
  to: zAddress.optional().describe(
    "The address of the account that is executing this code (`address(this)`). Defaults to the zero address."
  ),
  blobVersionedHashes: zod.z.array(zHex).optional().describe("Versioned hashes for each blob in a blob transaction"),
  stateOverrideSet: zStateOverrideSet.optional().describe("State override set for the call"),
  blockOverrideSet: zBlockOverrideSet.optional().describe("Block override set for the call"),
  maxFeePerGas: zod.z.bigint().optional().describe(
    "The maximum fee per gas for the call for an EIP-1559 tx. If not set it will be calculated based on the parent block."
  ),
  maxPriorityFeePerGas: zod.z.bigint().optional().describe("The maximum priority fee per gas for the call for an EIP-1559 tx.")
}).refine(
  (params) => {
    if (params.addToMempool !== void 0 && params.addToBlockchain !== void 0) {
      return false;
    }
    return true;
  },
  {
    message: "Cannot set both addToMempool and addToBlockchain simultaneously. Use one or the other."
  }
).describe("Properties shared across call-like actions");

// src/BaseCall/validateBaseCallParams.js
var validateBaseCallParams = (action) => {
  const errors$1 = [];
  const parsedParams = zBaseCallParams.safeParse(action);
  if (parsedParams.success === false) {
    const formattedErrors = zod.treeifyError(parsedParams.error);
    formattedErrors.errors.forEach((error) => {
      errors$1.push(new errors.InvalidParamsError(error));
    });
    if (formattedErrors.properties?.skipBalance) {
      formattedErrors.properties.skipBalance.errors.forEach((error) => {
        errors$1.push(new errors.InvalidSkipBalanceError(error));
      });
    }
    if (formattedErrors.properties?.gasRefund) {
      formattedErrors.properties.gasRefund.errors.forEach((error) => {
        errors$1.push(new errors.InvalidGasRefundError(error));
      });
    }
    if (formattedErrors.properties?.blockTag) {
      formattedErrors.properties.blockTag.errors.forEach((error) => {
        errors$1.push(new errors.InvalidBlockError(error));
      });
    }
    if (formattedErrors.properties?.gas) {
      formattedErrors.properties.gas.errors.forEach((error) => {
        errors$1.push(new errors.InvalidGasPriceError(error));
      });
    }
    if (formattedErrors.properties?.origin) {
      formattedErrors.properties.origin.errors.forEach((error) => {
        errors$1.push(new errors.InvalidOriginError(error));
      });
    }
    if (formattedErrors.properties?.caller) {
      formattedErrors.properties.caller.errors.forEach((error) => {
        errors$1.push(new errors.InvalidCallerError(error));
      });
    }
    if (formattedErrors.properties?.gas) {
      formattedErrors.properties.gas.errors.forEach((error) => {
        errors$1.push(new errors.InvalidGasPriceError(error));
      });
    }
    if (formattedErrors.properties?.value) {
      formattedErrors.properties.value.errors.forEach((error) => {
        errors$1.push(new errors.InvalidValueError(error));
      });
    }
    if (formattedErrors.properties?.depth) {
      formattedErrors.properties.depth.errors.forEach((error) => {
        errors$1.push(new errors.InvalidDepthError(error));
      });
    }
    if (formattedErrors.properties?.selfdestruct) {
      formattedErrors.properties.selfdestruct.errors.forEach((error) => {
        errors$1.push(new errors.InvalidSelfdestructError(error));
      });
    }
    if (formattedErrors.properties?.to) {
      formattedErrors.properties.to.errors.forEach((error) => {
        errors$1.push(new errors.InvalidToError(error));
      });
    }
    if (formattedErrors.properties?.blobVersionedHashes) {
      formattedErrors.properties.blobVersionedHashes.errors.forEach((error) => {
        errors$1.push(new errors.InvalidBlobVersionedHashesError(error));
      });
      for (const [key, value] of Object.entries(formattedErrors.properties?.blobVersionedHashes)) {
        if (key === "errors") continue;
        if (Array.isArray(value) && value.length > 0 && typeof value[0] === "object" && "errors" in value[0]) {
          value.forEach((item) => {
            if (typeof item === "object" && "errors" in item) {
              item.errors.forEach((error) => {
                errors$1.push(new errors.InvalidBlobVersionedHashesError(error));
              });
            }
          });
        }
      }
    }
    if (formattedErrors.properties?.maxFeePerGas) {
      formattedErrors.properties.maxFeePerGas.errors.forEach((error) => {
        errors$1.push(new errors.InvalidMaxFeePerGasError(error));
      });
    }
    if (formattedErrors.properties?.maxPriorityFeePerGas) {
      formattedErrors.properties.maxPriorityFeePerGas.errors.forEach((error) => {
        errors$1.push(new errors.InvalidMaxPriorityFeePerGasError(error));
      });
    }
    if (formattedErrors.properties?.addToMempool) {
      formattedErrors.properties.addToMempool.errors.forEach((error) => {
        errors$1.push(new errors.InvalidAddToMempoolError(error));
      });
    }
    if (formattedErrors.properties?.addToBlockchain) {
      formattedErrors.properties.addToBlockchain.errors.forEach((error) => {
        errors$1.push(new errors.InvalidAddToBlockchainError(error));
      });
    }
    if (errors$1.length === 0 && parsedParams.success === false) {
      errors$1.push(new errors.InvalidParamsError(parsedParams.error.message));
    }
  }
  return errors$1;
};
var zCallParams = zod.z.intersection(
  zBaseCallParams,
  zod.z.object({
    data: zHex.optional().describe("the data to send"),
    salt: zHex.optional().describe("the salt to use for the call"),
    code: zHex.optional().describe("the encoded deployment code to use for the call"),
    deployedBytecode: zHex.optional().describe("the deployed bytecode to put into state. Use code if you want to encode the deployment code")
  })
).refine(
  (params) => {
    if (params.code && params.deployedBytecode) {
      return false;
    }
    return true;
  },
  { message: "Cannot have both code and deployedBytecode set" }
).refine(
  (params) => {
    if (params.createTransaction && params.stateOverrideSet) {
      return false;
    }
    if (params.createTransaction && params.blockOverrideSet) {
      return false;
    }
    return true;
  },
  {
    message: "Cannot have stateOverrideSet or blockOverrideSet for createTransaction"
  }
).describe("Params to make a call to the tevm EVM");

// src/Call/validateCallParams.js
var validateCallParams = (action) => {
  const errors$1 = validateBaseCallParams(action);
  const parsedParams = zCallParams.safeParse(action);
  if (parsedParams.success === false) {
    const formattedErrors = parsedParams.error.format();
    if (formattedErrors.salt) {
      formattedErrors.salt._errors.forEach((error) => {
        errors$1.push(new errors.InvalidSaltError(error));
      });
    }
    if (formattedErrors.data) {
      formattedErrors.data._errors.forEach((error) => {
        errors$1.push(new errors.InvalidDataError(error));
      });
    }
    if (formattedErrors.code) {
      formattedErrors.code._errors.forEach((error) => {
        errors$1.push(new errors.InvalidBytecodeError(error));
      });
    }
    if (formattedErrors._errors) {
      formattedErrors._errors.forEach((error) => {
        errors$1.push(new errors.InvalidBytecodeError(error));
      });
    }
  }
  return errors$1;
};

// src/Call/callHandler.js
var callHandler2 = (client, { throwOnFail: defaultThrowOnFail = true } = {}) => async ({ code, deployedBytecode, onStep, onNewContract, onBeforeMessage, onAfterMessage, ...params }) => {
  client.logger.debug(params, "callHandler: Executing call with params");
  const validationErrors = validateCallParams(params);
  if (validationErrors.length > 0) {
    client.logger.debug(validationErrors, "Params do not pass validation");
    return maybeThrowOnFail(params.throwOnFail ?? defaultThrowOnFail, {
      errors: validationErrors,
      executionGasUsed: 0n,
      /**
       * @type {`0x${string}`}
       */
      rawData: "0x"
    });
  }
  const _params = {
    ...params
  };
  if (_params.blockTag === "pending") {
    const minePending = await getPendingClient(client);
    if (minePending.errors) {
      client.logger.error(minePending.errors);
      return maybeThrowOnFail(_params.throwOnFail ?? defaultThrowOnFail, {
        errors: minePending.errors,
        executionGasUsed: 0n,
        /**
         * @type {`0x${string}`}
         */
        rawData: "0x"
      });
    }
    if (_params.createTransaction || _params.addToMempool || _params.addToBlockchain || client.miningConfig.type === "auto") {
      const pendingClientAny = (
        /** @type {any}*/
        minePending.pendingClient
      );
      pendingClientAny.getTxPool = client.getTxPool;
    }
    return callHandler2(minePending.pendingClient, {
      throwOnFail: defaultThrowOnFail
    })({
      ...code !== void 0 ? { code } : {},
      ...deployedBytecode !== void 0 ? { deployedBytecode } : {},
      ..._params,
      blockTag: "latest"
    });
  }
  const callHandlerRes = await callHandlerOpts(client, _params);
  if (callHandlerRes.errors) {
    return maybeThrowOnFail(_params.throwOnFail ?? defaultThrowOnFail, {
      errors: callHandlerRes.errors,
      executionGasUsed: 0n,
      rawData: (
        /** @type {`0x${string}`}*/
        "0x"
      )
    });
  }
  const evmInput = callHandlerRes.data;
  const block = (
    /** @type {import('@tevm/block').Block}*/
    evmInput.block
  );
  await handlePendingTransactionsWarning(client, params, code, deployedBytecode);
  const vm = await cloneVmWithBlockTag(client, block);
  if (vm instanceof Error) {
    return maybeThrowOnFail(_params.throwOnFail ?? defaultThrowOnFail, {
      errors: [vm],
      executionGasUsed: 0n,
      /**
       * @type {`0x${string}`}
       */
      rawData: "0x"
    });
  }
  const stateOverrideResult = await handleStateOverrides(
    { ...client, getVm: async () => vm },
    params.stateOverrideSet
  );
  if (stateOverrideResult.errors) {
    return maybeThrowOnFail(_params.throwOnFail ?? defaultThrowOnFail, {
      errors: stateOverrideResult.errors,
      executionGasUsed: 0n,
      /**
       * @type {`0x${string}`}
       */
      rawData: "0x"
    });
  }
  const scriptResult = code || deployedBytecode ? await createScript({ ...client, getVm: () => vm.ready().then(() => vm) }, code, deployedBytecode, _params.to) : { address: _params.to, errors: void 0 };
  if (scriptResult.errors) {
    client.logger.error(scriptResult.errors, "contractHandler: Errors creating script");
    return maybeThrowOnFail(_params.throwOnFail ?? defaultThrowOnFail, {
      // TODO type errors better in callHandler
      errors: (
        /** @type {any}*/
        scriptResult.errors
      ),
      executionGasUsed: 0n,
      /**
       * @type {`0x${string}`}
       */
      rawData: "0x"
    });
  }
  if (scriptResult.address !== void 0) {
    evmInput.to = address.createAddress(scriptResult.address);
    _params.to = scriptResult.address;
  }
  const l1FeeInfoPromise = vm.common.sourceId !== void 0 ? getL1FeeInformationOpStack(evmInput.data ?? viem.numberToBytes(0), vm).catch((e) => {
    client.logger.warn(e, "Unable to get l1 fee estimation");
    return {};
  }) : Promise.resolve({});
  client.logger.debug(
    {
      to: evmInput.to?.toString(),
      origin: evmInput.origin?.toString(),
      caller: evmInput.caller?.toString(),
      value: evmInput.value?.toString(),
      gasLimit: evmInput.gasLimit?.toString(),
      data: evmInput.data
    },
    "callHandler: Executing runCall with params"
  );
  const eventHandlers = {};
  if (onStep) eventHandlers.onStep = onStep;
  if (onNewContract) eventHandlers.onNewContract = onNewContract;
  if (onBeforeMessage) eventHandlers.onBeforeMessage = onBeforeMessage;
  if (onAfterMessage) eventHandlers.onAfterMessage = onAfterMessage;
  const executedCall = await executeCall(
    { ...client, getVm: () => Promise.resolve(vm) },
    evmInput,
    _params,
    eventHandlers
  );
  if (!("runTxResult" in executedCall)) {
    return maybeThrowOnFail(_params.throwOnFail ?? defaultThrowOnFail, {
      executionGasUsed: (
        /** @type {any}*/
        0n
      ),
      // transaction was not executed
      rawData: (
        /** @type {`0x${string}`}*/
        "0x"
      ),
      errors: executedCall.errors,
      ..."trace" in executedCall && executedCall.trace !== void 0 ? { trace: executedCall.trace } : {}
    });
  }
  const txResult = await handleTransactionCreation(client, params, executedCall, evmInput);
  if ("runTxResult" in executedCall && (executedCall.errors || txResult.errors)) {
    return maybeThrowOnFail(_params.throwOnFail ?? defaultThrowOnFail, {
      ...vm.common.sourceId !== void 0 ? await l1FeeInfoPromise : {},
      ...callHandlerResult(executedCall.runTxResult, txResult.hash, executedCall.trace, executedCall.accessList),
      errors: (
        /** @type {any}*/
        executedCall.errors ?? txResult.errors
      )
    });
  }
  return maybeThrowOnFail(_params.throwOnFail ?? defaultThrowOnFail, {
    ...vm.common.sourceId !== void 0 ? await l1FeeInfoPromise : {},
    ...callHandlerResult(executedCall.runTxResult, txResult.hash, executedCall.trace, executedCall.accessList)
  });
};
var zAbi = zod$1.Abi.describe("A valid ABI");

// src/Contract/zContractParams.js
var zContractParams = zod.z.intersection(
  zBaseCallParams,
  zod.z.object({
    to: zAddress.optional().describe("The required address of the contract to call"),
    abi: zAbi.describe("The abi of the contract"),
    args: zod.z.array(zod.z.any()).optional().describe("The arguments to pass to the function"),
    functionName: zod.z.string().describe("The name of the function to call"),
    code: zHex.optional().describe("the encoded bytecode to use for the call"),
    deployedBytecode: zHex.optional().describe(
      "deployed bytecode to put into state for contract. If you want to run a constructor use code instead"
    )
  })
).refine(
  (params) => {
    if (!params.code && !params.to && !params.deployedBytecode) {
      return false;
    }
    return true;
  },
  {
    message: "Must have either code or to"
  }
).refine(
  (params) => {
    if (params.createTransaction && params.stateOverrideSet) {
      return false;
    }
    if (params.createTransaction && params.blockOverrideSet) {
      return false;
    }
    return true;
  },
  {
    message: "Cannot have stateOverrideSet or blockOverrideSet for createTransaction"
  }
).describe("Params to execute a contract method in the tevm EVM");

// src/Contract/validateContractParams.js
var validateContractParams = (action) => {
  const errors$1 = validateBaseCallParams(action);
  const parsedParams = zContractParams.safeParse(action);
  if (parsedParams.success === false) {
    const formattedErrors = parsedParams.error.format();
    if (formattedErrors._errors) {
      formattedErrors._errors.forEach((error) => {
        errors$1.push(new errors.InvalidParamsError(error));
      });
    }
    if (formattedErrors.code) {
      formattedErrors.code._errors.forEach((error) => {
        errors$1.push(new errors.InvalidBytecodeError(error));
      });
    }
    if (formattedErrors.deployedBytecode) {
      formattedErrors.deployedBytecode._errors.forEach((error) => {
        errors$1.push(new errors.InvalidBytecodeError(error));
      });
    }
    if (formattedErrors.abi) {
      formattedErrors.abi._errors.forEach((error) => {
        errors$1.push(new errors.InvalidAbiError(error));
      });
    }
    if (formattedErrors.args) {
      formattedErrors.args._errors.forEach((error) => {
        errors$1.push(new errors.InvalidArgsError(error));
      });
    }
    if (formattedErrors.functionName) {
      formattedErrors.functionName._errors.forEach((error) => {
        errors$1.push(new errors.InvalidFunctionNameError(error));
      });
    }
    if (formattedErrors.to) {
      formattedErrors.to._errors.forEach((error) => {
        errors$1.push(new errors.InvalidAddressError(error));
      });
    }
  }
  return errors$1;
};

// src/Contract/contractHandler.js
var contractHandler = (client, { throwOnFail: throwOnFailDefault = true } = {}) => async (params) => {
  const errors$1 = validateContractParams(
    /** @type any*/
    params
  );
  if (errors$1.length > 0) {
    client.logger.debug(errors$1, "contractHandler: Invalid params");
    return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, {
      errors: errors$1,
      executionGasUsed: 0n,
      rawData: "0x"
    });
  }
  const vm = await client.getVm();
  const contract = params.to && await vm.evm.stateManager.getCode(address.createAddress(params.to));
  const precompile = params.to && vm.evm.getPrecompile(address.createAddress(params.to));
  if (!params.deployedBytecode && !params.code && contract && contract?.length === 0 && !precompile) {
    client.logger.debug(
      { contract, precompile, to: params.to },
      "contractHandler: No contract bytecode nor precompile was found at specified `to` address. Unable to execute contract call."
    );
    return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, {
      rawData: "0x",
      executionGasUsed: 0n,
      errors: [
        {
          _tag: "InvalidRequestError",
          name: "InvalidRequestError",
          message: `Contract at address ${params.to} does not exist`
        }
      ]
    });
  }
  let functionData;
  try {
    functionData = utils.encodeFunctionData(
      /** @type {any} */
      {
        abi: params.abi,
        functionName: params.functionName,
        args: params.args
      }
    );
  } catch (e) {
    client.logger.debug(e, "contractHandler: Unable to encode the abi, functionName, and args into hex data");
    const cause = (
      /** @type {Error}*/
      e
    );
    const err = new errors.InvalidRequestError(cause.message, { cause });
    return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, {
      rawData: "0x",
      executionGasUsed: 0n,
      errors: [err]
    });
  }
  client.logger.debug(
    { functionData },
    "contractHandler: Encoded data, functionName, and args into hex data to execute call"
  );
  const result = await callHandler2(client, {
    throwOnFail: throwOnFailDefault
  })({
    ...params,
    throwOnFail: false,
    data: functionData
  });
  if (result.errors && result.errors.length > 0) {
    result.errors = result.errors.map((err) => {
      if (utils.isHex(result.rawData) && err instanceof errors.RevertError) {
        client.logger.debug(err, "contractHandler: Contract revert error. Decoding the error");
        try {
          if (!params.functionName) throw err;
          const rawContractError = new viem.RawContractError({ data: result.rawData });
          const contractError = viem.getContractError(rawContractError, {
            abi: (
              /** @type {import('@tevm/utils').Abi} */
              params.abi
            ),
            args: params.args,
            address: params.to,
            docsPath: err.docsPath,
            functionName: params.functionName,
            sender: params.caller ?? params.origin
          });
          const message = contractError.message;
          client.logger.debug(err, message);
          return new errors.RevertError(message, { cause: contractError });
        } catch (e) {
          client.logger.debug(e, "There was an error decoding error result");
          return new errors.RevertError(err.message, { cause: err, raw: result.rawData });
        }
      }
      return err;
    });
    client.logger.debug(result.errors, "contractHandler: Execution errors");
    return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, result);
  }
  let decodedResult;
  try {
    decodedResult = utils.decodeFunctionResult(
      /** @type {any} */
      {
        abi: params.abi,
        data: result.rawData,
        functionName: params.functionName
      }
    );
  } catch (e) {
    if (result.rawData === "0x") {
      return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, {
        errors: [
          new Error(
            "0x data returned from EVM with no error message. This indicates a the contract was missing or bug in Tevm if no other errors were thrown"
          )
        ],
        rawData: "0x",
        executionGasUsed: 0n
      });
    }
    client.logger.debug(e, "contractHandler: Error decoding returned call data with provided abi and functionName");
    const cause = (
      /** @type {Error}*/
      e
    );
    const err = new errors.DecodeFunctionDataError(cause.message, { cause });
    return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, {
      debugContext: {
        abi: params.abi,
        rawData: result.rawData,
        functionName: params.functionName
      },
      rawData: "0x",
      executionGasUsed: 0n,
      errors: [err]
    });
  }
  client.logger.debug(decodedResult, "contractHandler: decoded data into a final result");
  return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, {
    .../** @type any */
    result,
    data: decodedResult
  });
};
var decodeRevertReason = (data) => {
  if (!data || data === "0x") return "execution reverted";
  const hexData = typeof data === "string" && data.startsWith("0x") ? (
    /** @type {import('viem').Hex} */
    data
  ) : (
    /** @type {import('viem').Hex} */
    `0x${data}`
  );
  const cleanHex = hexData.slice(2);
  if (cleanHex.length === 0 || cleanHex.length % 2 !== 0 || cleanHex.length < 8) {
    return "execution reverted";
  }
  const ERROR_SELECTOR = viem.toFunctionSelector("Error(string)");
  const PANIC_SELECTOR = viem.toFunctionSelector("Panic(uint256)");
  if (hexData.toLowerCase().startsWith(ERROR_SELECTOR)) {
    try {
      const reason = viem.decodeAbiParameters([{ type: "string" }], `0x${hexData.slice(10)}`)[0];
      if (typeof reason === "string" && reason.length > 0) {
        return `execution reverted: ${reason}`;
      }
      return "execution reverted";
    } catch {
      return "execution reverted";
    }
  }
  if (hexData.startsWith(PANIC_SELECTOR)) {
    try {
      const code = viem.decodeAbiParameters([{ type: "uint256" }], `0x${hexData.slice(10)}`)[0];
      return `execution reverted: Panic(${code.toString()})`;
    } catch {
    }
  }
  try {
    const decoded = viem.hexToString(hexData);
    if (/^[\x20-\x7E]*$/.test(decoded) && decoded.trim().length > 0) {
      return `execution reverted: ${decoded.trim()}`;
    }
  } catch {
  }
  if (cleanHex.length > 8) {
    const selector = hexData.slice(0, 10);
    const errorData = (
      /** @type {import('viem').Hex} */
      `0x${hexData.slice(10)}`
    );
    try {
      const utf8 = viem.hexToString(errorData);
      if (/^[\x20-\x7E]*$/.test(utf8) && utf8.trim()) {
        return `execution reverted: custom error ${selector}: ${utf8.trim()}`;
      }
    } catch {
    }
    return `execution reverted: custom error ${selector}: ${errorData}`;
  }
  return `execution reverted: custom error ${hexData}`;
};
var parseBlockTag = (blockTag) => {
  const blockHashLength = 64 + "0x".length;
  const isBlockNumber = typeof blockTag === "string" && blockTag.startsWith("0x") && blockTag.length !== blockHashLength;
  if (isBlockNumber) {
    return utils.hexToBigInt(
      /** @type {import('@tevm/utils').Hex}*/
      blockTag
    );
  }
  return blockTag;
};

// src/Call/callProcedure.js
var callProcedure = (client) => async (request) => {
  const { errors: errors$1 = [], ...result } = await callHandler2(client)({
    throwOnFail: false,
    ...request.params[1] ? {
      stateOverrideSet: Object.fromEntries(
        Object.entries(request.params[1]).map(([address, state]) => [
          address,
          {
            ...state.code ? { code: state.code } : {},
            ...state.balance ? { balance: utils.hexToBigInt(state.balance) } : {},
            ...state.nonce ? { nonce: utils.hexToBigInt(state.nonce) } : {},
            ...state.state ? { state: state.state } : {},
            ...state.stateDiff ? { stateDiff: state.stateDiff } : {}
          }
        ])
      )
    } : {},
    ...request.params[2] ? {
      blockOverrideSet: {
        ...request.params[2].blobBaseFee ? { blobBaseFee: utils.hexToBigInt(request.params[2].blobBaseFee) } : {},
        ...request.params[2].baseFee ? { baseFee: utils.hexToBigInt(request.params[2].baseFee) } : {},
        ...request.params[2].gasLimit ? { gasLimit: utils.hexToBigInt(request.params[2].gasLimit) } : {},
        ...request.params[2].coinbase ? { coinbase: request.params[2].coinbase } : {},
        ...request.params[2].time ? { time: utils.hexToBigInt(request.params[2].time) } : {},
        ...request.params[2].number ? { number: utils.hexToBigInt(request.params[2].number) } : {}
      }
    } : {},
    ...request.params[0].code ? { code: request.params[0].code } : {},
    ...request.params[0].data ? { data: request.params[0].data } : {},
    ...request.params[0].deployedBytecode ? { deployedBytecode: request.params[0].deployedBytecode } : {},
    ...request.params[0].createTrace ? { createTrace: request.params[0].createTrace } : {},
    ...request.params[0].createAccessList ? { createAccessList: request.params[0].createAccessList } : {},
    ...request.params[0].blobVersionedHashes ? { blobVersionedHashes: request.params[0].blobVersionedHashes } : {},
    ...request.params[0].caller ? { caller: request.params[0].caller } : {},
    ...request.params[0].depth ? { depth: request.params[0].depth } : {},
    ...request.params[0].gasPrice ? { gasPrice: utils.hexToBigInt(request.params[0].gasPrice) } : {},
    ...request.params[0].gas ? { gas: utils.hexToBigInt(request.params[0].gas) } : {},
    ...request.params[0].gasRefund ? { gasRefund: utils.hexToBigInt(request.params[0].gasRefund) } : {},
    ...request.params[0].origin ? { origin: request.params[0].origin } : {},
    ...request.params[0].salt ? { salt: request.params[0].salt } : {},
    ...request.params[0].selfdestruct ? { selfdestruct: new Set(request.params[0].selfdestruct) } : {},
    ...request.params[0].skipBalance ? { skipBalance: request.params[0].skipBalance } : {},
    ...request.params[0].to ? { to: request.params[0].to } : {},
    ...request.params[0].value ? { value: utils.hexToBigInt(request.params[0].value) } : {},
    ...request.params[0].blockTag ? { blockTag: parseBlockTag(request.params[0].blockTag) } : {},
    ...request.params[0].createTransaction !== void 0 ? { createTransaction: request.params[0].createTransaction } : {},
    ...request.params[0].addToMempool !== void 0 ? { addToMempool: request.params[0].addToMempool } : {},
    ...request.params[0].addToBlockchain !== void 0 ? { addToBlockchain: request.params[0].addToBlockchain } : {},
    ...request.params[0].from ? { from: request.params[0].from } : {},
    ...request.params[0].maxFeePerGas ? { maxFeePerGas: utils.hexToBigInt(request.params[0].maxFeePerGas) } : {},
    ...request.params[0].maxPriorityFeePerGas ? { maxPriorityFeePerGas: utils.hexToBigInt(request.params[0].maxPriorityFeePerGas) } : {},
    ...request.params[0].nonce ? { nonce: utils.hexToBigInt(request.params[0].nonce) } : {}
  });
  if (errors$1.length > 0) {
    const error = (
      /** @type {import('./TevmCallError.js').TevmCallError}*/
      errors$1[0]
    );
    let message = error.message;
    if (error.code === errors.RevertError.code) {
      message = decodeRevertReason(result.rawData);
    }
    return {
      jsonrpc: "2.0",
      error: {
        code: error.code,
        message,
        data: {
          data: result.rawData,
          errors: errors$1.map(({ message: message2 }) => message2)
        }
      },
      method: "tevm_call",
      ...request.id === void 0 ? {} : { id: request.id }
    };
  }
  const accessList = result.accessList !== void 0 ? Object.fromEntries(Object.entries(result.accessList).map(([key, value]) => [key, [...value]])) : void 0;
  const toHex3 = (value) => (
    /**@type {import('@tevm/utils').Hex}*/
    utils.numberToHex(value)
  );
  const out = {
    jsonrpc: "2.0",
    result: {
      executionGasUsed: toHex3(result.executionGasUsed),
      rawData: result.rawData,
      ...result.selfdestruct ? { selfdestruct: [...result.selfdestruct] } : {},
      ...result.gasRefund ? { gasRefund: toHex3(result.gasRefund) } : {},
      ...result.gas ? { gas: toHex3(result.gas) } : {},
      ...result.logs ? { logs: result.logs } : {},
      ...result.txHash ? { txHash: result.txHash } : {},
      ...result.blobGasUsed ? { blobGasUsed: toHex3(result.blobGasUsed) } : {},
      ...accessList !== void 0 ? { accessList } : {},
      ...result.preimages ? { preimages: result.preimages } : {},
      ...result.l1Fee ? { l1Fee: utils.numberToHex(result.l1Fee) } : {},
      ...result.l1BaseFee ? { l1BaseFee: utils.numberToHex(result.l1BaseFee) } : {},
      ...result.l1BlobFee ? { l1BlobFee: utils.numberToHex(result.l1BlobFee) } : {},
      ...result.l1GasUsed ? { l1GasUsed: utils.numberToHex(result.l1GasUsed) } : {},
      ...result.amountSpent ? { amountSpent: utils.numberToHex(result.amountSpent) } : {},
      ...result.baseFee ? { baseFee: utils.numberToHex(result.baseFee) } : {},
      ...result.totalGasSpent ? { totalGasSpent: utils.numberToHex(result.totalGasSpent) } : {},
      ...result.trace ? {
        trace: {
          ...result.trace,
          gas: toHex3(result.trace.gas),
          structLogs: result.trace.structLogs.map((log) => ({
            ...log,
            gas: toHex3(log.gas),
            gasCost: toHex3(log.gasCost),
            stack: [...log.stack]
          }))
        }
      } : {},
      ...result.createdAddress ? { createdAddress: result.createdAddress } : {},
      ...result.createdAddresses ? { createdAddresses: [...result.createdAddresses] } : {}
    },
    method: "tevm_call",
    ...request.id === void 0 ? {} : { id: request.id }
  };
  return out;
};

// src/eth/ethCreateAccessListProcedure.js
var ethCreateAccessListProcedure = (client) => async (req) => {
  const [tx, blockTag] = req.params;
  const { data, from, to, gas, gasPrice, value } = tx;
  const response = await callProcedure(client)({
    ...req.id !== void 0 ? { id: req.id } : {},
    jsonrpc: req.jsonrpc,
    method: "tevm_call",
    params: [
      {
        ...gasPrice !== void 0 ? { gasPrice } : {},
        ...data !== void 0 ? { data } : {},
        ...gas !== void 0 ? { gas } : {},
        ...value !== void 0 ? { value } : {},
        ...to !== void 0 ? { to } : {},
        ...from !== void 0 ? { from } : {},
        ...blockTag !== void 0 ? { blockTag } : {},
        createAccessList: true
      }
    ]
  });
  if (!response.result || !response.result.accessList) {
    const out = {
      jsonrpc: req.jsonrpc,
      method: "eth_createAccessList",
      error: response.error ?? { code: -32e3, message: "Failed to create access list" },
      ...req.id !== void 0 ? { id: req.id } : {}
    };
    return out;
  }
  const formattedAccessList = Object.entries(response.result.accessList).map(([address, storageKeys]) => ({
    address: (
      /** @type {import('abitype').Address}*/
      address
    ),
    storageKeys: Array.from(storageKeys)
  }));
  return {
    jsonrpc: req.jsonrpc,
    method: "eth_createAccessList",
    result: {
      accessList: formattedAccessList,
      gasUsed: response.result.totalGasSpent ?? "0x0"
    },
    ...req.id !== void 0 ? { id: req.id } : {}
  };
};
var getStorageAtHandler = (client) => async (params) => {
  const vm = await client.getVm();
  const tag = params.blockTag ?? "latest";
  if (tag === "pending") {
    const mineResult = await getPendingClient(client);
    if (mineResult.errors) {
      throw mineResult.errors[0];
    }
    return getStorageAtHandler(mineResult.pendingClient)({ ...params, blockTag: "latest" });
  }
  if (tag === "latest") {
    return utils.bytesToHex(
      await vm.stateManager.getStorage(address.createAddress(params.address), utils.hexToBytes(params.position, { size: 32 }))
    );
  }
  const block = await vm.blockchain.getBlockByTag(tag);
  const clonedVm = await cloneVmWithBlockTag(client, block);
  if (clonedVm instanceof errors.ForkError || clonedVm instanceof errors.InternalError) {
    throw clonedVm;
  }
  return getStorageAtHandler({ ...client, getVm: () => Promise.resolve(clonedVm) })({ ...params, blockTag: "latest" });
};
var setAccountProcedure = (client) => async (request) => {
  const { errors = [], ...result } = await setAccountHandler(client)({
    throwOnFail: false,
    address: request.params[0].address,
    ...request.params[0].nonce ? { nonce: utils.hexToBigInt(request.params[0].nonce) } : {},
    ...request.params[0].balance ? { balance: utils.hexToBigInt(request.params[0].balance) } : {},
    ...request.params[0].deployedBytecode ? { deployedBytecode: request.params[0].deployedBytecode } : {},
    ...request.params[0].storageRoot ? { storageRoot: request.params[0].storageRoot } : {},
    ...request.params[0].state ? { state: request.params[0].state } : {},
    ...request.params[0].stateDiff ? { stateDiff: request.params[0].stateDiff } : {}
  });
  if (errors.length > 0) {
    const error = (
      /** @type {import('./TevmSetAccountError.js').TevmSetAccountError}*/
      errors[0]
    );
    return {
      jsonrpc: "2.0",
      error: {
        code: error.code,
        message: error.message,
        data: {
          errors: errors.map(({ message }) => message)
        }
      },
      method: "tevm_setAccount",
      ...request.id === void 0 ? {} : { id: request.id }
    };
  }
  return {
    jsonrpc: "2.0",
    result,
    method: "tevm_setAccount",
    ...request.id === void 0 ? {} : { id: request.id }
  };
};

// src/anvil/anvilSetStorageAtProcedure.js
var anvilSetStorageAtJsonRpcProcedure = (client) => {
  return async (request) => {
    const result = await setAccountProcedure(client)({
      method: "tevm_setAccount",
      ...request.id ? { id: request.id } : {},
      jsonrpc: "2.0",
      params: [
        {
          address: request.params[0],
          stateDiff: {
            [request.params[1]]: request.params[2]
          }
        }
      ]
    });
    if (result.error) {
      return {
        error: (
          /** @type {any}*/
          result.error
        ),
        jsonrpc: "2.0",
        method: request.method,
        ...request.id ? { id: request.id } : {}
      };
    }
    return {
      jsonrpc: "2.0",
      method: request.method,
      ...request.id ? { id: request.id } : {},
      result: null
    };
  };
};

// src/anvil/anvilDealHandler.js
var dealHandler = (node) => async ({ erc20, account, amount }) => {
  if (!erc20) {
    return setAccountHandler(node)({
      address: account,
      balance: amount
    });
  }
  const value = utils.numberToHex(amount, { size: 32 });
  const accessListResponse = await ethCreateAccessListProcedure(node)({
    method: "eth_createAccessList",
    params: [
      {
        to: erc20,
        data: viem.encodeFunctionData({
          abi: contract.ERC20.abi,
          functionName: "balanceOf",
          args: [account]
        })
      }
    ],
    id: 1,
    jsonrpc: "2.0"
  });
  if (!accessListResponse.result?.accessList) {
    console.error(accessListResponse.error);
    throw new Error("Failed to get access list");
  }
  const modifiedSlots = [];
  for (const { address, storageKeys } of accessListResponse.result.accessList) {
    for (const slot of storageKeys) {
      const oldValue = await getStorageAtHandler(node)({
        address,
        position: slot,
        blockTag: "latest"
      });
      await anvilSetStorageAtJsonRpcProcedure(node)({
        method: "anvil_setStorageAt",
        params: [address, slot, value],
        id: 1,
        jsonrpc: "2.0"
      });
      modifiedSlots.push({ address, slot, oldValue });
      const balanceResponse = await contractHandler(node)({
        to: erc20,
        abi: contract.ERC20.abi,
        functionName: "balanceOf",
        args: [account],
        throwOnFail: false
      });
      if (!balanceResponse.errors && balanceResponse.data === viem.hexToBigInt(value)) {
        for (const { address: resetAddr, slot: resetSlot, oldValue: resetValue } of modifiedSlots) {
          if (resetAddr === address && resetSlot === slot) continue;
          await anvilSetStorageAtJsonRpcProcedure(node)({
            method: "anvil_setStorageAt",
            params: [resetAddr, resetSlot, resetValue],
            id: 1,
            jsonrpc: "2.0"
          });
        }
        return {};
      }
      await anvilSetStorageAtJsonRpcProcedure(node)({
        method: "anvil_setStorageAt",
        params: [address, slot, oldValue],
        id: 1,
        jsonrpc: "2.0"
      });
      modifiedSlots.pop();
    }
  }
  return {
    errors: [
      {
        name: "StorageSlotNotFound",
        message: "Could not find correct storage slot for balanceOf"
      }
    ]
  };
};
var anvilDealJsonRpcProcedure = (client) => async (request) => {
  const [{ erc20, account, amount }] = request.params;
  const result = await dealHandler(client)({
    ...erc20 !== void 0 ? { erc20 } : {},
    account,
    amount: viem.hexToBigInt(amount)
  });
  if ("errors" in result && result.errors) {
    const out = {
      jsonrpc: request.jsonrpc,
      ...request.id !== void 0 ? { id: request.id } : {},
      method: "anvil_deal",
      error: {
        // @ts-expect-error being lazy here
        code: (result.errors[0]?.code ?? -32e3).toString(),
        message: result.errors[0]?.message ?? result.errors[0]?.name ?? "An unknown error occured"
      }
    };
    return out;
  }
  return {
    jsonrpc: request.jsonrpc,
    ...request.id !== void 0 ? { id: request.id } : {},
    method: "anvil_deal",
    result: {}
  };
};
var anvilDropTransactionJsonRpcProcedure = (client) => {
  return async (request) => {
    const anvilDropTransactionRequest = (
      /** @type {import('./AnvilJsonRpcRequest.js').AnvilDropTransactionJsonRpcRequest}*/
      request
    );
    const txHash = anvilDropTransactionRequest.params[0].transactionHash;
    const txPool = await client.getTxPool();
    if (
      /** @type {any[]}*/
      txPool.getByHash([utils.hexToBytes(txHash)]).length > 0
    ) {
      txPool.removeByHash(txHash);
    } else {
      throw new Error(
        "Only tx in the txpool are allowed to be dropped. Dropping transactions that have already been mined is not yet supported"
      );
    }
    return {
      method: anvilDropTransactionRequest.method,
      jsonrpc: "2.0",
      result: null,
      ...anvilDropTransactionRequest.id ? { id: anvilDropTransactionRequest.id } : {}
    };
  };
};
var serializeState = (state) => {
  const serializedState = {};
  for (const [address, account] of Object.entries(state)) {
    serializedState[address] = {
      nonce: utils.numberToHex(account.nonce),
      balance: utils.numberToHex(account.balance),
      storageRoot: account.storageRoot,
      codeHash: account.codeHash,
      ...account.deployedBytecode && { deployedBytecode: account.deployedBytecode },
      ...account.storage && {
        storage: {
          ...Object.fromEntries(Object.entries(account.storage).map(([key, value]) => [`0x${key}`, value]))
        }
      }
    };
  }
  return serializedState;
};
var dumpStateHandler = (client, options = {}) => async ({ throwOnFail = options.throwOnFail, blockTag = "latest" } = {}) => {
  try {
    const vm = blockTag === "pending" ? await getPendingClient(client).then((mineResult) => {
      if (mineResult.errors) {
        throw mineResult.errors[0];
      }
      return mineResult.pendingClient.getVm();
    }) : await client.getVm();
    if ("dumpCanonicalGenesis" in vm.stateManager) {
      if (blockTag === "latest" || blockTag === "pending") {
        const rawState = await vm.stateManager.dumpCanonicalGenesis();
        return { state: serializeState(rawState) };
      }
      const block = await vm.blockchain.getBlockByTag(blockTag);
      if (await vm.stateManager.hasStateRoot(block.header.stateRoot)) {
        const rawState = vm.stateManager._baseState.stateRoots.get(utils.bytesToHex(block.header.stateRoot)) ?? {};
        return { state: serializeState(rawState) };
      }
      client.logger.warn(`State root does not exist for block ${blockTag}. Returning empty state`);
      return { state: {} };
    }
    throw new errors.InternalError(
      "Unsupported state manager. Must use a TEVM state manager from `@tevm/state` package. This may indicate a bug in TEVM internal code."
    );
  } catch (e) {
    if (
      /** @type {import('@tevm/errors').BaseError}*/
      e._tag
    ) {
      return maybeThrowOnFail(throwOnFail ?? true, {
        state: {},
        // TODO we need to strongly type errors better here
        errors: [
          /**@type {any} */
          e
        ]
      });
    }
    return maybeThrowOnFail(throwOnFail ?? true, {
      state: {},
      errors: [e instanceof errors.InternalError ? e : new errors.InternalError("Unexpected error", { cause: e })]
    });
  }
};

// src/DumpState/dumpStateProcedure.js
var dumpStateProcedure = (client) => async (request) => {
  const { errors = [], ...result } = await dumpStateHandler(client)({
    throwOnFail: false
  });
  if (errors.length > 0) {
    const error = (
      /** @type {import('./TevmDumpStateError.js').TevmDumpStateError}*/
      errors[0]
    );
    return {
      jsonrpc: "2.0",
      error: {
        code: error.code,
        message: error.message,
        data: {
          errors: errors.map(({ message }) => message)
        }
      },
      method: "tevm_dumpState",
      ...request.id === void 0 ? {} : { id: request.id }
    };
  }
  return {
    jsonrpc: "2.0",
    result: {
      state: result.state
    },
    method: "tevm_dumpState",
    ...request.id === void 0 ? {} : { id: request.id }
  };
};

// src/anvil/anvilDumpStateProcedure.js
var anvilDumpStateJsonRpcProcedure = (client) => {
  return async (request) => {
    return (
      /** @type any*/
      {
        ...await dumpStateProcedure(client)({
          ...request.id ? { id: request.id } : {},
          jsonrpc: "2.0",
          method: "tevm_dumpState"
        }),
        method: request.method
      }
    );
  };
};

// src/anvil/anvilGetAutomineProcedure.js
var anvilGetAutomineJsonRpcProcedure = (client) => {
  return async (request) => {
    return {
      jsonrpc: "2.0",
      method: request.method,
      result: client.miningConfig.type === "auto",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var anvilImpersonateAccountJsonRpcProcedure = (client) => {
  return async (request) => {
    try {
      client.setImpersonatedAccount(utils.getAddress(request.params[0]));
      return {
        jsonrpc: "2.0",
        method: request.method,
        ...request.id ? { id: request.id } : {},
        result: null
      };
    } catch (e) {
      return {
        jsonrpc: "2.0",
        method: request.method,
        ...request.id ? { id: request.id } : {},
        // TODO use @tevm/errors
        error: {
          code: (
            /** @type any*/
            -32602
          ),
          message: (
            /** @type {Error}*/
            e.message
          )
        }
      };
    }
  };
};
var anvilLoadStateJsonRpcProcedure = (client) => {
  return async (request) => {
    const loadStateRequest = (
      /** @type {import('./AnvilJsonRpcRequest.js').AnvilLoadStateJsonRpcRequest}*/
      request
    );
    const vm = await client.getVm();
    return Promise.all(
      Object.entries(loadStateRequest.params[0].state).map(([address$1, rlpEncodedAccount]) => {
        const rlpBytes = utils.hexToBytes(rlpEncodedAccount);
        const decoded = utils.fromRlp(rlpBytes);
        if (!Array.isArray(decoded) || decoded.length !== 4) {
          throw new Error("Invalid RLP serialized account");
        }
        const [nonce, balance, storageRoot, codeHash] = decoded;
        const account = utils.createAccount({
          nonce,
          balance,
          storageRoot,
          codeHash
        });
        return vm.stateManager.putAccount(address.createAddress(address$1), account);
      })
    ).then(() => {
      const response = {
        jsonrpc: "2.0",
        method: loadStateRequest.method,
        result: null,
        ...loadStateRequest.id ? { id: loadStateRequest.id } : {}
      };
      return response;
    }).catch((e) => {
      const response = {
        jsonrpc: "2.0",
        method: loadStateRequest.method,
        ...loadStateRequest.id ? { id: loadStateRequest.id } : {},
        error: {
          // TODO use @tevm/errors
          code: (
            /** @type any*/
            -32602
          ),
          message: e.message
        }
      };
      return response;
    });
  };
};
var anvilResetJsonRpcProcedure = (node) => {
  return async (request) => {
    const filters = node.getFilters();
    filters.forEach((filter) => {
      node.removeFilter(filter.id);
    });
    node.setImpersonatedAccount(void 0);
    const txPool = await node.getTxPool();
    const txs = await txPool.txsByPriceAndNonce();
    txs.forEach((tx) => {
      txPool.removeByHash(viem.bytesToHex(tx.hash()));
    });
    const vm = await node.getVm();
    const newStateManager = vm.stateManager.shallowCopy();
    const newBlockchain = vm.blockchain.shallowCopy();
    const forkedBlock = vm.blockchain.blocksByTag.get("forked");
    if (forkedBlock) {
      await newBlockchain.putBlock(forkedBlock);
    }
    vm.stateManager = /** @type {any}*/
    newStateManager;
    vm.evm.stateManager = /** @type {any}*/
    newStateManager;
    vm.blockchain = newBlockchain;
    vm.evm.blockchain = newBlockchain;
    const receiptManager$1 = await node.getReceiptsManager();
    receiptManager$1.mapDb = receiptManager.createMapDb({ cache: /* @__PURE__ */ new Map() });
    receiptManager$1.chain = newBlockchain;
    return {
      result: null,
      method: request.method,
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};

// src/anvil/anvilSetBalanceProcedure.js
var anvilSetBalanceJsonRpcProcedure = (client) => {
  return async (request) => {
    const balanceResult = await setAccountProcedure(client)({
      jsonrpc: request.jsonrpc,
      method: "tevm_setAccount",
      params: [
        {
          address: request.params[0],
          balance: request.params[1]
        }
      ],
      ...request.id ? { id: request.id } : {}
    });
    if (balanceResult.error) {
      return {
        jsonrpc: "2.0",
        method: request.method,
        error: (
          /** @type {any}*/
          balanceResult.error
        ),
        ...request.id !== void 0 ? { id: request.id } : {}
      };
    }
    return {
      jsonrpc: "2.0",
      method: request.method,
      result: null,
      ...request.id !== void 0 ? { id: request.id } : {}
    };
  };
};
var anvilSetChainIdJsonRpcProcedure = (client) => {
  return async (request) => {
    const chainId = utils.hexToNumber(request.params[0]);
    if (!Number.isInteger(chainId) || chainId <= 0) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: (
            /** @type any*/
            -32602
          ),
          message: `Invalid id ${chainId}. Must be a positive integer.`
        }
      };
    }
    const err = new errors.MethodNotSupportedError(
      "UnsupportedMethodError: tevm_contract is not supported. Encode the contract arguments and use tevm_call instead."
    );
    client.logger.error(err);
    return (
      /**@type any*/
      {
        id: (
          /** @type any*/
          request.id
        ),
        jsonrpc: "2.0",
        error: {
          code: err._tag,
          message: err.message
        }
      }
    );
  };
};

// src/anvil/anvilSetCodeProcedure.js
var anvilSetCodeJsonRpcProcedure = (client) => {
  return async (request) => {
    const result = await setAccountProcedure(client)({
      jsonrpc: request.jsonrpc,
      method: "tevm_setAccount",
      params: [{ address: request.params[0], deployedBytecode: request.params[1] }],
      ...request.id ? { id: request.id } : {}
    });
    if (result.error) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: (
            /** @type any*/
            -32602
          ),
          message: result.error.message
        }
      };
    }
    return {
      ...request.id ? { id: request.id } : {},
      method: request.method,
      jsonrpc: request.jsonrpc,
      result: null
    };
  };
};
var anvilSetCoinbaseJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const currentBlock = await vm.blockchain.getCanonicalHeadBlock();
    const coinbase = utils.getAddress(request.params[0]);
    const newHeader = block.BlockHeader.fromHeaderData(
      {
        ...currentBlock.header.raw(),
        coinbase
      },
      {
        common: vm.common,
        freeze: false,
        setHardfork: false
      }
    );
    const newBlock = block.Block.fromBlockData(
      /** @type {any}*/
      {
        ...currentBlock,
        withdrawals: currentBlock.withdrawals,
        header: newHeader
      },
      {
        common: vm.common,
        freeze: false,
        setHardfork: false
      }
    );
    await vm.blockchain.putBlock(newBlock);
    return {
      method: request.method,
      result: coinbase,
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};

// src/anvil/anvilSetNonceProcedure.js
var anvilSetNonceJsonRpcProcedure = (client) => {
  return async (request) => {
    const balanceResult = await setAccountProcedure(client)({
      jsonrpc: request.jsonrpc,
      method: "tevm_setAccount",
      params: [
        {
          address: request.params[0],
          nonce: request.params[1]
        }
      ],
      ...request.id ? { id: request.id } : {}
    });
    if (balanceResult.error) {
      return {
        jsonrpc: "2.0",
        method: request.method,
        error: (
          /** @type {any}*/
          balanceResult.error
        ),
        ...request.id !== void 0 ? { id: request.id } : {}
      };
    }
    return {
      jsonrpc: "2.0",
      method: request.method,
      result: null,
      ...request.id !== void 0 ? { id: request.id } : {}
    };
  };
};

// src/anvil/anvilStopImpersonatingAccountProcedure.js
var anvilStopImpersonatingAccountJsonRpcProcedure = (client) => {
  return async (request) => {
    client.setImpersonatedAccount(void 0);
    return {
      jsonrpc: "2.0",
      method: request.method,
      result: null,
      ...request.id ? { id: request.id } : {}
    };
  };
};
var deployHandler = (client, { throwOnFail: throwOnFailDefault = true } = {}) => async (params) => {
  client.logger.debug({ params }, "deployHandler called with params");
  let deployData;
  try {
    deployData = utils.encodeDeployData(
      /** @type {any} */
      {
        abi: params.abi,
        bytecode: params.bytecode,
        args: params.args
      }
    );
  } catch (e) {
    client.logger.debug(e, "deployHandler: Unable to encode the abi, functionName, and args into hex data");
    const cause = (
      /** @type {Error}*/
      e
    );
    const err = new errors.InvalidRequestError(cause.message, { cause });
    return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, {
      /**
       * @type {import('@tevm/utils').Hex}
       */
      rawData: "0x",
      executionGasUsed: 0n,
      errors: [err]
    });
  }
  client.logger.debug({ deployData }, "deployHandler: Encoded abi bytecode and args into hex data to execute call");
  const result = await callHandler2(client, {
    throwOnFail: throwOnFailDefault
  })({
    ...params,
    // Unlike most calls deployments default to true
    createTransaction: params.createTransaction !== void 0 ? params.createTransaction : true,
    data: deployData,
    throwOnFail: false
  });
  if (result.errors && result.errors.length > 0) {
    result.errors = result.errors.map((err) => {
      if (utils.isHex(err.message) && err instanceof errors.RevertError) {
        try {
          client.logger.debug(err, "contractHandler: Contract revert error. Decoding the error");
          const decodedError = utils.decodeErrorResult(
            /** @type {any} */
            {
              abi: params.abi,
              data: err.message,
              functionName: "constructor"
            }
          );
          const message = `Revert: ${decodedError.errorName} ${JSON.stringify(decodedError)}`;
          client.logger.debug({ message }, "Revert message decoded");
          return new errors.RevertError(message, { cause: (
            /** @type any*/
            err
          ) });
        } catch (e) {
          client.logger.warn(e, "Unable to decode revert data");
          return err;
        }
      }
      return err;
    });
    client.logger.debug(result.errors, "contractHandler: Execution errors");
    return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, result);
  }
  return maybeThrowOnFail(params.throwOnFail ?? throwOnFailDefault, result);
};

// src/debug/DebugParams.ts
var debugTraceStateFilters = [
  "blockchain",
  "blockchain.blocksByNumber",
  "blockchain.initOptions",
  "evm",
  "evm.opcodes",
  "evm.precompiles",
  "evm.common",
  "evm.common.eips",
  "evm.common.hardfork",
  "evm.common.consensus",
  "node",
  "node.status",
  "node.mode",
  "node.miningConfig",
  "node.filters",
  "node.impersonatedAccount",
  "pool",
  "pool.pool",
  "pool.txsByHash",
  "pool.txsByNonce",
  "pool.txsInNonceOrder",
  "pool.txsInPool",
  "stateManager",
  "stateManager.storage",
  "stateManager.stateRoots"
];
var serializeTraceResult = (traceResult) => {
  if ("structLogs" in traceResult) {
    return (
      /** @type {any} */
      {
        failed: traceResult.failed,
        gas: utils.numberToHex(traceResult.gas),
        returnValue: traceResult.returnValue,
        structLogs: traceResult.structLogs.map((log) => ({
          ...log,
          gas: utils.numberToHex(log.gas),
          gasCost: utils.numberToHex(log.gasCost)
        }))
      }
    );
  }
  return (
    /** @type {any} */
    traceResult
  );
};
var runCallWithCallTrace = async (vm, logger, params, lazilyRun = false) => {
  const callStack = [];
  let rootTrace = null;
  vm.evm.events?.on("beforeMessage", async (message, next) => {
    logger.debug(message, "runCallWithCallTrace: beforeMessage event");
    let traceType = "CALL";
    if (message.to === void 0) {
      traceType = message.salt !== void 0 ? "CREATE2" : "CREATE";
    } else if (message.delegatecall) {
      traceType = "DELEGATECALL";
    } else if (message.isStatic) {
      traceType = "STATICCALL";
    }
    const traceCall = {
      type: traceType,
      from: message.caller.toString(),
      to: message.to ? message.to.toString() : `0x${"0".repeat(40)}`,
      value: message.value ?? 0n,
      gas: message.gasLimit,
      gasUsed: 0n,
      input: utils.bytesToHex(message.data ?? new Uint8Array(0)),
      output: "0x",
      calls: []
    };
    if (message.depth === 0) {
      rootTrace = {
        type: traceCall.type,
        from: traceCall.from,
        to: traceCall.to,
        value: traceCall.value ?? 0n,
        gas: traceCall.gas ?? 0n,
        gasUsed: traceCall.gasUsed ?? 0n,
        input: traceCall.input,
        output: traceCall.output,
        calls: []
      };
      callStack.push(
        /** @type {import('../common/TraceCall.js').TraceCall} */
        rootTrace
      );
    } else {
      const parent = callStack[callStack.length - 1];
      if (parent) {
        if (!parent.calls) {
          parent.calls = [];
        }
        parent.calls.push(traceCall);
        callStack.push(traceCall);
      }
    }
    next?.();
  });
  vm.evm.events?.on("afterMessage", async (result, next) => {
    logger.debug(result, "runCallWithCallTrace: afterMessage event");
    const currentCall = callStack.pop();
    if (!currentCall) {
      logger.warn("runCallWithCallTrace: no current call in stack for afterMessage");
      next?.();
      return;
    }
    currentCall.gasUsed = result.execResult.executionGasUsed ?? 0n;
    if (result.execResult?.returnValue) {
      currentCall.output = utils.bytesToHex(result.execResult.returnValue);
    }
    if (result.createdAddress && (currentCall.type === "CREATE" || currentCall.type === "CREATE2")) {
      currentCall.to = result.createdAddress.toString();
    }
    if (result.execResult?.exceptionError) {
      currentCall.error = result.execResult.exceptionError.error;
      if (result.execResult.exceptionError.error.includes("revert")) {
        currentCall.revertReason = decodeRevertReason(utils.bytesToHex(result.execResult.returnValue));
      }
      console.log(currentCall);
    }
    next?.();
  });
  if (lazilyRun) {
    return (
      /** @type {any} */
      { trace: rootTrace }
    );
  }
  const runCallResult = await vm.evm.runCall(params);
  logger.debug(runCallResult, "runCallWithCallTrace: evm run call complete");
  if (!rootTrace) {
    throw new errors.DefensiveNullCheckError("Expected root trace to be created during call execution");
  }
  rootTrace = /** @type {import('../common/CallTraceResult.js').CallTraceResult} */
  rootTrace;
  rootTrace.gasUsed = runCallResult.execResult.executionGasUsed;
  if (runCallResult.execResult.returnValue) {
    rootTrace.output = utils.bytesToHex(runCallResult.execResult.returnValue);
  }
  if (runCallResult.execResult.exceptionError) {
    const rootTraceWithError = (
      /** @type {any} */
      rootTrace
    );
    rootTraceWithError.error = runCallResult.execResult.exceptionError.error || runCallResult.execResult.exceptionError.toString();
    if (runCallResult.execResult.exceptionError.error?.includes("revert")) {
      rootTraceWithError.revertReason = decodeRevertReason(utils.bytesToHex(runCallResult.execResult.returnValue));
    }
  }
  return {
    ...runCallResult,
    trace: rootTrace
  };
};
var runCallWithFourbyteTrace = async (vm, logger, params, lazilyRun = false) => {
  const selectors = {};
  const calldatas = {};
  const extractSelectorAndSize = (data) => {
    if (data.length >= 4) {
      const selector = utils.bytesToHex(data.slice(0, 4));
      const calldata = data.slice(4);
      const calldataSize = calldata.length;
      const key = (
        /** @type {SelectorAndSizeKey} */
        `${selector}-${calldataSize}`
      );
      return { key, selector, calldata: utils.bytesToHex(calldata), calldataSize };
    }
    return null;
  };
  vm.evm.events?.on("beforeMessage", async (message, next) => {
    logger.debug(message, "runCallWithFourbyteTrace: beforeMessage event");
    if (message.to && message.data && message.data.length >= 4) {
      const result = extractSelectorAndSize(message.data);
      if (result) {
        selectors[result.key] = (selectors[result.key] ?? 0) + 1;
        const contractAddress = utils.getAddress(message.to.toString());
        calldatas[contractAddress] = {
          ...calldatas[contractAddress] ?? {},
          [result.selector]: [...calldatas[contractAddress]?.[result.selector] ?? [], result.calldata]
        };
        logger.debug(
          {
            contractAddress: message.to.toString(),
            key: result.key,
            selector: result.selector,
            calldata: result.calldata,
            calldataSize: result.calldataSize,
            count: selectors[result.key]
          },
          "runCallWithFourbyteTrace: collected selector with calldata size"
        );
      }
    }
    next?.();
  });
  if (lazilyRun) {
    return (
      /** @type {any} */
      { trace: selectors }
    );
  }
  const runCallResult = await vm.evm.runCall(params);
  logger.debug(runCallResult, "runCallWithFourbyteTrace: evm run call complete");
  logger.debug(selectors, "runCallWithFourbyteTrace: collected selectors");
  return {
    ...runCallResult,
    trace: {
      ...selectors,
      ...calldatas
    }
  };
};
var runCallWithPrestateTrace = async (client, evmInput, diffMode = (
  /** @type {TDiffMode} */
  false
)) => {
  const { logger, getVm } = client;
  const vm = await getVm();
  await vm.evm.journal.cleanup();
  const tx = await evmInputToImpersonatedTx(client)(evmInput);
  logger.debug(evmInput, "runCallWithPrestateTrace: executing call using runTx");
  const runTxResult = await vm.runTx({
    tx,
    skipHardForkValidation: true,
    skipBlockGasLimitValidation: true,
    reportAccessList: true,
    reportPreimages: true,
    preserveJournal: true
  });
  const { accessList: _accessList, preimages: _preimages } = runTxResult;
  if (!_accessList) throw new errors.DefensiveNullCheckError("Expected access list to be defined");
  const preimages = Array.from(_preimages?.values() ?? []).map((v) => utils.bytesToHex(v));
  const accessList = /* @__PURE__ */ new Map();
  for (const { address, storageKeys } of _accessList) {
    accessList.set(`0x${address}`, new Set(storageKeys.map((s) => (
      /** @type {import('@tevm/utils').Hex} */
      `0x${s}`
    ))));
  }
  const postState = {};
  if (diffMode) {
    for (const address$1 of preimages) {
      try {
        const ethAddress = address.createAddress(address$1);
        const slots = accessList.get(address$1) ?? /* @__PURE__ */ new Set();
        const accountState = await captureAccountState(vm, logger, ethAddress, slots);
        if (accountState) postState[address$1] = accountState;
      } catch (err) {
        logger.error(err, `Error capturing post-state for ${address$1}`);
      }
    }
  }
  vm.evm.journal.revert();
  const preState = {};
  for (const address$1 of preimages) {
    try {
      const ethAddress = address.createAddress(address$1);
      const slots = accessList.get(address$1) ?? /* @__PURE__ */ new Set();
      const accountState = await captureAccountState(vm, logger, ethAddress, slots);
      if (accountState) preState[address$1] = accountState;
    } catch (err) {
      logger.error(err, `Error capturing pre-state for ${address$1}`);
    }
  }
  return {
    ...runTxResult,
    // Include both pre and post state only in diffMode
    trace: (
      /** @type {any} */
      diffMode ? formatDiffResult(preState, postState) : preState
    )
  };
};
var captureAccountState = async (vm, logger, address, slots = /* @__PURE__ */ new Set()) => {
  try {
    const account = await vm.stateManager.getAccount(address);
    if (!account) return void 0;
    const code = await vm.stateManager.getCode(address);
    const storage = {};
    for (const slotHex of slots) {
      try {
        const slotKey = utils.hexToBytes(slotHex);
        const value = await vm.stateManager.getStorage(address, slotKey);
        storage[slotHex] = utils.bytesToHex(value);
      } catch (err) {
        logger.error(err, `Error getting storage at slot ${slotHex} for account ${address.toString()}`);
      }
    }
    return {
      storage,
      balance: utils.toHex(account.balance),
      nonce: Number(account.nonce),
      code: code && code.length > 0 ? utils.bytesToHex(code) : "0x"
    };
  } catch (err) {
    logger.error(err, `Error capturing state for account ${address.toString()}`);
    return void 0;
  }
};
var formatDiffResult = (preState, postState) => {
  const postDiff = {};
  for (const address of Object.keys(postState)) {
    const addressHex = (
      /** @type {import('@tevm/utils').Hex} */
      address
    );
    const pre = preState[addressHex];
    const post = postState[addressHex];
    if (!post) continue;
    const allSlots = /* @__PURE__ */ new Set([...Object.keys(pre?.storage ?? {}), ...Object.keys(post.storage ?? {})]);
    let storageDiff = {};
    for (const slot of allSlots) {
      const slotHex = (
        /** @type {import('@tevm/utils').Hex} */
        slot
      );
      const preValue = pre?.storage?.[slotHex] ?? "0x0";
      const postValue = post.storage?.[slotHex] ?? "0x0";
      storageDiff = {
        ...storageDiff,
        ...preValue !== postValue ? { [slotHex]: postValue } : {}
      };
    }
    const postDiffAccount = {
      ...pre !== void 0 && post.balance !== void 0 && pre.balance !== post.balance ? { balance: post.balance } : {},
      ...pre !== void 0 && post.nonce !== void 0 && pre.nonce !== post.nonce ? { nonce: post.nonce } : {},
      ...pre !== void 0 && post.code !== void 0 && pre.code !== post.code ? { code: post.code } : {},
      ...Object.keys(storageDiff).length > 0 ? { storage: storageDiff } : {}
    };
    if (Object.keys(postDiffAccount).length > 0) postDiff[addressHex] = postDiffAccount;
  }
  return {
    pre: preState,
    post: postDiff
  };
};

// src/debug/traceCallHandler.js
var traceCallHandler = (client) => (
  /**
   * @template {'callTracer' | 'prestateTracer' | '4byteTracer'} TTracer
   * @template {boolean} TDiffMode
   * @param {import('./DebugParams.js').DebugTraceCallParams<TTracer, TDiffMode>} params
   * @returns {Promise<import('./DebugResult.js').DebugTraceCallResult<TTracer, TDiffMode>>}
   */
  (params) => {
    const { logger, getVm } = client;
    logger.debug(params, "traceCallHandler: executing trace call with params");
    const callParams = {
      ...params.from !== void 0 ? {
        origin: address.createAddress(params.from),
        caller: address.createAddress(params.from)
      } : {},
      ...params.data !== void 0 ? { data: utils.hexToBytes(params.data) } : {},
      ...params.to ? { to: address.createAddress(params.to) } : {},
      ...params.gasPrice ? { gasPrice: params.gasPrice } : {},
      ...params.gas ? { gasLimit: params.gas } : {},
      ...params.value ? { value: params.value } : {}
    };
    if (params.tracer === "prestateTracer") {
      const diffMode = params.tracerConfig?.diffMode === true;
      logger.debug({ diffMode }, "traceCallHandler: using prestateTracer");
      return getVm().then((vm) => vm.deepCopy()).then((vm) => runCallWithPrestateTrace({ ...client, getVm: () => Promise.resolve(vm) }, callParams, diffMode)).then((res) => (
        /** @type {any} */
        res.trace
      ));
    }
    if (params.tracer === "callTracer") {
      return getVm().then((vm) => vm.deepCopy()).then((vm) => runCallWithCallTrace(vm, logger, callParams)).then((res) => (
        /** @type {any} */
        res.trace
      ));
    }
    if (params.tracer === "4byteTracer") {
      logger.debug("traceCallHandler: using 4byteTracer");
      return getVm().then((vm) => vm.deepCopy()).then((vm) => runCallWithFourbyteTrace(vm, logger, callParams)).then((res) => (
        /** @type {any} */
        res.trace
      ));
    }
    return getVm().then((vm) => vm.deepCopy()).then((vm) => runCallWithTrace(vm, logger, callParams)).then((res) => (
      /** @type {any} */
      res.trace
    ));
  }
);

// src/debug/debugTraceBlockProcedure.js
var debugTraceBlockJsonRpcProcedure = (client) => {
  return async (request) => {
    const { tracer, timeout, tracerConfig, block: blockParam, blockTag, blockHash, blockNumber } = request.params[0];
    if (timeout !== void 0) {
      client.logger.warn("Warning: timeout is currently respected param of debug_traceBlock");
    }
    client.logger.debug({ blockTag, tracer, tracerConfig }, "debug_traceBlock: executing with params");
    let vm = await client.getVm();
    const block = await vm.blockchain.getBlockByTag(blockParam ?? blockTag ?? blockHash ?? blockNumber ?? "latest");
    if (block.transactions.length === 0) {
      return {
        jsonrpc: "2.0",
        method: request.method,
        ...request.id !== void 0 ? { id: request.id } : {},
        result: (
          /** @type {any} */
          []
        )
      };
    }
    const parentBlock = await vm.blockchain.getBlock(block.header.parentHash);
    const hasStateRoot = await vm.stateManager.hasStateRoot(parentBlock.header.stateRoot);
    if (!hasStateRoot && client.forkTransport) {
      vm = await forkAndCacheBlock(client, parentBlock);
    } else if (!hasStateRoot) {
      return {
        jsonrpc: "2.0",
        method: request.method,
        ...request.id !== void 0 ? { id: request.id } : {},
        error: {
          code: "-32602",
          message: "State root not available for parent block"
        }
      };
    }
    const vmClone = await vm.deepCopy();
    await vmClone.stateManager.setStateRoot(parentBlock.header.stateRoot);
    const traceResults = [];
    for (let i = 0; i < block.transactions.length; i++) {
      const blockTx = block.transactions[i];
      if (!blockTx) continue;
      const impersonatedTx = tx.createImpersonatedTx(
        {
          ...blockTx,
          gasPrice: null,
          impersonatedAddress: address.createAddress(blockTx.getSenderAddress())
        },
        {
          freeze: false,
          common: vmClone.common.ethjsCommon,
          allowUnlimitedInitCodeSize: true
        }
      );
      const txParams = impersonatedTx.toJSON();
      const traceResult = await traceCallHandler({ ...client, getVm: () => Promise.resolve(vmClone) })({
        tracer,
        from: impersonatedTx.getSenderAddress().toString(),
        blockTag: utils.bytesToHex(block.header.hash()),
        ...txParams.to !== void 0 ? { to: txParams.to } : {},
        ...txParams.gasLimit !== void 0 ? { gas: utils.hexToBigInt(txParams.gasLimit) } : {},
        ...txParams.gasPrice !== void 0 ? { gasPrice: utils.hexToBigInt(txParams.gasPrice) } : {},
        ...txParams.value !== void 0 ? { value: utils.hexToBigInt(txParams.value) } : {},
        ...txParams.data !== void 0 ? { data: txParams.data } : {},
        ...timeout !== void 0 ? { timeout } : {},
        .../** @type {any} */
        tracerConfig !== void 0 ? { tracerConfig } : {}
      });
      traceResults.push({
        txHash: utils.bytesToHex(blockTx.hash()),
        txIndex: i,
        result: traceResult
      });
      await vmClone.runTx({
        block,
        skipNonce: true,
        skipBalance: true,
        skipHardForkValidation: true,
        skipBlockGasLimitValidation: true,
        tx: impersonatedTx
      });
    }
    return {
      jsonrpc: "2.0",
      method: request.method,
      result: (
        /** @type {any} */
        traceResults.map((trace) => ({ ...trace, result: serializeTraceResult(trace.result) }))
      ),
      ...request.id !== void 0 ? { id: request.id } : {}
    };
  };
};
var debugTraceCallJsonRpcProcedure = (client) => {
  return async (request) => {
    const { blockTag, tracer, to, gas, data, from, value, timeout, gasPrice, tracerConfig } = request.params[0];
    if (timeout !== void 0) {
      client.logger.warn("Warning: timeout is currently respected param of debug_traceCall");
    }
    const traceResult = await traceCallHandler(client)({
      tracer,
      ...to !== void 0 ? { to } : {},
      ...from !== void 0 ? { from } : {},
      ...gas !== void 0 ? { gas: typeof gas === "bigint" ? gas : utils.hexToBigInt(gas) } : {},
      ...gasPrice !== void 0 ? { gasPrice: typeof gasPrice === "bigint" ? gasPrice : utils.hexToBigInt(gasPrice) } : {},
      ...value !== void 0 ? { value: typeof value === "bigint" ? value : utils.hexToBigInt(value) } : {},
      ...data !== void 0 ? { data } : {},
      ...blockTag !== void 0 ? { blockTag } : {},
      ...timeout !== void 0 ? { timeout } : {},
      .../** @type {any} */
      tracerConfig !== void 0 ? { tracerConfig } : {}
    });
    return {
      method: request.method,
      result: (
        /** @type {any} */
        serializeTraceResult(traceResult)
      ),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};

// src/debug/debugTraceStateProcedure.js
var debugTraceStateJsonRpcProcedure = (client) => {
  return async (request) => {
    const { filters: _filters, timeout } = request.params[0];
    if (timeout !== void 0) {
      client.logger.warn("Warning: timeout is currently respected param of debug_traceState");
    }
    const filters = _filters === void 0 || _filters.length === 0 ? debugTraceStateFilters : _filters;
    const trace = {};
    const vm = await client.getVm();
    const txPool = await client.getTxPool();
    if (filters.includes("blockchain") || filters.includes("blockchain.blocksByNumber")) {
      trace["blockchain"] = { blocksByNumber: vm.blockchain.blocksByNumber };
    }
    if (filters.includes("blockchain") || filters.includes("blockchain.initOptions")) {
      trace["blockchain"] = {
        ...trace["blockchain"] ?? {},
        initOptions: vm.blockchain.options
      };
    }
    if (filters.includes("evm") || filters.includes("evm.opcodes")) {
      trace["evm"] = { opcodes: vm.evm.getActiveOpcodes() };
    }
    if (filters.includes("evm") || filters.includes("evm.precompiles")) {
      trace["evm"] = {
        ...trace["evm"] ?? {},
        precompiles: vm.evm.precompiles
      };
    }
    if (filters.includes("evm") || filters.includes("evm.common") || filters.includes("evm.common.eips")) {
      trace["evm"] = {
        ...trace["evm"] ?? {},
        common: {
          eips: vm.evm.common.eips()
        }
      };
    }
    if (filters.includes("evm") || filters.includes("evm.common") || filters.includes("evm.common.hardfork")) {
      trace["evm"] = {
        ...trace["evm"] ?? {},
        common: {
          ...trace["evm"]?.common ?? {},
          hardfork: vm.evm.common.hardfork()
        }
      };
    }
    if (filters.includes("evm") || filters.includes("evm.common") || filters.includes("evm.common.consensus")) {
      trace["evm"] = {
        ...trace["evm"] ?? {},
        common: {
          ...trace["evm"]?.common ?? {},
          consensus: {
            algorithm: vm.evm.common.consensusAlgorithm(),
            type: vm.evm.common.consensusType()
          }
        }
      };
    }
    if (filters.includes("node") || filters.includes("node.status")) {
      trace["node"] = {
        status: client.status
      };
    }
    if (filters.includes("node") || filters.includes("node.mode")) {
      trace["node"] = {
        ...trace["node"] ?? {},
        mode: client.mode
      };
    }
    if (filters.includes("node") || filters.includes("node.miningConfig")) {
      trace["node"] = {
        ...trace["node"] ?? {},
        miningConfig: client.miningConfig
      };
    }
    if (filters.includes("node") || filters.includes("node.filters")) {
      trace["node"] = {
        ...trace["node"] ?? {},
        filters: client.getFilters()
      };
    }
    if (filters.includes("node") || filters.includes("node.impersonatedAccount")) {
      trace["node"] = {
        ...trace["node"] ?? {},
        impersonatedAccount: client.getImpersonatedAccount()
      };
    }
    if (filters.includes("pool") || filters.includes("pool.pool")) {
      trace["pool"] = {
        pool: txPool.pool
      };
    }
    if (filters.includes("pool") || filters.includes("pool.txsByHash")) {
      trace["pool"] = {
        ...trace["pool"] ?? {},
        txsByHash: txPool.txsByHash
      };
    }
    if (filters.includes("pool") || filters.includes("pool.txsByNonce")) {
      trace["pool"] = {
        ...trace["pool"] ?? {},
        txsByNonce: txPool.txsByNonce
      };
    }
    if (filters.includes("pool") || filters.includes("pool.txsInNonceOrder")) {
      trace["pool"] = {
        ...trace["pool"] ?? {},
        txsInNonceOrder: txPool.txsInNonceOrder
      };
    }
    if (filters.includes("pool") || filters.includes("pool.txsInPool")) {
      trace["pool"] = {
        ...trace["pool"] ?? {},
        txsInPool: txPool.txsInPool
      };
    }
    if (filters.includes("stateManager") || filters.includes("stateManager.storage")) {
      trace["stateManager"] = {
        ...trace["stateManager"] ?? {},
        storage: await vm.stateManager.dumpCanonicalGenesis()
      };
    }
    if (filters.includes("stateManager") || filters.includes("stateManager.stateRoots")) {
      trace["stateManager"] = {
        ...trace["stateManager"] ?? {},
        stateRoots: vm.stateManager._baseState.stateRoots
      };
    }
    return {
      method: request.method,
      result: (
        /** @type {any} */
        trace
      ),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};

// src/eth/blockNumberHandler.js
var blockNumberHandler = (client) => async () => {
  const vm = await client.getVm();
  return vm.blockchain.getCanonicalHeadBlock().then((block) => block.header.number);
};

// src/eth/blockNumberProcedure.js
var blockNumberProcedure = (client) => async (req) => ({
  ...req.id ? { id: req.id } : {},
  jsonrpc: "2.0",
  method: req.method,
  result: await blockNumberHandler(client)({}).then(utils.numberToHex)
});

// src/eth/chainIdHandler.js
var chainIdHandler = (client) => async () => {
  const { common } = await client.getVm();
  return BigInt(common.id);
};
var chainIdProcedure = (baseClient) => async (req) => ({
  ...req.id ? { id: req.id } : {},
  jsonrpc: "2.0",
  method: req.method,
  // TODO pass in a client instead
  result: await chainIdHandler(baseClient)({}).then(utils.numberToHex)
});
var ethBlobBaseFeeJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const headBlock = await vm.blockchain.getCanonicalHeadBlock();
    return {
      result: utils.numberToHex(headBlock.header.calcNextBlobGasPrice()),
      jsonrpc: "2.0",
      method: request.method,
      ...request.id ? { id: request.id } : {}
    };
  };
};

// src/eth/ethCallProcedure.js
var ethCallProcedure = (client) => async (req) => {
  const [tx, blockTag, stateOverrideSet, blockOverrideSet] = req.params;
  const { data, from, to, gas, gasPrice, value } = tx;
  const response = await callProcedure(client)({
    ...req.id !== void 0 ? { id: req.id } : {},
    jsonrpc: req.jsonrpc,
    method: "tevm_call",
    params: [
      {
        ...gasPrice !== void 0 ? { gasPrice } : {},
        ...data !== void 0 ? { data } : {},
        ...gas !== void 0 ? { gas } : {},
        ...value !== void 0 ? { value } : {},
        ...to !== void 0 ? { to } : {},
        ...from !== void 0 ? { from } : {},
        ...blockTag !== void 0 ? { blockTag } : {},
        addToBlockchain: false
      },
      stateOverrideSet,
      blockOverrideSet
    ]
  });
  if (!response.result) {
    return {
      jsonrpc: req.jsonrpc,
      method: "eth_call",
      error: response.error,
      ...req.id !== void 0 ? { id: req.id } : {}
    };
  }
  return {
    jsonrpc: req.jsonrpc,
    method: "eth_call",
    result: response.result.rawData,
    ...req.id !== void 0 ? { id: req.id } : {}
  };
};

// src/eth/ethCoinbaseProcedure.js
var ethCoinbaseJsonRpcProcedure = (client) => {
  return async (request) => {
    return {
      ...request.id ? { id: request.id } : {},
      method: request.method,
      jsonrpc: request.jsonrpc,
      // same default as hardhat
      result: await client.getVm().then((vm) => vm.blockchain.getCanonicalHeadBlock()).then((block) => (
        /** @type {import('@tevm/utils').Address}*/
        block.header.coinbase.toString()
      ))
    };
  };
};

// src/eth/ethEstimateGasProcedure.js
var ethEstimateGasJsonRpcProcedure = (client) => {
  return async (request) => {
    const estimateGasRequest = (
      /** @type {import('./EthJsonRpcRequest.js').EthEstimateGasJsonRpcRequest}*/
      request
    );
    const [_params, blockTag, stateOverrides, blockOverrides] = estimateGasRequest.params;
    const getParams = () => {
      const params2 = [
        {
          ..._params,
          ...blockTag !== void 0 ? { blockTag } : {}
        }
      ];
      if (blockOverrides !== void 0) {
        params2.push(stateOverrides ?? {}, blockOverrides);
      }
      if (stateOverrides !== void 0) {
        params2.push(...params2, stateOverrides);
      }
      return params2;
    };
    const [baseParams, ...params] = getParams();
    const callResult = await callProcedure(client)({
      ...estimateGasRequest,
      params: [
        {
          ...baseParams,
          addToBlockchain: false
        },
        ...params
      ],
      method: "tevm_call"
    });
    if (callResult.error || !callResult.result) {
      return {
        ...callResult,
        method: estimateGasRequest.method
      };
    }
    return {
      method: estimateGasRequest.method,
      result: callResult.result.totalGasSpent ?? callResult.result.executionGasUsed,
      jsonrpc: "2.0",
      ...estimateGasRequest.id ? { id: estimateGasRequest.id } : {}
    };
  };
};
var txToJsonRpcTx = (tx, block, txIndex) => {
  const txJSON = tx.toJSON();
  return (
    /** @type {import('../common/TransactionResult.js').TransactionResult} */
    {
      blockHash: utils.bytesToHex(block.hash()),
      blockNumber: utils.numberToHex(block.header.number),
      from: (
        /** @type {import('@tevm/utils').Address}*/
        tx.getSenderAddress().toString()
      ),
      gas: (
        /** @type {import('@tevm/utils').Hex} **/
        txJSON.gasLimit
      ),
      gasPrice: (
        /** @type {import('@tevm/utils').Hex}*/
        txJSON.gasPrice ?? txJSON.maxFeePerGas
      ),
      maxFeePerGas: txJSON.maxFeePerGas,
      maxPriorityFeePerGas: txJSON.maxPriorityFeePerGas,
      type: utils.numberToHex(tx.type),
      ...txJSON.accessList !== void 0 ? { accessList: txJSON.accessList } : {},
      hash: utils.bytesToHex(tx.hash()),
      input: (
        /** @type {import('@tevm/utils').Hex} */
        txJSON.data
      ),
      nonce: (
        /** @type {import('@tevm/utils').Hex}*/
        txJSON.nonce
      ),
      // these toString existed in ethereumjs but I don't think are necessary
      ...txJSON.to !== void 0 ? { to: (
        /** @type {import('@tevm/utils').Address} */
        txJSON.to.toString()
      ) } : {},
      ...txIndex !== void 0 ? { transactionIndex: utils.numberToHex(txIndex) } : {},
      ...txJSON.value !== void 0 ? { value: typeof txJSON.value === "string" ? txJSON.value : utils.numberToHex(txJSON.value) } : {},
      ..."isImpersonated" in tx ? { isImpersonated: tx.isImpersonated } : {},
      ...txJSON.v !== void 0 ? { v: txJSON.v } : {},
      ...txJSON.r !== void 0 ? { r: txJSON.r } : {},
      ...txJSON.s !== void 0 ? { s: txJSON.s } : {},
      ...txJSON.chainId !== void 0 ? { chainId: typeof txJSON.chainId === "string" ? txJSON.chainId : utils.numberToHex(txJSON.chainId) } : {},
      maxFeePerBlobGas: txJSON.maxFeePerBlobGas,
      blobVersionedHashes: txJSON.blobVersionedHashes
    }
  );
};

// src/utils/blockToJsonRpcBlock.js
var blockToJsonRpcBlock = async (block, includeTransactions) => {
  const json = block.toJSON();
  const header = (
    /** @type {import('@tevm/block').JsonHeader}*/
    json.header
  );
  const transactions = block.transactions.map(
    (tx, txIndex) => includeTransactions ? txToJsonRpcTx(tx, block, txIndex) : utils.bytesToHex(tx.hash())
  );
  const out = {
    number: (
      /** @type {import('@tevm/utils').Hex}*/
      header.number
    ),
    hash: utils.bytesToHex(block.hash()),
    parentHash: (
      /** @type {import('@tevm/utils').Hex}*/
      header.parentHash
    ),
    // TODO add this to the type
    ...{ mixHash: header.mixHash },
    nonce: (
      /** @type {import('@tevm/utils').Hex}*/
      header.nonce
    ),
    sha3Uncles: (
      /** @type {import('@tevm/utils').Hex}*/
      header.uncleHash
    ),
    logsBloom: (
      /** @type {import('@tevm/utils').Hex}*/
      header.logsBloom
    ),
    transactionsRoot: (
      /** @type {import('@tevm/utils').Hex}*/
      header.transactionsTrie
    ),
    stateRoot: (
      /** @type {import('@tevm/utils').Hex}*/
      header.stateRoot
    ),
    miner: (
      /** @type {import('@tevm/utils').Address}*/
      header.coinbase
    ),
    difficulty: (
      /** @type {import('@tevm/utils').Hex}*/
      header.difficulty
    ),
    // TODO we need to actually add this
    totalDifficulty: (
      /** @type {import('@tevm/utils').Hex}*/
      "0x0"
    ),
    extraData: (
      /** @type {import('@tevm/utils').Hex}*/
      header.extraData
    ),
    size: utils.numberToHex(utils.toBytes(JSON.stringify(json)).byteLength),
    gasLimit: (
      /** @type {import('@tevm/utils').Hex}*/
      header.gasLimit
    ),
    gasUsed: (
      /** @type {import('@tevm/utils').Hex}*/
      header.gasUsed
    ),
    timestamp: (
      /** @type {import('@tevm/utils').Hex}*/
      header.timestamp
    ),
    uncles: block.uncleHeaders.map((uh) => utils.bytesToHex(uh.hash())),
    // TODO fix this type
    transactions: (
      /** @type any*/
      transactions
    ),
    // TODO add this to the type
    ...{ baseFeePerGas: header.baseFeePerGas },
    ...{ receiptsRoot: header.receiptTrie },
    ...header.withdrawalsRoot !== void 0 ? {
      withdrawalsRoot: header.withdrawalsRoot,
      withdrawals: json.withdrawals
    } : {},
    ...header.blobGasUsed !== void 0 ? { blobGasUsed: header.blobGasUsed } : {},
    // TODO add this to the type
    ...{ requestsRoot: header.requestsRoot },
    // TODO add this to the type
    ...{ requests: block.requests?.map((req) => utils.bytesToHex(req.serialize())) },
    // TODO add this to the type
    ...{ excessBlobGas: header.excessBlobGas },
    // TODO add this to the type
    ...{ parentBeaconBlockRoot: header.parentBeaconBlockRoot }
  };
  return out;
};

// src/eth/ethGetBlockByHashProcedure.js
var ethGetBlockByHashJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const block = await vm.blockchain.getBlock(utils.hexToBytes(request.params[0]));
    const includeTransactions = request.params[1] ?? false;
    const result = await blockToJsonRpcBlock(block, includeTransactions);
    return {
      method: request.method,
      result,
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethGetBlockByNumberJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const blockTagOrNumber = request.params[0];
    const block = await (() => {
      if (blockTagOrNumber.startsWith("0x")) {
        return vm.blockchain.getBlock(utils.hexToBigInt(
          /** @type {import('@tevm/utils').Hex}*/
          blockTagOrNumber
        ));
      }
      return vm.blockchain.blocksByTag.get(
        /** @type {import('@tevm/utils').BlockTag}*/
        blockTagOrNumber
      );
    })();
    if (!block && client.forkTransport) {
      const fetcher = jsonrpc.createJsonRpcFetcher(client.forkTransport);
      const res = await fetcher.request({
        jsonrpc: "2.0",
        id: request.id ?? 1,
        method: request.method,
        params: [blockTagOrNumber, request.params[1] ?? false]
      });
      if (res.error) {
        return {
          ...request.id ? { id: request.id } : {},
          method: request.method,
          jsonrpc: request.jsonrpc,
          error: res.error
        };
      }
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        result: (
          /** @type {any}*/
          res.result
        )
      };
    }
    if (!block) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: `Invalid block tag ${blockTagOrNumber}`
        }
      };
    }
    const includeTransactions = request.params[1] ?? false;
    const result = await blockToJsonRpcBlock(block, includeTransactions);
    return {
      method: request.method,
      result,
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethGetBlockTransactionCountByHashJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const block = await vm.blockchain.getBlock(utils.hexToBytes(request.params[0]));
    const result = block.transactions.length;
    return {
      method: request.method,
      result: utils.numberToHex(result),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethGetBlockTransactionCountByNumberJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const blockTagOrNumber = request.params[0];
    const block = await (() => {
      if (blockTagOrNumber.startsWith("0x")) {
        return vm.blockchain.getBlock(utils.hexToBigInt(
          /** @type {import('@tevm/utils').Hex}*/
          blockTagOrNumber
        ));
      }
      return vm.blockchain.blocksByTag.get(
        /** @type {import('@tevm/utils').BlockTag}*/
        blockTagOrNumber
      );
    })();
    if (!block) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: `Invalid block tag ${blockTagOrNumber}`
        }
      };
    }
    const result = block.transactions.length;
    return {
      method: request.method,
      result: utils.numberToHex(result),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethGetFilterChangesProcedure = (client) => {
  return async (request) => {
    const getFilterChangesRequest = (
      /** @type {import('./EthJsonRpcRequest.js').EthGetFilterChangesJsonRpcRequest}*/
      request
    );
    const [id] = getFilterChangesRequest.params;
    const filter = client.getFilters().get(id);
    if (!filter) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32601,
          message: "Method not implemented yet"
        }
      };
    }
    switch (filter.type) {
      case "Log": {
        const { logs } = filter;
        const response = {
          ...request.id ? { id: request.id } : {},
          method: request.method,
          jsonrpc: request.jsonrpc,
          result: logs.map((log) => ({
            address: log.address,
            topics: log.topics,
            data: log.data,
            blockNumber: utils.numberToHex(log.blockNumber),
            transactionHash: log.transactionHash,
            transactionIndex: utils.numberToHex(log.transactionIndex),
            blockHash: log.blockHash,
            logIndex: utils.numberToHex(log.logIndex),
            removed: log.removed
          }))
        };
        filter.logs = [];
        return response;
      }
      case "Block": {
        const { blocks } = filter;
        const response = {
          ...request.id ? { id: request.id } : {},
          // TODO fix this type
          result: (
            /** @type {any} */
            blocks.map((block) => utils.numberToHex(block.header.number))
          ),
          method: request.method,
          jsonrpc: request.jsonrpc
        };
        filter.blocks = [];
        return response;
      }
      case "PendingTransaction": {
        const { tx } = filter;
        const response = {
          ...request.id ? { id: request.id } : {},
          // TODO fix this type
          result: (
            /** @type {any} */
            tx.map((tx2) => utils.bytesToHex(tx2.hash()))
          ),
          method: request.method,
          jsonrpc: request.jsonrpc
        };
        filter.tx = [];
        return response;
      }
      default: {
        throw new Error(
          "InternalError: Unknown filter type. This indicates a bug in tevm or potentially a typo in filter type if manually added"
        );
      }
    }
  };
};

// src/utils/isArray.js
function isArray(value) {
  return Array.isArray(value);
}
var parseBlockParam = async (blockchain, blockParam) => {
  if (typeof blockParam === "number") {
    return BigInt(blockParam);
  }
  if (typeof blockParam === "bigint") {
    return blockParam;
  }
  if (typeof blockParam === "string" && blockParam.startsWith("0x")) {
    if (blockParam.length === 66) {
      const block = await blockchain.getBlock(utils.hexToBytes(
        /** @type {import('@tevm/utils').Hex}*/
        blockParam
      ));
      return BigInt(block.header.number);
    }
    return utils.hexToBigInt(
      /** @type {import('@tevm/utils').Hex}*/
      blockParam
    );
  }
  if (blockParam === "safe") {
    const safeBlock = blockchain.blocksByTag.get("safe");
    if (safeBlock) {
      return safeBlock.header.number;
    }
    throw new errors.InvalidBlockError("safe not currently supported as block tag");
  }
  if (blockParam === "latest" || blockParam === void 0) {
    const safeBlock = blockchain.blocksByTag.get("latest");
    if (safeBlock) {
      return safeBlock.header.number;
    }
    throw new errors.InvalidBlockError("latest block does not exist on chain");
  }
  if (blockParam === "pending") {
    throw new errors.InvalidBlockError(
      "Pending not yet supported but will be in future. Consider opening an issue or reaching out on telegram if you need this feature to expediate its release"
    );
  }
  if (blockParam === "earliest") {
    return BigInt(1);
  }
  if (blockParam === "finalized") {
    throw new errors.InvalidBlockError("finalized noet yet supported for this feature");
  }
  blockchain.logger.error({ blockParam }, "Unknown block param pased to blockNumberHandler");
  throw new errors.InvalidBlockError(`Unknown block param ${blockParam} pased to blockNumberHandler`);
};

// src/eth/ethGetLogsHandler.js
var ethGetLogsHandler = (client) => async (params) => {
  client.logger.debug(params, "ethGetLogsHandler called with params");
  const vm = await client.getVm();
  const receiptsManager = await client.getReceiptsManager();
  if (params.filterParams.toBlock === "pending") {
    const mineResult = await getPendingClient(client);
    if (mineResult.errors) {
      throw mineResult.errors[0];
    }
    return ethGetLogsHandler(mineResult.pendingClient)({
      ...params,
      filterParams: { ...params.filterParams, toBlock: "latest" }
    });
  }
  const fromBlock = await vm.blockchain.getBlock(
    await parseBlockParam(vm.blockchain, params.filterParams.fromBlock ?? 0n)
  );
  const toBlock = await vm.blockchain.getBlock(
    await parseBlockParam(vm.blockchain, params.filterParams.toBlock ?? "latest")
  );
  const forkedBlock = vm.blockchain.blocksByTag.get("forked");
  const logs = [];
  const fetchFromRpc = forkedBlock && forkedBlock.header.number >= fromBlock.header.number;
  if (fetchFromRpc) {
    if (!client.forkTransport) {
      throw new viem.InternalRpcError(
        new Error(
          "InternalError: no forkUrl set on client despite a forkBlock. This should be an impossible state and indicates a bug in tevm"
        )
      );
    }
    const fetcher = jsonrpc.createJsonRpcFetcher(client.forkTransport);
    const { result: jsonRpcLogs, error } = await fetcher.request({
      jsonrpc: "2.0",
      id: 1,
      method: "eth_getLogs",
      params: [
        {
          fromBlock: utils.numberToHex(fromBlock.header.number),
          toBlock: toBlock.header.number < forkedBlock.header.number ? utils.numberToHex(toBlock.header.number) : utils.numberToHex(forkedBlock.header.number),
          address: params.filterParams.address,
          topics: params.filterParams.topics
        }
      ]
    });
    if (error) {
      throw error;
    }
    const typedLogs = (
      /**
       * @type {Array<Log> | undefined}
       */
      jsonRpcLogs ?? void 0
    );
    if (typedLogs !== void 0) {
      logs.push(
        ...typedLogs.map((log) => {
          return {
            removed: false,
            logIndex: utils.hexToBigInt(log.logIndex),
            transactionIndex: utils.hexToBigInt(log.transactionIndex),
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: utils.hexToBigInt(log.blockNumber),
            address: log.address,
            topics: log.topics,
            data: log.data
          };
        })
      );
    }
  }
  if (forkedBlock && toBlock.header.number <= forkedBlock.header.number) {
    return logs;
  }
  const cachedLogs = await receiptsManager.getLogs(
    fetchFromRpc ? (
      /** @type {import('@tevm/block').Block}*/
      forkedBlock
    ) : fromBlock,
    toBlock,
    params.filterParams.address !== void 0 ? [address.createAddress(params.filterParams.address).bytes] : [],
    // params.filterParams.topics?.map((topic) => hexToBytes(topic)),
    params.filterParams.topics?.map((topic) => isArray(topic) ? topic.map(utils.hexToBytes) : utils.hexToBytes(topic))
  );
  logs.push(
    ...cachedLogs.map(({ log, block, tx, txIndex, logIndex }) => ({
      // what does this mean?
      removed: false,
      logIndex: BigInt(logIndex),
      transactionIndex: BigInt(txIndex),
      transactionHash: utils.bytesToHex(tx.hash()),
      blockHash: utils.bytesToHex(block.hash()),
      blockNumber: block.header.number,
      address: utils.bytesToHex(log[0]),
      topics: log[1].map((topic) => utils.bytesToHex(topic)),
      data: utils.bytesToHex(log[2])
    }))
  );
  return logs;
};

// src/eth/ethGetFilterLogsProcedure.js
var ethGetFilterLogsProcedure = (client) => {
  return async (request) => {
    const filter = client.getFilters().get(request.params[0]);
    if (!filter) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: "Filter not found"
        }
      };
    }
    try {
      const ethGetLogsResult = await ethGetLogsHandler(client)({
        filterParams: {
          fromBlock: filter.logsCriteria.fromBlock?.header?.number ?? 0n,
          toBlock: filter.logsCriteria.toBlock?.header?.number ?? "latest",
          address: filter.logsCriteria.address,
          topics: filter.logsCriteria.topics
        }
      });
      const jsonRpcResult = ethGetLogsResult.map((log) => ({
        address: log.address,
        topics: [...log.topics],
        data: log.data,
        blockNumber: utils.numberToHex(log.blockNumber),
        transactionHash: log.transactionHash,
        transactionIndex: utils.numberToHex(log.transactionIndex),
        blockHash: log.blockHash,
        logIndex: utils.numberToHex(log.logIndex),
        removed: log.removed
      }));
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        result: jsonRpcResult
      };
    } catch (e) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32601,
          message: (
            /** @type {Error}*/
            e.message
          )
        }
      };
    }
  };
};
var ethGetLogsProcedure = (client) => async (req) => {
  const result = await ethGetLogsHandler(client)({
    filterParams: req.params[0]
  });
  try {
    const jsonRpcResult = result.map((log) => ({
      address: log.address,
      topics: log.topics,
      data: log.data,
      blockNumber: utils.numberToHex(log.blockNumber),
      transactionHash: log.transactionHash,
      transactionIndex: utils.numberToHex(log.transactionIndex),
      blockHash: log.blockHash,
      logIndex: utils.numberToHex(log.logIndex),
      removed: log.removed
    }));
    return {
      jsonrpc: req.jsonrpc,
      ...req.id !== void 0 ? { id: req.id } : {},
      method: req.method,
      result: jsonRpcResult
    };
  } catch (e) {
    return (
      /** @type {any}*/
      {
        jsonrpc: req.jsonrpc,
        ...req.id !== void 0 ? { id: req.id } : {},
        method: req.method,
        error: {
          code: -32e3,
          message: (
            /** @type {Error}*/
            e.message
          )
        }
      }
    );
  }
};
var ethGetTransactionByBlockHashAndIndexJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const block = await vm.blockchain.getBlock(utils.hexToBytes(request.params[0]));
    const txIndex = utils.hexToNumber(request.params[1]);
    const tx = block.transactions[txIndex];
    if (!tx) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: "Transaction not found"
        }
      };
    }
    return {
      method: request.method,
      result: txToJsonRpcTx(tx, block, txIndex),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethGetTransactionByBlockNumberAndIndexJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const blockTagOrNumber = request.params[0];
    const block = await (() => {
      if (blockTagOrNumber.startsWith("0x")) {
        return vm.blockchain.getBlock(utils.hexToBigInt(
          /** @type {import('@tevm/utils').Hex}*/
          blockTagOrNumber
        ));
      }
      return vm.blockchain.blocksByTag.get(
        /** @type {import('@tevm/utils').BlockTag}*/
        blockTagOrNumber
      );
    })();
    if (!block) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: `Invalid block tag ${blockTagOrNumber}`
        }
      };
    }
    const txIndex = utils.hexToNumber(request.params[1]);
    const tx = block.transactions[txIndex];
    if (!tx) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: "Transaction not found"
        }
      };
    }
    return {
      method: request.method,
      result: txToJsonRpcTx(tx, block, txIndex),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethGetTransactionByHashJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const receiptsManager = await client.getReceiptsManager();
    const receipt = await receiptsManager.getReceiptByTxHash(utils.hexToBytes(request.params[0]));
    if (!receipt && client.forkTransport) {
      const fetcher = jsonrpc.createJsonRpcFetcher(client.forkTransport);
      const res = await fetcher.request({
        jsonrpc: "2.0",
        id: request.id ?? 1,
        method: request.method,
        params: [request.params[0]]
      });
      if (res.error) {
        return {
          ...request.id ? { id: request.id } : {},
          method: request.method,
          jsonrpc: request.jsonrpc,
          error: res.error
        };
      }
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        result: (
          /** @type any*/
          res.result
        ),
        jsonrpc: "2.0"
      };
    }
    if (!receipt) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: "Transaction not found"
        }
      };
    }
    const [_receipt, blockHash, txIndex] = receipt;
    const block = await vm.blockchain.getBlock(blockHash);
    const tx = block.transactions[txIndex];
    if (!tx) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: "Transaction not found"
        }
      };
    }
    return {
      method: request.method,
      result: txToJsonRpcTx(tx, block, txIndex),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethGetTransactionCountProcedure = (node) => {
  return async (request) => {
    const [address$1, tag] = request.params;
    const block = await (async () => {
      const vm = await node.getVm();
      if (tag.startsWith("0x") && tag.length === 66) {
        return vm.blockchain.getBlock(utils.hexToBytes(
          /** @type {import('@tevm/utils').Hex}*/
          tag
        ));
      }
      if (tag.startsWith("0x")) {
        return vm.blockchain.getBlock(utils.hexToBigInt(
          /** @type {import('@tevm/utils').Hex}*/
          tag
        ));
      }
      if (tag === "pending") {
        return vm.blockchain.blocksByTag.get("latest");
      }
      if (tag === "latest" || tag === "safe" || tag === "earliest" || tag === "finalized") {
        return vm.blockchain.blocksByTag.get(tag);
      }
      return void 0;
    })();
    if (!block) {
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: -32602,
          message: `Invalid block tag ${tag}`
        }
      };
    }
    const pendingCount = tag === "pending" ? await (async () => {
      const txPool = await node.getTxPool();
      const pendingTx = await txPool.getBySenderAddress(address.createAddress(address$1));
      return BigInt(pendingTx.length);
    })() : 0n;
    const includedCount = await (async () => {
      const vm = await node.getVm();
      if (!await vm.stateManager.hasStateRoot(block.header.stateRoot)) {
        return void 0;
      }
      const stateCopy = await vm.stateManager.deepCopy();
      await stateCopy.setStateRoot(block.header.stateRoot);
      const account = await stateCopy.getAccount(address.createAddress(address$1));
      return account?.nonce ?? 0n;
    })();
    if (includedCount === void 0 && node.forkTransport) {
      try {
        const result = await node.forkTransport.request(request);
        return {
          ...request.id ? { id: request.id } : {},
          method: request.method,
          jsonrpc: request.jsonrpc,
          result: utils.numberToHex(utils.hexToBigInt(result) + pendingCount)
        };
      } catch (e) {
        const err = new errors.ForkError("Unable to resolve eth_getTransactionCount with fork", {
          cause: (
            /** @type {any}*/
            e
          )
        });
        return {
          ...request.id ? { id: request.id } : {},
          method: request.method,
          jsonrpc: request.jsonrpc,
          error: {
            code: err.code,
            message: err.message
          }
        };
      }
    }
    if (includedCount === void 0) {
      const err = new errors.InternalEvmError(`No state root found for block tag ${tag} in eth_getTransactionCountProcedure`);
      node.logger.error(err);
      return {
        ...request.id ? { id: request.id } : {},
        method: request.method,
        jsonrpc: request.jsonrpc,
        error: {
          code: err.code,
          message: err.message
        }
      };
    }
    return {
      ...request.id ? { id: request.id } : {},
      method: request.method,
      jsonrpc: request.jsonrpc,
      result: utils.numberToHex(pendingCount + includedCount)
    };
  };
};
var uintEquals = (a, b) => {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};
var ethGetTransactionReceiptHandler = (client) => async (params) => {
  const receiptsManager = await client.getReceiptsManager();
  const vm = await client.getVm().then((vm2) => vm2.deepCopy());
  const result = await receiptsManager.getReceiptByTxHash(utils.hexToBytes(params.hash));
  if (!result && client.forkTransport) {
    const fetcher = jsonrpc.createJsonRpcFetcher(client.forkTransport);
    const { result: result2 } = await fetcher.request({
      method: "eth_getTransactionReceipt",
      params: [params.hash],
      id: 1,
      jsonrpc: "2.0"
    });
    const r = (
      /** @type {any}*/
      result2
    );
    return r && {
      blockHash: r.hex,
      blockNumber: BigInt(r.blockNumber),
      cumulativeGasUsed: BigInt(r.cumulativeBlockGasUsed),
      effectiveGasPrice: BigInt(r.effectiveGasPrice),
      from: r.from,
      gasUsed: BigInt(r.gasUsed),
      to: r.to,
      transactionHash: r.transactionHash,
      transactionIndex: BigInt(r.transactionIndex),
      contractAddress: r.contractAddress,
      logsBloom: r.logsBloom,
      blobGasUsed: r.blobGasUsed ? BigInt(r.blobGasUsed) : void 0,
      blobGasPrice: r.blobGasPrice ? BigInt(r.blobGasPrice) : void 0,
      root: r.root,
      status: r.status,
      logs: r.logs.map(
        /**
         * TODO type this
         * @param {any} log
         */
        (log) => ({
          address: log.address,
          blockHash: log.blockHash,
          blockNumber: BigInt(log.blockNumber),
          data: log.data,
          logIndex: log.logIndex,
          removed: log.removed,
          topics: log.topics,
          transactionIndex: BigInt(log.transactionIndex),
          transactionHash: log.transactionHash
        })
      )
    };
  }
  if (!result) {
    return null;
  }
  const [receipt, blockHash, txIndex, logIndex] = result;
  const block = await vm.blockchain.getBlock(blockHash);
  const blockByNumber = await vm.blockchain.getBlock(block.header.number);
  if (!uintEquals(blockByNumber.hash(), block.hash())) {
    return null;
  }
  const parentBlock = await vm.blockchain.getBlock(block.header.parentHash);
  const tx = block.transactions[txIndex];
  if (!tx) {
    throw {
      // TODO wrong code
      code: -32602,
      message: "No tx found"
    };
  }
  const effectiveGasPrice = (
    /** @type any*/
    tx.maxPriorityFeePerGas < /** @type any*/
    tx.maxFeePerGas - (block.header.baseFeePerGas ?? 0n) ? (
      /** @type any*/
      tx.maxPriorityFeePerGas
    ) : (
      /** @type any*/
      tx.maxFeePerGas - (block.header.baseFeePerGas ?? 0n) + (block.header.baseFeePerGas ?? 0n)
    )
  );
  vm.common.ethjsCommon.setHardfork(tx.common.hardfork());
  await vm.stateManager.setStateRoot(parentBlock.header.stateRoot);
  const runBlockResult = await vm.runBlock({
    block,
    root: parentBlock.header.stateRoot,
    skipBlockValidation: true
  });
  const res = runBlockResult.results[txIndex];
  if (!res) {
    throw new Error("No result for tx this indicates a bug in the client");
  }
  const { totalGasSpent, createdAddress } = res;
  const { blobGasPrice, blobGasUsed } = (
    /** @type {any}*/
    runBlockResult.receipts[txIndex]
  );
  return {
    blockHash: utils.bytesToHex(block.hash()),
    blockNumber: block.header.number,
    cumulativeGasUsed: receipt.cumulativeBlockGasUsed,
    effectiveGasPrice,
    from: tx.getSenderAddress().toString(),
    gasUsed: totalGasSpent,
    to: tx.to?.toString() ?? null,
    transactionHash: utils.bytesToHex(tx.hash()),
    transactionIndex: txIndex,
    contractAddress: createdAddress?.toString() ?? null,
    logsBloom: utils.bytesToHex(receipt.bitvector),
    blobGasUsed: blobGasUsed !== void 0 ? blobGasUsed : void 0,
    blobGasPrice: blobGasPrice !== void 0 ? blobGasPrice : void 0,
    root: (
      /** @type any*/
      receipt.stateRoot instanceof Uint8Array ? utils.bytesToHex(
        /** @type any*/
        receipt.stateRoot
      ) : void 0
    ),
    status: (
      /** @type any*/
      receipt.status instanceof Uint8Array ? utils.numberToHex(
        /** @type any*/
        receipt.status[0]
      ) : typeof /** @type any*/
      receipt.status === "number" ? utils.numberToHex(
        /** @type any*/
        receipt.status
      ) : void 0
    ),
    logs: await Promise.all(
      receipt.logs.map((log, i) => ({
        address: utils.bytesToHex(log[0]),
        blockHash: block ? utils.bytesToHex(block.hash()) : null,
        blockNumber: block ? block.header.number : null,
        data: utils.bytesToHex(log[2]),
        logIndex: logIndex + i,
        removed: false,
        topics: log[1].map((bytes) => utils.bytesToHex(bytes)),
        transactionIndex: txIndex !== void 0 ? txIndex : null,
        transactionHash: tx !== void 0 ? utils.bytesToHex(tx.hash()) : null
      }))
    )
  };
};

// src/eth/ethGetTransactionReceiptProcedure.js
var ethGetTransactionReceiptJsonRpcProcedure = (client) => async (req) => {
  const [txHash] = req.params;
  if (!txHash) {
    const out2 = {
      jsonrpc: "2.0",
      ...req.id ? { id: req.id } : {},
      method: req.method,
      error: {
        code: -32602,
        message: "Invalid params"
      }
    };
    return out2;
  }
  const res = await ethGetTransactionReceiptHandler(client)({ hash: txHash });
  const out = {
    jsonrpc: "2.0",
    ...req.id ? { id: req.id } : {},
    method: req.method,
    result: res && {
      blockHash: res.blockHash,
      blockNumber: utils.numberToHex(res.blockNumber),
      cumulativeGasUsed: utils.numberToHex(res.cumulativeGasUsed),
      effectiveGasPrice: utils.numberToHex(res.effectiveGasPrice),
      from: res.from,
      to: res.to,
      root: res.root ?? "0x",
      gasUsed: utils.numberToHex(res.gasUsed),
      transactionHash: res.transactionHash,
      transactionIndex: utils.numberToHex(res.transactionIndex),
      contractAddress: res.contractAddress,
      logs: await Promise.all(
        res.logs.map((log) => ({
          address: log.address,
          blockHash: log.blockHash,
          blockNumber: utils.numberToHex(log.blockNumber),
          data: log.data,
          logIndex: utils.numberToHex(log.logIndex),
          removed: false,
          topics: [...log.topics],
          transactionIndex: utils.numberToHex(log.transactionIndex),
          transactionHash: log.transactionHash
        }))
      ),
      logsBloom: res.logsBloom,
      status: res.status ?? "0x0",
      ...res.blobGasUsed !== void 0 ? { blobGasUsed: utils.numberToHex(res.blobGasUsed) } : {},
      ...res.blobGasPrice !== void 0 ? { blobGasPrice: utils.numberToHex(res.blobGasPrice) } : {}
    }
  };
  return out;
};

// src/utils/generateRandomId.js
var generateRandomId = () => {
  return `0x${Array.from(crypto.getRandomValues(new Uint8Array(16))).map((b) => b.toString(16).padStart(2, "0")).join("")}`;
};

// src/eth/ethNewBlockFilterProcedure.js
var ethNewBlockFilterProcedure = (client) => {
  return async (request) => {
    const newBlockFilterRequest = (
      /** @type {import('./EthJsonRpcRequest.js').EthNewBlockFilterJsonRpcRequest}*/
      request
    );
    const id = generateRandomId();
    const listener = (block) => {
      const filter = client.getFilters().get(id);
      if (!filter) {
        return;
      }
      filter.blocks.push(block);
    };
    client.setFilter({
      id,
      type: "Block",
      created: Date.now(),
      logs: [],
      tx: [],
      blocks: [],
      installed: {},
      err: void 0,
      registeredListeners: [listener]
    });
    return {
      ...newBlockFilterRequest.id ? { id: newBlockFilterRequest.id } : {},
      method: newBlockFilterRequest.method,
      jsonrpc: newBlockFilterRequest.jsonrpc,
      result: id
    };
  };
};

// src/eth/utils/generateRandomId.js
var generateRandomId2 = () => {
  return `0x${Array.from(crypto.getRandomValues(new Uint8Array(16))).map((b) => b.toString(16).padStart(2, "0")).join("")}`;
};
var parseBlockTag2 = (blockTag) => {
  const blockHashLength = 64 + "0x".length;
  const isBlockNumber = typeof blockTag === "string" && blockTag.startsWith("0x") && blockTag.length !== blockHashLength;
  if (isBlockNumber) {
    return utils.hexToBigInt(
      /** @type {import('@tevm/utils').Hex}*/
      blockTag
    );
  }
  return blockTag;
};

// src/eth/ethNewFilterHandler.js
var ethNewFilterHandler = (tevmNode) => {
  return async (params) => {
    const { topics, address: address$1, toBlock = "latest", fromBlock } = params;
    const vm = await tevmNode.getVm();
    const getBlock = async (tag) => {
      const parsedTag = parseBlockTag2(tag);
      if (parsedTag === "safe" || parsedTag === "latest" || parsedTag === "finalized" || parsedTag === "earliest" || parsedTag === "pending" || parsedTag === /** @type any*/
      "forked") {
        return vm.blockchain.blocksByTag.get(parsedTag);
      }
      if (typeof parsedTag === "string") {
        return vm.blockchain.getBlock(utils.hexToBytes(parsedTag));
      }
      if (typeof tag === "bigint") {
        return vm.blockchain.getBlock(tag);
      }
      throw new errors.InvalidBlockError(`Invalid block tag ${tag}`);
    };
    const _toBlock = await getBlock(toBlock);
    if (!_toBlock) {
      throw new errors.UnknownBlockError(`Unknown block tag ${toBlock}`);
    }
    const _fromBlock = await getBlock(fromBlock ?? "latest");
    if (!_fromBlock) {
      throw new errors.UnknownBlockError(`Unknown block tag ${fromBlock}`);
    }
    const id = generateRandomId2();
    const listener = (log) => {
      const filter = tevmNode.getFilters().get(id);
      if (!filter) {
        return;
      }
      filter.logs.push(log);
    };
    tevmNode.on("newLog", listener);
    const receiptsManager = await tevmNode.getReceiptsManager();
    const pastLogs = await receiptsManager.getLogs(
      _fromBlock,
      _toBlock,
      address$1 !== void 0 ? [address.createAddress(address$1).bytes] : [],
      topics?.map((topic) => isArray(topic) ? topic.map(utils.hexToBytes) : utils.hexToBytes(topic))
    );
    tevmNode.setFilter({
      id,
      type: "Log",
      created: Date.now(),
      logs: pastLogs.map((log) => {
        const [address2, topics2, data] = log.log;
        return {
          topics: (
            /** @type {[import('@tevm/utils').Hex, ...Array<import('@tevm/utils').Hex>]}*/
            topics2.map((topic) => utils.bytesToHex(topic))
          ),
          address: utils.bytesToHex(address2),
          data: utils.bytesToHex(data),
          blockNumber: log.block.header.number,
          transactionHash: utils.bytesToHex(log.tx.hash()),
          removed: false,
          logIndex: log.logIndex,
          blockHash: utils.bytesToHex(log.block.hash()),
          transactionIndex: log.txIndex
        };
      }),
      tx: [],
      blocks: [],
      logsCriteria: {
        topics,
        address: address$1,
        toBlock,
        fromBlock: fromBlock ?? _fromBlock.header.number
      },
      installed: {},
      err: void 0,
      registeredListeners: [listener]
    });
    return id;
  };
};

// src/eth/ethNewFilterProcedure.js
var ethNewFilterJsonRpcProcedure = (tevmNode) => {
  return async (request) => {
    const newFilterRequest = (
      /** @type {import('./EthJsonRpcRequest.js').EthNewFilterJsonRpcRequest}*/
      request
    );
    try {
      return {
        jsonrpc: request.jsonrpc,
        method: request.method,
        result: await ethNewFilterHandler(tevmNode)(newFilterRequest.params[0]),
        ...request.id !== void 0 ? { id: request.id } : {}
      };
    } catch (e) {
      tevmNode.logger.error(e);
      const { code, message } = (
        /** @type {import('./ethNewFilterHandler.js').EthNewFilterError}*/
        e
      );
      return {
        error: {
          code,
          message
        },
        method: request.method,
        jsonrpc: request.jsonrpc,
        ...request.id !== void 0 ? { id: request.id } : {}
      };
    }
  };
};

// src/eth/ethNewPendingTransactionFilterProcedure.js
var ethNewPendingTransactionFilterProcedure = (client) => {
  return async (request) => {
    await client.ready();
    const id = generateRandomId();
    const listener = (tx) => {
      const filter = client.getFilters().get(id);
      if (!filter) {
        return;
      }
      filter.tx.push(tx);
    };
    client.on("newPendingTransaction", listener);
    client.setFilter({
      id,
      type: "PendingTransaction",
      created: Date.now(),
      logs: [],
      tx: [],
      blocks: [],
      installed: {},
      err: void 0,
      registeredListeners: [listener]
    });
    return {
      ...request.id ? { id: request.id } : {},
      method: request.method,
      jsonrpc: request.jsonrpc,
      result: id
    };
  };
};
var ethProtocolVersionJsonRpcProcedure = () => {
  return async (request) => {
    return {
      result: viem.stringToHex("tevm@1.x.x"),
      jsonrpc: "2.0",
      method: "eth_protocolVersion",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethSendRawTransactionJsonRpcProcedure = (client) => {
  return async (request) => {
    const vm = await client.getVm();
    const [serializedTx] = request.params;
    const txBuf = utils.hexToBytes(serializedTx);
    const tx$1 = tx.createTxFromRLP(txBuf, { common: vm.common.ethjsCommon });
    if (!tx$1.isSigned()) {
      const err = new errors.InvalidParamsError("Transaction must be signed!");
      return {
        method: request.method,
        jsonrpc: "2.0",
        ...request.id ? { id: request.id } : {},
        error: {
          code: err._tag,
          message: err.message
        }
      };
    }
    const txPool = await client.getTxPool();
    await txPool.add(tx$1, true);
    if (client.miningConfig.type === "auto") {
      await handleAutomining(client, utils.bytesToHex(tx$1.hash()), false, true);
    }
    return {
      method: request.method,
      result: utils.bytesToHex(tx$1.hash()),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};
var ethSendTransactionHandler = (client) => async (params) => {
  let tx$1 = tx.TransactionFactory(
    {
      ...params,
      data: params.data ?? new Uint8Array()
    },
    { freeze: false }
  );
  const impersonatedAccount = client.getImpersonatedAccount();
  if (!tx$1.isSigned() && impersonatedAccount !== void 0) {
    const impersonatedTx = (
      /** @type {any}*/
      tx$1
    );
    impersonatedTx.impersonatedAddress = address.createAddress(impersonatedAccount);
    tx$1 = tx.createImpersonatedTx(impersonatedTx);
  } else if (!tx$1.isSigned()) {
    client.logger.debug(
      "Raw Transaction is not signed. Consider calling impersonate endpoint. In future versions unsigned transactions will be rejected."
    );
    const impersonatedTx = (
      /** @type {any}*/
      tx$1
    );
    impersonatedTx.impersonatedAddress = address.createAddress(
      impersonatedAccount ?? /** @type {import('@tevm/utils').Address} */
      node.prefundedAccounts[0]
    );
    tx$1 = tx.createImpersonatedTx(impersonatedTx);
  }
  const { errors } = await callHandler2(client)({
    ...params,
    createTransaction: true,
    skipBalance: true
  });
  if (errors?.length === 1) {
    throw errors[0];
  }
  if (errors?.length && errors.length > 1) {
    throw new AggregateError(errors);
  }
  return utils.bytesToHex(tx$1.hash());
};

// src/eth/ethSendTransactionProcedure.js
var ethSendTransactionJsonRpcProcedure = (client) => {
  return async (request) => {
    const sendTransactionRequest = (
      /** @type {import('./EthJsonRpcRequest.js').EthSendTransactionJsonRpcRequest}*/
      request
    );
    const txHash = await ethSendTransactionHandler(client)({
      ...request.params[0].from ? { from: request.params[0].from } : {},
      ...request.params[0].data ? { data: request.params[0].data } : {},
      ...request.params[0].to ? { to: request.params[0].to } : {},
      ...request.params[0].gas ? { gas: utils.hexToBigInt(request.params[0].gas) } : {},
      ...request.params[0].gasPrice ? { gasPrice: utils.hexToBigInt(request.params[0].gasPrice) } : {},
      ...request.params[0].value ? { value: utils.hexToBigInt(request.params[0].value) } : {}
    });
    return {
      method: sendTransactionRequest.method,
      result: txHash,
      jsonrpc: "2.0",
      ...sendTransactionRequest.id ? { id: sendTransactionRequest.id } : {}
    };
  };
};

// src/eth/ethUninstallFilterProcedure.js
var ethUninstallFilterJsonRpcProcedure = (client) => {
  return async (request) => {
    const uninstallFilterRequest = (
      /** @type {import('./EthJsonRpcRequest.js').EthUninstallFilterJsonRpcRequest}*/
      request
    );
    const [filterId] = uninstallFilterRequest.params;
    const filter = client.getFilters().get(filterId);
    if (!filter) {
      return {
        ...uninstallFilterRequest.id ? { id: uninstallFilterRequest.id } : {},
        method: uninstallFilterRequest.method,
        jsonrpc: uninstallFilterRequest.jsonrpc,
        result: false
      };
    }
    const [listener] = filter.registeredListeners;
    if (filter.type === "Log" && listener) {
      client.removeListener("newLog", listener);
    } else if (filter.type === "Block" && listener) {
      client.removeListener("newBlock", listener);
    } else if (filter.type === "PendingTransaction" && listener) {
      client.removeListener("newPendingTransaction", listener);
    }
    client.removeFilter(filterId);
    return {
      ...request.id ? { id: request.id } : {},
      method: request.method,
      jsonrpc: request.jsonrpc,
      result: true
    };
  };
};
var gasPriceHandler = ({ forkTransport, getVm, ...client }) => {
  let gasPrice;
  let blockNumber;
  return async () => {
    if (!forkTransport) {
      return utils.parseGwei("1");
    }
    const fetcher = jsonrpc.createJsonRpcFetcher(forkTransport);
    const newBlockNumber = await blockNumberHandler({ ...client, getVm })({});
    if (!gasPrice || blockNumber !== newBlockNumber) {
      blockNumber = newBlockNumber;
      gasPrice = await fetcher.request({
        method: "eth_gasPrice",
        params: [],
        jsonrpc: "2.0",
        id: 1
      }).then(({ result }) => {
        return utils.hexToBigInt(
          /** @type {import('@tevm/utils').Hex} */
          result
        );
      });
    }
    return gasPrice;
  };
};

// src/eth/gasPriceProcedure.js
var gasPriceProcedure = ({ getVm, forkTransport }) => async (req) => ({
  ...req.id ? { id: req.id } : {},
  jsonrpc: "2.0",
  method: req.method,
  // TODO pass in a client instead
  result: await gasPriceHandler(
    /** @type any*/
    { getVm, forkTransport }
  )({}).then(utils.numberToHex)
});
var getBalanceHandler = (baseClient) => async ({ address: address$1, blockTag = "latest" }) => {
  const vm = await baseClient.getVm();
  if (blockTag === "latest") {
    const account = await vm.stateManager.getAccount(address.createAddress(address$1));
    return account?.balance ?? 0n;
  }
  if (blockTag === "pending") {
    const mineResult = await getPendingClient(baseClient);
    if (mineResult.errors) {
      throw mineResult.errors[0];
    }
    return getBalanceHandler(mineResult.pendingClient)({ address: address$1, blockTag: "latest" });
  }
  const block = vm.blockchain.blocks.get(
    /** @type any*/
    blockTag
  ) ?? vm.blockchain.blocksByTag.get(
    /** @type any*/
    blockTag
  ) ?? vm.blockchain.blocksByNumber.get(
    /** @type any*/
    blockTag
  );
  const hasStateRoot = block && await vm.stateManager.hasStateRoot(block.header.stateRoot);
  if (hasStateRoot) {
    const root = vm.stateManager._baseState.stateRoots.get(utils.bytesToHex(block.header.stateRoot));
    if (root?.[address$1]) return root[address$1].balance;
  }
  if (!baseClient.forkTransport) {
    throw new errors.NoForkUrlSetError("No fork url set");
  }
  const fetcher = jsonrpc.createJsonRpcFetcher(baseClient.forkTransport);
  const jsonRpcResponse = await fetcher.request({
    jsonrpc: "2.0",
    id: 1,
    method: "eth_getBalance",
    params: [address$1, typeof blockTag === "bigint" ? utils.numberToHex(blockTag) : blockTag]
  });
  if (jsonRpcResponse.error) {
    throw jsonRpcResponse.error;
  }
  if (jsonRpcResponse.result === null) {
    return 0n;
  }
  return utils.hexToBigInt(
    /** @type {any}*/
    jsonRpcResponse.result
  );
};

// src/eth/getBalanceProcedure.js
var getBalanceProcedure = (baseClient) => async (req) => {
  if (!req.params[1]) {
    throw new Error(
      'getBalanceProcedure received invalid parameters: Block parameter (req.params[1]) is missing or invalid. Expected a hex string or block tag (e.g., "latest", "earliest").'
    );
  }
  return {
    ...req.id ? { id: req.id } : {},
    jsonrpc: "2.0",
    method: req.method,
    result: utils.numberToHex(
      await getBalanceHandler(baseClient)({
        address: req.params[0],
        ...req.params[1].startsWith("0x") ? { blockNumber: BigInt(req.params[1]) } : {
          blockTag: (
            /** @type {import('@tevm/utils').BlockTag}*/
            req.params[1]
          )
        }
      })
    )
  };
};
var getCodeHandler = (baseClient) => async (params) => {
  const vm = await baseClient.getVm();
  const tag = params.blockTag ?? "latest";
  if (tag === "pending") {
    const mineResult = await getPendingClient(baseClient);
    if (mineResult.errors) {
      throw mineResult.errors[0];
    }
    return getCodeHandler(mineResult.pendingClient)({ ...params, blockTag: "latest" });
  }
  const block = await (async () => {
    if (tag === "latest" || tag === "earliest" || tag === "safe" || tag === "finalized") {
      return vm.blockchain.blocksByTag.get(tag);
    }
    if (utils.isHex(tag)) {
      return vm.blockchain.getBlock(utils.hexToBytes(tag));
    }
    return vm.blockchain.getBlock(tag);
  })();
  if (!block) {
    throw new errors.UnknownBlockError(`Unable to find block ${tag}`);
  }
  let deployedBytecode;
  if (await vm.stateManager.hasStateRoot(block.header.stateRoot)) {
    deployedBytecode = vm.stateManager._baseState.stateRoots.get(utils.bytesToHex(block.header.stateRoot))?.[utils.getAddress(params.address)]?.deployedBytecode;
  }
  if (!deployedBytecode && baseClient.forkTransport) {
    const fetcher = jsonrpc.createJsonRpcFetcher(baseClient.forkTransport);
    return fetcher.request({
      jsonrpc: "2.0",
      id: 1,
      method: "eth_getCode",
      params: [params.address, tag]
    }).then((res) => {
      if (res.error) {
        const err = new Error(res.error.message);
        err._tag = res.error.code;
        err.name = res.error.code;
        throw err;
      }
      return (
        /** @type {import('@tevm/utils').Hex}*/
        res.result
      );
    }).catch((err) => {
      if (err.name === "MethodNotFound") {
        throw new Error("Method eth_getCode not supported by fork url");
      }
      throw err;
    });
  }
  return deployedBytecode ?? utils.bytesToHex(new Uint8Array());
};

// src/eth/getCodeProcedure.js
var getCodeProcedure = (baseClient) => async (req) => ({
  ...req.id ? { id: req.id } : {},
  jsonrpc: "2.0",
  method: req.method,
  result: await getCodeHandler(baseClient)({
    address: req.params[0],
    blockTag: req.params[1]
  })
});

// src/eth/getStorageAtProcedure.js
var getStorageAtProcedure = (client) => async (req) => ({
  ...req.id ? { id: req.id } : {},
  jsonrpc: "2.0",
  method: req.method,
  result: await getStorageAtHandler(client)({
    address: req.params[0],
    position: req.params[1],
    blockTag: req.params[2]
  })
});
var getAccountProcedure = (client) => async (request) => {
  request.params;
  const { errors = [], ...result } = await getAccountHandler(client)({
    address: request.params[0].address,
    throwOnFail: false,
    returnStorage: request.params[0].returnStorage ?? false
  });
  if (errors.length > 0) {
    const error = (
      /** @type {import('./TevmGetAccountError.js').TevmGetAccountError}*/
      errors[0]
    );
    return {
      jsonrpc: "2.0",
      error: {
        code: error.code,
        message: error.message,
        data: {
          errors: errors.map(({ message }) => message)
        }
      },
      method: "tevm_getAccount",
      ...request.id === void 0 ? {} : { id: request.id }
    };
  }
  return {
    jsonrpc: "2.0",
    result: (
      /** @type any*/
      {
        address: result.address,
        balance: utils.numberToHex(result.balance ?? 0n),
        deployedBytecode: result.deployedBytecode ?? "0x0",
        nonce: utils.numberToHex(result.nonce ?? 0n),
        storageRoot: result.storageRoot,
        isContract: result.isContract,
        isEmpty: result.isEmpty,
        codeHash: result.codeHash,
        storage: result.storage
      }
    ),
    method: "tevm_getAccount",
    ...request.id === void 0 ? {} : { id: request.id }
  };
};
var AccountStorage = zBaseParams.extend({
  nonce: zHex.describe("The nonce of the account"),
  balance: zHex.describe("The balance of the account"),
  storageRoot: zHex.describe("The storage root of the account"),
  codeHash: zHex.describe("The code hash of the account"),
  storage: zod.z.optional(zod.z.record(zHex, zHex)).describe("The storage of the account")
});
var zLoadStateParams = zod.z.object({ state: zod.z.record(zHex, AccountStorage) }).describe("Properties shared across the load state");

// src/LoadState/validateLoadStateParams.js
var validateLoadStateParams = (action) => {
  const errors$1 = [];
  const parsedParams = zLoadStateParams.safeParse(action);
  if (parsedParams.success === false) {
    const formattedErrors = parsedParams.error.format();
    if (formattedErrors._errors) {
      formattedErrors._errors.forEach((error) => {
        errors$1.push(new errors.InvalidRequestError(error));
      });
    }
    if (formattedErrors.state?._errors) {
      formattedErrors.state._errors.forEach((error) => {
        errors$1.push(new errors.InvalidRequestError(`Invalid state: ${error}`));
      });
    }
  }
  return errors$1;
};

// src/LoadState/loadStateHandler.js
var deserializeState = (serializedState) => {
  const state = {};
  for (const [address, account] of Object.entries(serializedState)) {
    const addressKey = (
      /** @type {import('@tevm/utils').Address} */
      address
    );
    state[addressKey] = {
      nonce: utils.hexToBigInt(account.nonce),
      balance: utils.hexToBigInt(account.balance),
      storageRoot: account.storageRoot,
      codeHash: account.codeHash,
      ...account.deployedBytecode && { deployedBytecode: account.deployedBytecode },
      ...account.storage && {
        storage: {
          ...Object.fromEntries(Object.entries(account.storage).map(([key, value]) => [key.replace(/^0x/, ""), value]))
        }
      }
    };
  }
  return state;
};
var loadStateHandler = (client, options = {}) => async ({ throwOnFail = options.throwOnFail ?? true, ...params }) => {
  const errors$1 = validateLoadStateParams(params);
  if (errors$1.length > 0) {
    return maybeThrowOnFail(throwOnFail, { errors: errors$1 });
  }
  try {
    const vm = await client.getVm();
    if ("generateCanonicalGenesis" in vm.stateManager) {
      const deserializedState = deserializeState(params.state);
      await vm.stateManager.generateCanonicalGenesis(deserializedState);
    } else {
      throw new Error(
        "Unsupported state manager. Must use a Tevm state manager from `@tevm/state` package. This may indicate a bug in tevm internal code."
      );
    }
    return {};
  } catch (e) {
    return maybeThrowOnFail(throwOnFail, {
      errors: [new errors.InternalError("UnexpectedError", { cause: e })]
    });
  }
};

// src/LoadState/loadStateProcedure.js
var loadStateProcedure = (client) => async (request) => {
  const {
    params: [{ state }]
  } = request;
  const { errors = [] } = await loadStateHandler(client)({
    state,
    throwOnFail: false
  });
  if (errors.length > 0) {
    const error = (
      /** @type {import('./TevmLoadStateError.js').TevmLoadStateError}*/
      errors[0]
    );
    return {
      jsonrpc: "2.0",
      error: {
        code: error.code,
        message: error.message,
        data: {
          errors: errors.map(({ message }) => message)
        }
      },
      method: "tevm_loadState",
      ...request.id === void 0 ? {} : { id: request.id }
    };
  }
  return {
    jsonrpc: "2.0",
    result: {},
    method: "tevm_loadState",
    ...request.id === void 0 ? {} : { id: request.id }
  };
};
var mineProcedure = (client) => async (request) => {
  const { errors: errors$1 = [], ...result } = await mineHandler(client)({
    throwOnFail: false,
    interval: utils.hexToNumber(request.params[1] ?? "0x0"),
    blockCount: utils.hexToNumber(request.params[0] ?? "0x1")
  });
  if (errors$1.length > 0) {
    const error = (
      /** @type {import('./TevmMineError.js').TevmMineError}*/
      errors$1[0]
    );
    return {
      jsonrpc: "2.0",
      error: {
        code: error.code,
        message: error.message,
        data: {
          errors: errors$1.map(({ message }) => message)
        }
      },
      method: "tevm_mine",
      ...request.id === void 0 ? {} : { id: request.id }
    };
  }
  if (!result.blockHashes?.length) {
    const error = new errors.InternalError("No blocks were mined");
    return {
      jsonrpc: "2.0",
      error: {
        code: error.code,
        message: error.message
      },
      method: "tevm_mine",
      ...request.id === void 0 ? {} : { id: request.id }
    };
  }
  return {
    jsonrpc: "2.0",
    result: {
      blockHashes: result.blockHashes ?? []
    },
    method: "tevm_mine",
    ...request.id === void 0 ? {} : { id: request.id }
  };
};

// src/createHandlers.js
var createHandlers = (client) => {
  const tevmHandlers = {
    tevm_call: callProcedure(client),
    /**
     * @param {any} request
     */
    tevm_contract: (request) => {
      const err = new errors.MethodNotSupportedError(
        "UnsupportedMethodError: tevm_contract is not supported. Encode the contract arguments and use tevm_call instead."
      );
      return (
        /**@type any*/
        {
          id: (
            /** @type any*/
            request.id
          ),
          method: request.method,
          jsonrpc: "2.0",
          error: {
            code: err._tag,
            message: err.message
          }
        }
      );
    },
    tevm_getAccount: getAccountProcedure(client),
    tevm_setAccount: setAccountProcedure(client),
    tevm_dumpState: dumpStateProcedure(client),
    tevm_loadState: loadStateProcedure(client),
    tevm_miner: mineProcedure(client)
  };
  const ethHandlers = {
    eth_blockNumber: blockNumberProcedure(client),
    eth_chainId: chainIdProcedure(client),
    eth_call: ethCallProcedure(client),
    eth_createAccessList: ethCreateAccessListProcedure(client),
    eth_getCode: getCodeProcedure(client),
    eth_getStorageAt: getStorageAtProcedure(client),
    eth_gasPrice: gasPriceProcedure(client),
    eth_getBalance: getBalanceProcedure(client),
    eth_coinbase: ethCoinbaseJsonRpcProcedure(client),
    eth_mining: (
      /**
       * @param {any} request}
       */
      (request) => {
        return {
          result: client.status === "MINING",
          method: request.method,
          jsonrpc: "2.0",
          ...request.id ? { id: request.id } : {}
        };
      }
    ),
    eth_syncing: (
      /**
       * @param {any} request}
       */
      (request) => {
        return {
          result: client.status === "SYNCING",
          method: request.method,
          jsonrpc: "2.0",
          ...request.id ? { id: request.id } : {}
        };
      }
    ),
    eth_sendTransaction: ethSendTransactionJsonRpcProcedure(client),
    eth_sendRawTransaction: ethSendRawTransactionJsonRpcProcedure(client),
    eth_estimateGas: ethEstimateGasJsonRpcProcedure(client),
    eth_getTransactionReceipt: ethGetTransactionReceiptJsonRpcProcedure(client),
    eth_getLogs: ethGetLogsProcedure(client),
    eth_getBlockByHash: ethGetBlockByHashJsonRpcProcedure(client),
    eth_getBlockByNumber: ethGetBlockByNumberJsonRpcProcedure(client),
    eth_getBlockTransactionCountByHash: ethGetBlockTransactionCountByHashJsonRpcProcedure(client),
    eth_getBlockTransactionCountByNumber: ethGetBlockTransactionCountByNumberJsonRpcProcedure(client),
    eth_getTransactionByHash: ethGetTransactionByHashJsonRpcProcedure(client),
    eth_getTransactionByBlockHashAndIndex: ethGetTransactionByBlockHashAndIndexJsonRpcProcedure(client),
    eth_getTransactionByBlockNumberAndIndex: ethGetTransactionByBlockNumberAndIndexJsonRpcProcedure(client),
    eth_protocolVersion: ethProtocolVersionJsonRpcProcedure(),
    eth_getTransactionCount: ethGetTransactionCountProcedure(client),
    eth_newFilter: ethNewFilterJsonRpcProcedure(client),
    eth_getFilterLogs: ethGetFilterLogsProcedure(client),
    eth_newBlockFilter: ethNewBlockFilterProcedure(client),
    eth_uninstallFilter: ethUninstallFilterJsonRpcProcedure(client),
    eth_getFilterChanges: ethGetFilterChangesProcedure(client),
    eth_newPendingTransactionFilter: ethNewPendingTransactionFilterProcedure(client),
    eth_blobBaseFee: ethBlobBaseFeeJsonRpcProcedure(client)
  };
  const anvilHandlers = {
    anvil_deal: anvilDealJsonRpcProcedure(client),
    anvil_setCode: anvilSetCodeJsonRpcProcedure(client),
    anvil_setBalance: anvilSetBalanceJsonRpcProcedure(client),
    anvil_setNonce: anvilSetNonceJsonRpcProcedure(client),
    anvil_setChainId: chainIdHandler(client),
    anvil_getAutomine: anvilGetAutomineJsonRpcProcedure(client),
    anvil_setCoinbase: anvilSetCoinbaseJsonRpcProcedure(client),
    anvil_mine: mineProcedure(client),
    anvil_reset: anvilResetJsonRpcProcedure(client),
    anvil_dropTransaction: anvilDropTransactionJsonRpcProcedure(client),
    anvil_dumpState: anvilDumpStateJsonRpcProcedure(client),
    anvil_loadState: anvilLoadStateJsonRpcProcedure(client),
    anvil_setStorageAt: anvilSetStorageAtJsonRpcProcedure(client),
    anvil_impersonateAccount: anvilImpersonateAccountJsonRpcProcedure(client),
    anvil_stopImpersonatingAccount: anvilStopImpersonatingAccountJsonRpcProcedure(client)
  };
  const tevmAnvilHandlers = Object.fromEntries(
    Object.entries(anvilHandlers).map(([key, value]) => {
      return [key.replace("anvil", "tevm"), value];
    })
  );
  const ganacheHandlers = Object.fromEntries(
    Object.entries(anvilHandlers).map(([key, value]) => {
      return [key.replace("anvil", "ganache"), value];
    })
  );
  const hardhatHandlers = Object.fromEntries(
    Object.entries(anvilHandlers).map(([key, value]) => {
      return [key.replace("anvil", "hardhat"), value];
    })
  );
  const debugHandlers = {
    debug_traceBlock: debugTraceBlockJsonRpcProcedure(client),
    debug_traceBlockByHash: debugTraceBlockJsonRpcProcedure(client),
    debug_traceBlockByNumber: debugTraceBlockJsonRpcProcedure(client),
    debug_traceCall: debugTraceCallJsonRpcProcedure(client),
    debug_traceTransaction: debugTraceTransactionJsonRpcProcedure(client),
    debug_traceState: debugTraceStateJsonRpcProcedure(client)
  };
  const allHandlers = {
    ...tevmHandlers,
    ...ethHandlers,
    ...anvilHandlers,
    ...tevmAnvilHandlers,
    ...ganacheHandlers,
    ...hardhatHandlers,
    ...debugHandlers
  };
  return allHandlers;
};

// src/requestProcedure.js
var requestProcedure = (client) => {
  const handlers = createHandlers(client);
  return async (request) => {
    await client.ready();
    client.logger.debug({ request }, "JSON-RPC request received");
    if (!(request.method in handlers)) {
      const err = new errors.MethodNotFoundError(`UnsupportedMethodError: Unknown method ${/**@type any*/
      request.method}`);
      return (
        /** @type {any}*/
        {
          id: (
            /** @type any*/
            request.id ?? null
          ),
          method: (
            /** @type any*/
            request.method
          ),
          jsonrpc: "2.0",
          error: {
            code: err.code,
            message: err.message
          }
        }
      );
    }
    return handlers[
      /** @type {keyof typeof handlers}*/
      request.method
    ](request);
  };
};

// src/debug/debugTraceTransactionProcedure.js
var debugTraceTransactionJsonRpcProcedure = (client) => {
  return async (request) => {
    const { tracer, timeout, tracerConfig, transactionHash } = request.params[0];
    if (timeout !== void 0) {
      client.logger.warn("Warning: timeout is currently respected param of debug_traceTransaction");
    }
    client.logger.debug({ transactionHash, tracer, tracerConfig }, "debug_traceTransaction: executing with params");
    const transactionByHashResponse = await requestProcedure(client)({
      method: "eth_getTransactionByHash",
      params: [transactionHash],
      jsonrpc: "2.0",
      id: 1
    });
    if (transactionByHashResponse.error) {
      return {
        error: {
          code: transactionByHashResponse.error.code.toString(),
          message: transactionByHashResponse.error.message
        },
        ...request.id !== void 0 ? { id: request.id } : {},
        jsonrpc: "2.0",
        method: request.method
      };
    }
    let vm = await client.getVm();
    const block = await vm.blockchain.getBlock(utils.hexToBytes(transactionByHashResponse.result.blockHash));
    const parentBlock = await vm.blockchain.getBlock(block.header.parentHash);
    const previousTx = block.transactions.filter(
      (_, i) => i < utils.hexToNumber(transactionByHashResponse.result.transactionIndex)
    );
    const hasStateRoot = await vm.stateManager.hasStateRoot(parentBlock.header.stateRoot);
    if (!hasStateRoot && client.forkTransport) {
      vm = await forkAndCacheBlock(client, parentBlock);
    } else if (!hasStateRoot) {
      return {
        jsonrpc: "2.0",
        method: request.method,
        ...request.id !== void 0 ? { id: request.id } : {},
        error: {
          code: "-32602",
          message: "State root not available for parent block"
        }
      };
    }
    const vmClone = await vm.deepCopy();
    await vmClone.stateManager.setStateRoot(parentBlock.header.stateRoot);
    for (const tx$1 of previousTx) {
      await vmClone.runTx({
        block,
        skipNonce: true,
        skipBalance: true,
        skipHardForkValidation: true,
        skipBlockGasLimitValidation: true,
        tx: tx.createImpersonatedTx(
          {
            ...tx$1,
            gasPrice: null,
            impersonatedAddress: address.createAddress(tx$1.getSenderAddress())
          },
          {
            freeze: false,
            common: vmClone.common.ethjsCommon,
            allowUnlimitedInitCodeSize: true
          }
        )
      });
    }
    const traceResult = await traceCallHandler({ ...client, getVm: () => Promise.resolve(vmClone) })({
      tracer,
      ...transactionByHashResponse.result.to !== void 0 ? { to: transactionByHashResponse.result.to } : {},
      ...transactionByHashResponse.result.from !== void 0 ? { from: transactionByHashResponse.result.from } : {},
      ...transactionByHashResponse.result.gas !== void 0 ? { gas: utils.hexToBigInt(transactionByHashResponse.result.gas) } : {},
      ...transactionByHashResponse.result.gasPrice !== void 0 ? { gasPrice: utils.hexToBigInt(transactionByHashResponse.result.gasPrice) } : {},
      ...transactionByHashResponse.result.value !== void 0 ? { value: utils.hexToBigInt(transactionByHashResponse.result.value) } : {},
      ...transactionByHashResponse.result.input !== void 0 ? { data: transactionByHashResponse.result.input } : {},
      ...transactionByHashResponse.result.blockHash !== void 0 ? { blockTag: transactionByHashResponse.result.blockHash } : {},
      ...timeout !== void 0 ? { timeout } : {},
      .../** @type {any} */
      tracerConfig !== void 0 ? { tracerConfig } : {}
    });
    return {
      method: request.method,
      result: (
        /** @type {any} */
        serializeTraceResult(traceResult)
      ),
      jsonrpc: "2.0",
      ...request.id ? { id: request.id } : {}
    };
  };
};

// src/eth/ethAccountsHandler.js
var ethAccountsHandler = ({ accounts }) => async () => {
  return accounts.map((account) => account.address);
};

// src/eth/ethAccountsProcedure.js
var ethAccountsProcedure = (accounts) => async (req) => ({
  ...req.id ? { id: req.id } : {},
  jsonrpc: "2.0",
  method: req.method,
  result: await ethAccountsHandler({ accounts })({})
});

// src/eth/ethCallHandler.js
var ethCallHandler = (client) => async (params) => {
  return callHandler2(client)({
    ...params,
    createTransaction: false,
    skipBalance: true
  }).then((res) => {
    if (res.errors?.length) {
      throw res.errors?.[0];
    }
    return res.rawData;
  });
};
var txType = {
  OPTIMISM_DEPOSIT: 126
};
var getTx = (vm, txBuf) => {
  if (txBuf[0] === txType.OPTIMISM_DEPOSIT) {
    throw new Error("Optimism deposit tx are not supported");
  }
  const tx$1 = tx.createTxFromRLP(txBuf, {
    common: vm.common.ethjsCommon,
    freeze: false
  });
  if (tx.isBlobEIP4844Tx(tx$1)) {
    const blobGasLimit = (
      /** @type {any} */
      vm.common.ethjsCommon.param("gasConfig", "maxblobGasPerBlock")
    );
    const blobGasPerBlob = (
      /** @type {any} */
      vm.common.ethjsCommon.param("gasConfig", "blobGasPerBlob")
    );
    const blobCount = BigInt(tx$1.blobs?.length ?? 0);
    const blobGas = blobCount * blobGasPerBlob;
    if (blobGas > blobGasLimit) {
      throw new errors.BlobGasLimitExceededError();
    }
  }
  return tx$1;
};
var ethSendRawTransactionHandler = (client) => async (params) => {
  const vm = await client.getVm();
  const txBuf = utils.hexToBytes(params.data);
  let tx$1;
  try {
    tx$1 = /** @type {any} */
    getTx(vm, txBuf);
  } catch (e) {
    throw new errors.InvalidTransactionError("Invalid transaction. Unable to parse data", { cause: (
      /** @type {Error}*/
      e
    ) });
  }
  const impersonatedAccount = client.getImpersonatedAccount();
  if (!tx$1.isSigned() && impersonatedAccount !== void 0) {
    const impersonatedTx = (
      /** @type {any}*/
      tx$1
    );
    impersonatedTx.impersonatedAddress = address.createAddress(impersonatedAccount);
    tx$1 = tx.createImpersonatedTx(impersonatedTx, { common: tx$1.common });
  } else if (!tx$1.isSigned()) {
    client.logger.debug(
      "Raw Transaction is not signed. Consider calling impersonate endpoint. In future versions unsigned transactions will be rejected."
    );
    const impersonatedTx = (
      /** @type {any}*/
      tx$1
    );
    impersonatedTx.impersonatedAddress = address.createAddress(
      impersonatedAccount ?? /** @type {import('@tevm/utils').Address} */
      node.prefundedAccounts[0]
    );
    tx$1 = tx.createImpersonatedTx(impersonatedTx);
  }
  let res;
  try {
    res = await callHandler2(client)({
      throwOnFail: false,
      createTransaction: "always",
      ...tx$1,
      from: (
        /** @type {import('@tevm/utils').Address}*/
        tx$1.getSenderAddress().toString()
      ),
      to: (
        /** @type {import('@tevm/utils').Address}*/
        tx$1.to?.toString()
      ),
      ..."blobVersionedHashes" in tx$1 && tx$1.blobVersionedHashes ? {
        blobVersionedHashes: (
          /** @type {import('@tevm/utils').Hex[]} */
          tx$1.blobVersionedHashes
        )
      } : {},
      data: utils.bytesToHex(tx$1.data)
    });
  } catch (error) {
    throw new errors.InvalidTransactionError("Invalid transaction. Unable to add transaction to pool", {
      cause: (
        /** @type {Error}*/
        error
      )
    });
  }
  if (res.errors?.length === 1) {
    throw res.errors[0];
  }
  if ((res.errors?.length ?? 0) > 0) {
    throw new AggregateError(res.errors ?? []);
  }
  return utils.bytesToHex(tx$1.hash());
};

// src/eth/ethSignHandler.js
var MissingAccountError = class extends Error {
  /**
   * @type {'MissingAccountError'}
   */
  _tag = "MissingAccountError";
  /**
   * @type {'MissingAccountError'}
   * @override
   */
  name = "MissingAccountError";
};
var ethSignHandler = ({ accounts }) => {
  const accountsByAddress = Object.fromEntries(accounts.map((account) => [account.address, account]));
  return async (params) => {
    const account = accountsByAddress[params.address];
    if (!account) {
      throw new MissingAccountError(`Account ${params.address} not found`);
    }
    return account.signMessage({ message: params.data });
  };
};

// src/eth/ethSignProcedure.js
var ethSignProcedure = (accounts) => async (req) => ({
  ...req.id ? { id: req.id } : {},
  jsonrpc: "2.0",
  method: req.method,
  result: await ethSignHandler({ accounts })({
    address: req.params[0],
    data: req.params[1]
  })
});

// src/eth/ethSignTransactionHandler.js
var ethSignTransactionHandler = ({ getChainId, accounts }) => {
  const accountsByAddress = Object.fromEntries(accounts.map((account) => [account.address, account]));
  return async ({ nonce, ...params }) => {
    const account = accountsByAddress[params.from];
    if (!account) {
      throw new MissingAccountError(`Account ${params.from} not found`);
    }
    return account.signTransaction({
      ...params,
      type: "eip2930",
      chainId: Number(await getChainId()),
      ...typeof nonce === "bigint" ? { nonce: Number(nonce) } : {}
    });
  };
};
var ethSignTransactionProcedure = (options) => async (req) => ({
  ...req.id ? { id: req.id } : {},
  jsonrpc: "2.0",
  method: req.method,
  result: await ethSignTransactionHandler(options)({
    from: req.params[0].from,
    ...req.params[0].to ? { to: req.params[0].to } : {},
    ...req.params[0].data ? { data: req.params[0].data } : {},
    ...req.params[0].value ? { value: utils.hexToBigInt(req.params[0].value) } : {},
    ...req.params[0].gas ? { gas: utils.hexToBigInt(req.params[0].gas) } : {},
    ...req.params[0].gasPrice ? { gasPrice: utils.hexToBigInt(req.params[0].gasPrice) } : {},
    ...req.params[0].nonce ? { nonce: utils.hexToBigInt(req.params[0].nonce) } : {}
  })
});
var zBlock = zod.z.strictObject({
  number: zod.z.bigint().min(0n).describe("The block number (height) in the blockchain."),
  coinbase: zAddress.describe("The address of the miner or validator who mined or validated the block."),
  timestamp: zod.z.bigint().min(0n).describe("The timestamp at which the block was mined or validated."),
  difficulty: zod.z.bigint().min(0n).describe("The difficulty level of the block (relevant in PoW chains)."),
  gasLimit: zod.z.bigint().min(0n).describe(
    "The gas limit for the block, i.e., the maximum amount of gas that can be used by the transactions in the block."
  ),
  baseFeePerGas: zod.z.bigint().min(0n).optional().describe(
    "(Optional) The base fee per gas in the block, introduced in EIP-1559 for dynamic transaction fee calculation."
  ),
  blobGasPrice: zod.z.bigint().min(0n).optional().describe("The gas price for the block; may be undefined in blocks after EIP-1559.")
}).describe("A valid block header");

// src/Mine/validateMineEvents.js
var validateMineEvents = (events) => {
  if (typeof events !== "object" || events === null) {
    return {
      isValid: false,
      errors: [{ path: "", message: "Events must be an object" }]
    };
  }
  const errors = [];
  const handlers = ["onBlock", "onReceipt", "onLog"];
  for (const handler of handlers) {
    if (handler in events && /** @type {Record<string, unknown>} */
    events[handler] !== void 0) {
      if (typeof /** @type {Record<string, unknown>} */
      events[handler] !== "function") {
        errors.push({
          path: handler,
          message: `${handler} must be a function`
        });
      }
    }
  }
  for (const key in events) {
    if (!handlers.includes(key)) {
      errors.push({
        path: key,
        message: `Unknown event handler: ${key}`
      });
    }
  }
  return {
    isValid: errors.length === 0,
    errors
  };
};

// src/requestBulkProcedure.js
var requestBulkProcedure = (client) => async (requests) => {
  const handleRequest = requestProcedure(client);
  const responses = await Promise.allSettled(requests.map((request) => handleRequest(
    /** @type any*/
    request
  )));
  return responses.map((response, i) => {
    const request = (
      /** @type {import("@tevm/jsonrpc").JsonRpcRequest<string, object>} */
      requests[i]
    );
    if (response.status === "rejected") {
      client.logger.error(response.reason);
      return {
        id: request.id,
        method: request.method,
        jsonrpc: "2.0",
        error: {
          // TODO This should be added to @tevm/errors package and rexported in tevm
          code: response.reason.code ?? -32e3,
          message: response.reason.message ?? "UnexpectedBulkRequestError"
        }
      };
    }
    return response.value;
  });
};

exports.MissingAccountError = MissingAccountError;
exports.anvilDealJsonRpcProcedure = anvilDealJsonRpcProcedure;
exports.anvilDropTransactionJsonRpcProcedure = anvilDropTransactionJsonRpcProcedure;
exports.anvilDumpStateJsonRpcProcedure = anvilDumpStateJsonRpcProcedure;
exports.anvilGetAutomineJsonRpcProcedure = anvilGetAutomineJsonRpcProcedure;
exports.anvilImpersonateAccountJsonRpcProcedure = anvilImpersonateAccountJsonRpcProcedure;
exports.anvilLoadStateJsonRpcProcedure = anvilLoadStateJsonRpcProcedure;
exports.anvilResetJsonRpcProcedure = anvilResetJsonRpcProcedure;
exports.anvilSetBalanceJsonRpcProcedure = anvilSetBalanceJsonRpcProcedure;
exports.anvilSetChainIdJsonRpcProcedure = anvilSetChainIdJsonRpcProcedure;
exports.anvilSetCodeJsonRpcProcedure = anvilSetCodeJsonRpcProcedure;
exports.anvilSetCoinbaseJsonRpcProcedure = anvilSetCoinbaseJsonRpcProcedure;
exports.anvilSetNonceJsonRpcProcedure = anvilSetNonceJsonRpcProcedure;
exports.anvilSetStorageAtJsonRpcProcedure = anvilSetStorageAtJsonRpcProcedure;
exports.anvilStopImpersonatingAccountJsonRpcProcedure = anvilStopImpersonatingAccountJsonRpcProcedure;
exports.blockNumberHandler = blockNumberHandler;
exports.blockNumberProcedure = blockNumberProcedure;
exports.callHandler = callHandler2;
exports.callHandlerOpts = callHandlerOpts;
exports.callHandlerResult = callHandlerResult;
exports.callProcedure = callProcedure;
exports.chainIdHandler = chainIdHandler;
exports.chainIdProcedure = chainIdProcedure;
exports.cloneVmWithBlockTag = cloneVmWithBlockTag;
exports.contractHandler = contractHandler;
exports.dealHandler = dealHandler;
exports.debugTraceBlockJsonRpcProcedure = debugTraceBlockJsonRpcProcedure;
exports.debugTraceCallJsonRpcProcedure = debugTraceCallJsonRpcProcedure;
exports.debugTraceStateFilters = debugTraceStateFilters;
exports.debugTraceStateJsonRpcProcedure = debugTraceStateJsonRpcProcedure;
exports.debugTraceTransactionJsonRpcProcedure = debugTraceTransactionJsonRpcProcedure;
exports.deployHandler = deployHandler;
exports.dumpStateHandler = dumpStateHandler;
exports.dumpStateProcedure = dumpStateProcedure;
exports.ethAccountsHandler = ethAccountsHandler;
exports.ethAccountsProcedure = ethAccountsProcedure;
exports.ethBlobBaseFeeJsonRpcProcedure = ethBlobBaseFeeJsonRpcProcedure;
exports.ethCallHandler = ethCallHandler;
exports.ethCallProcedure = ethCallProcedure;
exports.ethCoinbaseJsonRpcProcedure = ethCoinbaseJsonRpcProcedure;
exports.ethCreateAccessListProcedure = ethCreateAccessListProcedure;
exports.ethEstimateGasJsonRpcProcedure = ethEstimateGasJsonRpcProcedure;
exports.ethGetBlockByHashJsonRpcProcedure = ethGetBlockByHashJsonRpcProcedure;
exports.ethGetBlockByNumberJsonRpcProcedure = ethGetBlockByNumberJsonRpcProcedure;
exports.ethGetBlockTransactionCountByHashJsonRpcProcedure = ethGetBlockTransactionCountByHashJsonRpcProcedure;
exports.ethGetBlockTransactionCountByNumberJsonRpcProcedure = ethGetBlockTransactionCountByNumberJsonRpcProcedure;
exports.ethGetFilterChangesProcedure = ethGetFilterChangesProcedure;
exports.ethGetFilterLogsProcedure = ethGetFilterLogsProcedure;
exports.ethGetLogsHandler = ethGetLogsHandler;
exports.ethGetLogsProcedure = ethGetLogsProcedure;
exports.ethGetTransactionByBlockHashAndIndexJsonRpcProcedure = ethGetTransactionByBlockHashAndIndexJsonRpcProcedure;
exports.ethGetTransactionByBlockNumberAndIndexJsonRpcProcedure = ethGetTransactionByBlockNumberAndIndexJsonRpcProcedure;
exports.ethGetTransactionByHashJsonRpcProcedure = ethGetTransactionByHashJsonRpcProcedure;
exports.ethGetTransactionCountProcedure = ethGetTransactionCountProcedure;
exports.ethGetTransactionReceiptHandler = ethGetTransactionReceiptHandler;
exports.ethGetTransactionReceiptJsonRpcProcedure = ethGetTransactionReceiptJsonRpcProcedure;
exports.ethNewBlockFilterProcedure = ethNewBlockFilterProcedure;
exports.ethNewFilterHandler = ethNewFilterHandler;
exports.ethNewFilterJsonRpcProcedure = ethNewFilterJsonRpcProcedure;
exports.ethNewPendingTransactionFilterProcedure = ethNewPendingTransactionFilterProcedure;
exports.ethProtocolVersionJsonRpcProcedure = ethProtocolVersionJsonRpcProcedure;
exports.ethSendRawTransactionHandler = ethSendRawTransactionHandler;
exports.ethSendRawTransactionJsonRpcProcedure = ethSendRawTransactionJsonRpcProcedure;
exports.ethSendTransactionHandler = ethSendTransactionHandler;
exports.ethSendTransactionJsonRpcProcedure = ethSendTransactionJsonRpcProcedure;
exports.ethSignHandler = ethSignHandler;
exports.ethSignProcedure = ethSignProcedure;
exports.ethSignTransactionHandler = ethSignTransactionHandler;
exports.ethSignTransactionProcedure = ethSignTransactionProcedure;
exports.ethUninstallFilterJsonRpcProcedure = ethUninstallFilterJsonRpcProcedure;
exports.executeCall = executeCall;
exports.forkAndCacheBlock = forkAndCacheBlock;
exports.gasPriceHandler = gasPriceHandler;
exports.gasPriceProcedure = gasPriceProcedure;
exports.getAccountHandler = getAccountHandler;
exports.getAccountProcedure = getAccountProcedure;
exports.getBalanceHandler = getBalanceHandler;
exports.getBalanceProcedure = getBalanceProcedure;
exports.getCodeHandler = getCodeHandler;
exports.getCodeProcedure = getCodeProcedure;
exports.getStorageAtHandler = getStorageAtHandler;
exports.getStorageAtProcedure = getStorageAtProcedure;
exports.handleAutomining = handleAutomining;
exports.handlePendingTransactionsWarning = handlePendingTransactionsWarning;
exports.handleRunTxError = handleRunTxError;
exports.handleTransactionCreation = handleTransactionCreation;
exports.loadStateHandler = loadStateHandler;
exports.loadStateProcedure = loadStateProcedure;
exports.mineHandler = mineHandler;
exports.mineProcedure = mineProcedure;
exports.requestBulkProcedure = requestBulkProcedure;
exports.requestProcedure = requestProcedure;
exports.setAccountHandler = setAccountHandler;
exports.setAccountProcedure = setAccountProcedure;
exports.shouldAddToBlockchain = shouldAddToBlockchain;
exports.shouldCreateTransaction = shouldCreateTransaction;
exports.traceCallHandler = traceCallHandler;
exports.validateBaseCallParams = validateBaseCallParams;
exports.validateCallParams = validateCallParams;
exports.validateContractParams = validateContractParams;
exports.validateGetAccountParams = validateGetAccountParams;
exports.validateLoadStateParams = validateLoadStateParams;
exports.validateMineEvents = validateMineEvents;
exports.validateMineParams = validateMineParams;
exports.validateSetAccountParams = validateSetAccountParams;
exports.zAbi = zAbi;
exports.zAddress = zAddress;
exports.zBaseCallParams = zBaseCallParams;
exports.zBlock = zBlock;
exports.zBlockOverrideSet = zBlockOverrideSet;
exports.zBlockParam = zBlockParam;
exports.zBytecode = zBytecode;
exports.zCallParams = zCallParams;
exports.zContractParams = zContractParams;
exports.zGetAccountParams = zGetAccountParams;
exports.zHex = zHex;
exports.zLoadStateParams = zLoadStateParams;
exports.zMineParams = zMineParams;
exports.zSetAccountParams = zSetAccountParams;
exports.zStateOverrideSet = zStateOverrideSet;
exports.zStorageRoot = zStorageRoot;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map