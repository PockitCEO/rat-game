/**
 * Zod validator for a valid contract action
 */
export const zContractParams: z.ZodIntersection<z.ZodObject<{
    throwOnFail: z.ZodOptional<z.ZodBoolean>;
    createTrace: z.ZodOptional<z.ZodBoolean>;
    createAccessList: z.ZodOptional<z.ZodBoolean>;
    createTransaction: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    addToMempool: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    addToBlockchain: z.ZodUnion<readonly [z.ZodOptional<z.ZodBoolean>, z.ZodLiteral<"on-success">, z.ZodLiteral<"always">, z.ZodLiteral<"never">]>;
    skipBalance: z.ZodOptional<z.ZodBoolean>;
    gasRefund: z.ZodOptional<z.ZodBigInt>;
    blockTag: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"latest">, z.ZodLiteral<"earliest">, z.ZodLiteral<"pending">, z.ZodLiteral<"safe">, z.ZodLiteral<"finalized">, z.ZodBigInt, z.ZodPipe<z.ZodNumber, z.ZodTransform<bigint, number>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>]>>;
    gasPrice: z.ZodOptional<z.ZodBigInt>;
    origin: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    caller: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    gas: z.ZodOptional<z.ZodBigInt>;
    value: z.ZodOptional<z.ZodBigInt>;
    depth: z.ZodOptional<z.ZodNumber>;
    selfdestruct: z.ZodOptional<z.ZodSet<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>>;
    to: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    blobVersionedHashes: z.ZodOptional<z.ZodArray<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    stateOverrideSet: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>, z.ZodObject<{
        balance: z.ZodOptional<z.ZodBigInt>;
        nonce: z.ZodOptional<z.ZodBigInt>;
        code: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
        state: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
        stateDiff: z.ZodOptional<z.ZodRecord<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>, z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>>;
    }, z.core.$strict>>>;
    blockOverrideSet: z.ZodOptional<z.ZodObject<{
        number: z.ZodOptional<z.ZodBigInt>;
        time: z.ZodOptional<z.ZodBigInt>;
        gasLimit: z.ZodOptional<z.ZodBigInt>;
        coinbase: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
        baseFee: z.ZodOptional<z.ZodBigInt>;
        blobBaseFee: z.ZodOptional<z.ZodBigInt>;
    }, z.core.$strict>>;
    maxFeePerGas: z.ZodOptional<z.ZodBigInt>;
    maxPriorityFeePerGas: z.ZodOptional<z.ZodBigInt>;
    onStep: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onNewContract: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onBeforeMessage: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
    onAfterMessage: z.ZodOptional<z.ZodOptional<z.ZodFunction<z.core.$ZodFunctionArgs, z.core.$ZodFunctionOut>>>;
}, z.core.$strip>, z.ZodObject<{
    to: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<string, string>>>;
    abi: z.ZodReadonly<any>;
    args: z.ZodOptional<z.ZodArray<z.ZodAny>>;
    functionName: z.ZodString;
    code: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
    deployedBytecode: z.ZodOptional<z.ZodPipe<z.ZodString, z.ZodTransform<`0x${string}`, string>>>;
}, z.core.$strip>>;
import { z } from 'zod';
//# sourceMappingURL=zContractParams.d.ts.map