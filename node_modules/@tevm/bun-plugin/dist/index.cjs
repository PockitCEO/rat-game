'use strict';

var fs = require('fs');
var promises = require('fs/promises');
var baseBundler = require('@tevm/base-bundler');
var bundlerCache = require('@tevm/bundler-cache');
var config = require('@tevm/config');
var solc = require('@tevm/solc');
var Effect = require('effect/Effect');
var defaultSolc = require('solc');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var defaultSolc__default = /*#__PURE__*/_interopDefault(defaultSolc);

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/bunFile.js
var file = __require("bun").file;
var bunFileAccesObject = {
  /**
   * Synchronously checks if a file exists
   * @param {string} path - Path to the file
   * @returns {boolean} - True if the file exists, false otherwise
   */
  existsSync: fs.existsSync,
  /**
   * Asynchronously checks if a file exists using Bun's optimized file API
   * @param {string} filePath - Path to the file
   * @returns {Promise<boolean>} - Promise resolving to true if the file exists, false otherwise
   */
  exists: (filePath) => {
    const bunFile = file(filePath);
    return bunFile.exists();
  },
  /**
   * Asynchronously reads a file as text using Bun's optimized file API
   * @param {string} filePath - Path to the file
   * @param {BufferEncoding} _encoding - Encoding (ignored, Bun defaults to utf8)
   * @returns {Promise<string>} - Promise resolving to the file contents
   */
  readFile: (filePath, _encoding) => {
    const bunFile = file(filePath);
    return bunFile.text();
  },
  /**
   * Synchronously reads a file as text
   * @param {string} path - Path to the file
   * @param {BufferEncoding} encoding - Encoding to use
   * @returns {string} - File contents
   */
  readFileSync: fs.readFileSync,
  /**
   * Synchronously writes data to a file using Bun's optimized file API
   * @param {string} filePath - Path to the file
   * @param {string} data - Data to write
   * @returns {number} - Non 0 if successful
   */
  writeFileSync: (filePath, data) => {
    const bunFile = file(filePath);
    return bunFile.writer().write(data);
  },
  /**
   * Synchronously gets file stats
   * @param {string} path - Path to the file
   * @returns {import('fs').Stats} - File stats
   */
  statSync: fs.statSync,
  /**
   * Asynchronously gets file stats
   * @param {string} path - Path to the file
   * @returns {Promise<import('fs').Stats>} - Promise resolving to file stats
   */
  stat: promises.stat,
  /**
   * Synchronously creates a directory
   * @param {string} path - Path to create
   * @param {import('fs').MakeDirectoryOptions} [options] - Options
   * @returns {string|undefined} - The first directory path created, or undefined
   */
  mkdirSync: fs.mkdirSync,
  /**
   * Asynchronously creates a directory
   * @param {string} path - Path to create
   * @param {import('fs').MakeDirectoryOptions} [options] - Options
   * @returns {Promise<string|undefined>} - Promise resolving to the first directory path created, or undefined
   */
  mkdir: promises.mkdir,
  /**
   * Asynchronously writes data to a file
   * @param {string} path - Path to the file
   * @param {string|NodeJS.ArrayBufferView} data - Data to write
   * @param {import('fs').WriteFileOptions} [options] - Options
   * @returns {Promise<void>} - Promise resolving when write is complete
   */
  writeFile: promises.writeFile
};
var bunPluginTevm = ({ solc: solc$1 = defaultSolc__default.default.version }) => {
  return {
    name: "@tevm/bun-plugin",
    async setup(build) {
      const config$1 = Effect.runSync(
        config.loadConfig(process.cwd()).pipe(
          Effect.catchTag(
            "FailedToReadConfigError",
            () => Effect.logWarning("Unable to find tevm.config.json. Using default config.").pipe(Effect.map(() => config.defaultConfig))
          )
        )
      );
      const solcCache = bundlerCache.createCache(config$1.cacheDir, bunFileAccesObject, process.cwd());
      const moduleResolver = baseBundler.bundler(
        config$1,
        console,
        bunFileAccesObject,
        solc$1 === defaultSolc__default.default.version ? defaultSolc__default.default : await solc.createSolc(solc$1),
        solcCache
      );
      build.onResolve({ filter: /^@tevm\/contract/ }, ({ path, importer }) => {
        if (path.startsWith("@tevm/contract") && !importer.startsWith(process.cwd()) && !importer.includes("node_modules")) {
          return {
            path: __require.resolve("@tevm/contract")
          };
        }
        return {
          path: __require.resolve(path)
        };
      });
      build.onLoad({ filter: /\.sol$/ }, async ({ path }) => {
        const filePaths = [`${path}.ts`, `${path}.js`, `${path}.mjs`, `${path}.cjs`];
        const existsArr = await Promise.all(filePaths.map((filePath) => bunFileAccesObject.exists(filePath)));
        for (const [i, exists] of existsArr.entries()) {
          if (exists) {
            return {
              contents: await bunFileAccesObject.readFile(
                /** @type {any} */
                filePaths[i],
                "utf8"
              ),
              watchFiles: [filePaths[i]]
            };
          }
        }
        const resolveBytecode = path.endsWith(".s.sol");
        const { code: contents, modules } = await moduleResolver.resolveEsmModule(
          path,
          process.cwd(),
          false,
          // Don't include AST
          resolveBytecode
          // Include bytecode for script files
        );
        const watchFiles = Object.values(modules).filter(({ id }) => !id.includes("node_modules")).map(({ id }) => id);
        return { contents, watchFiles };
      });
    }
  };
};

exports.bunFileAccesObject = bunFileAccesObject;
exports.bunPluginTevm = bunPluginTevm;
exports.file = file;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map