'use strict';

var unplugin = require('unplugin');
var module$1 = require('module');
var baseBundler = require('@tevm/base-bundler');
var bundlerCache = require('@tevm/bundler-cache');
var config = require('@tevm/config');
var solc = require('@tevm/solc');
var Effect = require('effect/Effect');
var defaultSolc = require('solc');
var zod = require('zod');
var fs = require('fs');
var promises = require('fs/promises');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var defaultSolc__default = /*#__PURE__*/_interopDefault(defaultSolc);

// src/index.ts
var fao = {
  /**
   * Synchronously checks if a file exists
   * @param {string} path - Path to the file
   * @returns {boolean} - True if the file exists, false otherwise
   */
  existsSync: fs.existsSync,
  /**
   * Asynchronously reads a file as text
   * @param {string} path - Path to the file
   * @param {BufferEncoding} encoding - File encoding
   * @returns {Promise<string>} - Promise resolving to file contents
   */
  readFile: promises.readFile,
  /**
   * Synchronously reads a file as text
   * @param {string} path - Path to the file
   * @param {BufferEncoding} encoding - File encoding
   * @returns {string} - File contents
   */
  readFileSync: fs.readFileSync,
  /**
   * Synchronously writes data to a file
   * @param {string} path - Path to the file
   * @param {string} data - Data to write
   * @returns {void}
   */
  writeFileSync: fs.writeFileSync,
  /**
   * Synchronously gets file stats
   * @param {string} path - Path to the file
   * @returns {import('fs').Stats} - File stats
   */
  statSync: fs.statSync,
  /**
   * Asynchronously gets file stats
   * @param {string} path - Path to the file
   * @returns {Promise<import('fs').Stats>} - Promise resolving to file stats
   */
  stat: promises.stat,
  /**
   * Synchronously creates a directory
   * @param {string} path - Path to create
   * @param {import('fs').MakeDirectoryOptions} [options] - Options
   * @returns {string|undefined} - Path to created directory
   */
  mkdirSync: fs.mkdirSync,
  /**
   * Asynchronously writes data to a file
   * @param {string} path - Path to the file
   * @param {string} data - Data to write
   * @returns {Promise<void>} - Promise that resolves when write is complete
   */
  writeFile: promises.writeFile,
  /**
   * Asynchronously creates a directory
   * @param {string} path - Path to create
   * @param {import('fs').MakeDirectoryOptions} [options] - Options
   * @returns {Promise<string|undefined>} - Promise resolving to created directory path
   */
  mkdir: promises.mkdir,
  /**
   * Asynchronously checks if a file exists
   * @param {string} path - Path to the file
   * @returns {Promise<boolean>} - Promise resolving to true if file exists, false otherwise
   */
  exists: async (path) => {
    try {
      await promises.access(path);
      return true;
    } catch (_e) {
      return false;
    }
  }
};

// src/tevmUnplugin.js
var defaultVersion = defaultSolc__default.default.version().slice(0, defaultSolc__default.default.version().indexOf("+"));
var compilerOptionValidator = zod.z.union(
  /**
   * @type {any}
   */
  Object.keys(solc.releases).map((release) => zod.z.literal(release))
).default(defaultVersion).describe(`Solc compiler version to use. Defaults to ${defaultVersion}}`);
var bundlers = {
  solc: baseBundler.bundler
};
var tevmUnplugin = (options = {}) => {
  let config$1;
  const parsedSolcVersion = compilerOptionValidator.safeParse(options.solc);
  if (!parsedSolcVersion.success) {
    console.error(parsedSolcVersion.error);
    throw new Error(`Invalid solc compiler passed to Tevm plugin'`);
  }
  const bundler2 = bundlers.solc;
  let moduleResolver;
  return {
    name: "@tevm/rollup-plugin",
    /**
     * Make this plugin run before other plugins
     * We do this so other plugins (specifically webpack ones) don't barf on the solidity imports
     */
    enforce: "pre",
    async buildStart() {
      config$1 = await Effect.runPromise(
        config.loadConfig(process.cwd()).pipe(
          Effect.catchTag(
            "FailedToReadConfigError",
            () => Effect.logWarning("Unable to find tevm.config.json. Using default config.").pipe(Effect.map(() => config.defaultConfig))
          )
        )
      );
      const solcCache = bundlerCache.createCache(config$1.cacheDir, fao, process.cwd());
      console.log("proces.cwd()", process.cwd());
      const contractPackage = baseBundler.getContractPath(process.cwd());
      const versionedSolc = parsedSolcVersion.data === defaultVersion ? defaultSolc__default.default : await solc.createSolc(parsedSolcVersion.data);
      moduleResolver = bundler2(config$1, console, fao, versionedSolc, solcCache, contractPackage);
    },
    loadInclude: (id) => {
      return id.endsWith(".sol") && !fao.existsSync(`${id}.ts`) && !fao.existsSync(`${id}.d.ts`);
    },
    async resolveId(id, importer) {
      if (id.startsWith("@tevm/contract") && !(importer == null ? void 0 : importer.startsWith(process.cwd())) && !(importer == null ? void 0 : importer.includes("node_modules"))) {
        return module$1.createRequire(`${process.cwd()}/`).resolve("@tevm/contract");
      }
      return null;
    },
    async load(id) {
      const resolveBytecode = id.endsWith(".s.sol");
      const { code, modules } = await moduleResolver.resolveEsmModule(id, process.cwd(), false, resolveBytecode);
      Object.values(modules).forEach((module) => {
        if (module.id.includes("node_modules")) {
          return;
        }
        this.addWatchFile(module.id);
      });
      return code;
    },
    ...{ version: "0.11.2" }
  };
};

Object.defineProperty(exports, "createUnplugin", {
  enumerable: true,
  get: function () { return unplugin.createUnplugin; }
});
exports.tevmUnplugin = tevmUnplugin;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map