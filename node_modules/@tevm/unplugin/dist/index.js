export { createUnplugin } from 'unplugin';
import { createRequire } from 'module';
import { getContractPath, bundler } from '@tevm/base-bundler';
import { createCache } from '@tevm/bundler-cache';
import { loadConfig, defaultConfig } from '@tevm/config';
import { releases, createSolc } from '@tevm/solc';
import { runPromise, catchTag, logWarning, map } from 'effect/Effect';
import defaultSolc from 'solc';
import { z } from 'zod';
import { existsSync, mkdirSync, statSync, writeFileSync, readFileSync } from 'fs';
import { mkdir, writeFile, stat, readFile, access } from 'fs/promises';

// src/index.ts
var fao = {
  /**
   * Synchronously checks if a file exists
   * @param {string} path - Path to the file
   * @returns {boolean} - True if the file exists, false otherwise
   */
  existsSync,
  /**
   * Asynchronously reads a file as text
   * @param {string} path - Path to the file
   * @param {BufferEncoding} encoding - File encoding
   * @returns {Promise<string>} - Promise resolving to file contents
   */
  readFile,
  /**
   * Synchronously reads a file as text
   * @param {string} path - Path to the file
   * @param {BufferEncoding} encoding - File encoding
   * @returns {string} - File contents
   */
  readFileSync,
  /**
   * Synchronously writes data to a file
   * @param {string} path - Path to the file
   * @param {string} data - Data to write
   * @returns {void}
   */
  writeFileSync,
  /**
   * Synchronously gets file stats
   * @param {string} path - Path to the file
   * @returns {import('fs').Stats} - File stats
   */
  statSync,
  /**
   * Asynchronously gets file stats
   * @param {string} path - Path to the file
   * @returns {Promise<import('fs').Stats>} - Promise resolving to file stats
   */
  stat,
  /**
   * Synchronously creates a directory
   * @param {string} path - Path to create
   * @param {import('fs').MakeDirectoryOptions} [options] - Options
   * @returns {string|undefined} - Path to created directory
   */
  mkdirSync,
  /**
   * Asynchronously writes data to a file
   * @param {string} path - Path to the file
   * @param {string} data - Data to write
   * @returns {Promise<void>} - Promise that resolves when write is complete
   */
  writeFile,
  /**
   * Asynchronously creates a directory
   * @param {string} path - Path to create
   * @param {import('fs').MakeDirectoryOptions} [options] - Options
   * @returns {Promise<string|undefined>} - Promise resolving to created directory path
   */
  mkdir,
  /**
   * Asynchronously checks if a file exists
   * @param {string} path - Path to the file
   * @returns {Promise<boolean>} - Promise resolving to true if file exists, false otherwise
   */
  exists: async (path) => {
    try {
      await access(path);
      return true;
    } catch (_e) {
      return false;
    }
  }
};

// src/tevmUnplugin.js
var defaultVersion = defaultSolc.version().slice(0, defaultSolc.version().indexOf("+"));
var compilerOptionValidator = z.union(
  /**
   * @type {any}
   */
  Object.keys(releases).map((release) => z.literal(release))
).default(defaultVersion).describe(`Solc compiler version to use. Defaults to ${defaultVersion}}`);
var bundlers = {
  solc: bundler
};
var tevmUnplugin = (options = {}) => {
  let config;
  const parsedSolcVersion = compilerOptionValidator.safeParse(options.solc);
  if (!parsedSolcVersion.success) {
    console.error(parsedSolcVersion.error);
    throw new Error(`Invalid solc compiler passed to Tevm plugin'`);
  }
  const bundler2 = bundlers.solc;
  let moduleResolver;
  return {
    name: "@tevm/rollup-plugin",
    /**
     * Make this plugin run before other plugins
     * We do this so other plugins (specifically webpack ones) don't barf on the solidity imports
     */
    enforce: "pre",
    async buildStart() {
      config = await runPromise(
        loadConfig(process.cwd()).pipe(
          catchTag(
            "FailedToReadConfigError",
            () => logWarning("Unable to find tevm.config.json. Using default config.").pipe(map(() => defaultConfig))
          )
        )
      );
      const solcCache = createCache(config.cacheDir, fao, process.cwd());
      console.log("proces.cwd()", process.cwd());
      const contractPackage = getContractPath(process.cwd());
      const versionedSolc = parsedSolcVersion.data === defaultVersion ? defaultSolc : await createSolc(parsedSolcVersion.data);
      moduleResolver = bundler2(config, console, fao, versionedSolc, solcCache, contractPackage);
    },
    loadInclude: (id) => {
      return id.endsWith(".sol") && !fao.existsSync(`${id}.ts`) && !fao.existsSync(`${id}.d.ts`);
    },
    async resolveId(id, importer) {
      if (id.startsWith("@tevm/contract") && !(importer == null ? void 0 : importer.startsWith(process.cwd())) && !(importer == null ? void 0 : importer.includes("node_modules"))) {
        return createRequire(`${process.cwd()}/`).resolve("@tevm/contract");
      }
      return null;
    },
    async load(id) {
      const resolveBytecode = id.endsWith(".s.sol");
      const { code, modules } = await moduleResolver.resolveEsmModule(id, process.cwd(), false, resolveBytecode);
      Object.values(modules).forEach((module) => {
        if (module.id.includes("node_modules")) {
          return;
        }
        this.addWatchFile(module.id);
      });
      return code;
    },
    ...{ version: "0.11.2" }
  };
};

export { tevmUnplugin };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map