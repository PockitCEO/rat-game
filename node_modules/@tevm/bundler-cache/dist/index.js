// src/getArtifactsPath.js
var getArtifactsPath = (entryModuleId, item, cwd, cacheDir) => {
  const fileName = {
    dts: "contract.d.ts",
    // TypeScript declaration file
    artifactsJson: "artifacts.json",
    // Solidity compilation artifacts
    mjs: "contract.mjs"
    // ES module JavaScript file
  }[item];
  let normalizedEntryModuleId = entryModuleId.replace(cwd, "");
  if (normalizedEntryModuleId.startsWith("/")) {
    normalizedEntryModuleId = normalizedEntryModuleId.slice(1);
  }
  const dir = [cwd, cacheDir, normalizedEntryModuleId].join("/");
  const path = [dir, fileName].join("/");
  return { dir, path };
};

// src/getMetadataPath.js
var getMetadataPath = (entryModuleId, cwd, cacheDir) => {
  let normalizedEntryModuleId = entryModuleId.replace(cwd, "");
  if (normalizedEntryModuleId.startsWith("/")) {
    normalizedEntryModuleId = normalizedEntryModuleId.slice(1);
  }
  const dir = [cwd, cacheDir, normalizedEntryModuleId].join("/");
  const path = [dir, "metadata.json"].join("/");
  return { dir, path };
};

// src/version.js
var version = "1.x.x";

// src/readArtifacts.js
var readArtifacts = async (cacheDir, fs, cwd, entryModuleId) => {
  const { path: artifactsPath } = getArtifactsPath(entryModuleId, "artifactsJson", cwd, cacheDir);
  const { path: metadataPath } = getMetadataPath(entryModuleId, cwd, cacheDir);
  if (!await fs.exists(artifactsPath) || !await fs.exists(metadataPath)) {
    return void 0;
  }
  const metadata = JSON.parse(await fs.readFile(metadataPath, "utf8"));
  const didContentChange = version !== metadata.version || (await Promise.all(
    Object.entries(metadata.files).map(async ([sourcePath, timestamp]) => {
      const didChange = timestamp !== (await fs.stat(sourcePath)).mtimeMs;
      return didChange;
    })
  )).some((didChange) => didChange);
  if (didContentChange) {
    return void 0;
  }
  const content = await fs.readFile(artifactsPath, "utf8");
  try {
    return JSON.parse(content);
  } catch (_e) {
    throw new Error(`Cache miss for ${entryModuleId} because it isn't valid json`);
  }
};

// src/readArtifactsSync.js
var readArtifactsSync = (cacheDir, fs, cwd, entryModuleId) => {
  const { path: artifactsPath } = getArtifactsPath(entryModuleId, "artifactsJson", cwd, cacheDir);
  const { path: metadataPath } = getMetadataPath(entryModuleId, cwd, cacheDir);
  if (!fs.existsSync(artifactsPath) || !fs.existsSync(metadataPath)) {
    return void 0;
  }
  const metadata = JSON.parse(fs.readFileSync(metadataPath, "utf8"));
  const didContentChange = metadata.version !== version || Object.entries(metadata.files).some(([sourcePath, timestamp]) => {
    return timestamp !== fs.statSync(sourcePath).mtimeMs;
  });
  if (didContentChange) {
    return void 0;
  }
  const content = fs.readFileSync(artifactsPath, "utf8");
  try {
    return JSON.parse(content);
  } catch (_e) {
    throw new Error(`Cache miss for ${entryModuleId} because it isn't valid json`);
  }
};

// src/writeArtifacts.js
var writeArtifacts = async (cwd, cacheDir, entryModuleId, resolvedArtifacts, fs) => {
  var _a;
  const { dir, path } = getArtifactsPath(entryModuleId, "artifactsJson", cwd, cacheDir);
  const { path: metadataPath } = getMetadataPath(entryModuleId, cwd, cacheDir);
  if (!await fs.exists(dir)) {
    await fs.mkdir(dir, { recursive: true });
  }
  await Promise.all([
    // Write artifacts.json with the full compilation results
    fs.writeFile(path, JSON.stringify(resolvedArtifacts, null, 2)),
    // Write metadata.json with cache validation information
    fs.writeFile(
      metadataPath,
      JSON.stringify(
        {
          // Current cache version for compatibility checks
          version,
          // File modification timestamps for dependency tracking
          files: Object.fromEntries(
            Object.keys(((_a = resolvedArtifacts.solcInput) == null ? void 0 : _a.sources) || {}).map((sourcePath) => {
              return [sourcePath, fs.statSync(sourcePath).mtimeMs];
            })
          )
        },
        null,
        2
      )
    )
  ]);
  return path;
};

// src/writeArtifactsSync.js
var writeArtifactsSync = (cwd, cacheDir, entryModuleId, resolvedArtifacts, fs) => {
  var _a;
  const { dir, path } = getArtifactsPath(entryModuleId, "artifactsJson", cwd, cacheDir);
  const { path: metadataPath } = getMetadataPath(entryModuleId, cwd, cacheDir);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(path, JSON.stringify(resolvedArtifacts, null, 2));
  fs.writeFileSync(
    metadataPath,
    JSON.stringify(
      {
        // Current cache version for compatibility checks
        version,
        // File modification timestamps for dependency tracking
        files: Object.fromEntries(
          Object.keys(((_a = resolvedArtifacts.solcInput) == null ? void 0 : _a.sources) || {}).map((sourcePath) => {
            return [sourcePath, fs.statSync(sourcePath).mtimeMs];
          })
        )
      },
      null,
      2
    )
  );
  return path;
};

// src/createCache.js
var createCache = (cacheDir, fs, cwd) => {
  return {
    /**
     * Synchronously writes compiled Solidity artifacts to the cache
     * @param {string} entryModuleId - Path to the Solidity file being cached
     * @param {import('@tevm/compiler').ResolvedArtifacts} compiledContracts - Compilation result
     * @returns {string} Path where artifacts were written
     */
    writeArtifactsSync: (entryModuleId, compiledContracts) => {
      return writeArtifactsSync(cwd, cacheDir, entryModuleId, compiledContracts, fs);
    },
    /**
     * Asynchronously writes compiled Solidity artifacts to the cache
     * @param {string} entryModuleId - Path to the Solidity file being cached
     * @param {import('@tevm/compiler').ResolvedArtifacts} compiledContracts - Compilation result
     * @returns {Promise<string>} Path where artifacts were written
     */
    writeArtifacts: async (entryModuleId, compiledContracts) => {
      return writeArtifacts(cwd, cacheDir, entryModuleId, compiledContracts, fs);
    },
    /**
     * Synchronously reads compiled Solidity artifacts from the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @returns {import('@tevm/compiler').ResolvedArtifacts|undefined} Cached artifacts if found
     */
    readArtifactsSync: (entryModuleId) => {
      return readArtifactsSync(cacheDir, fs, cwd, entryModuleId);
    },
    /**
     * Asynchronously reads compiled Solidity artifacts from the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @returns {Promise<import('@tevm/compiler').ResolvedArtifacts|undefined>} Cached artifacts if found
     */
    readArtifacts: async (entryModuleId) => {
      return readArtifacts(cacheDir, fs, cwd, entryModuleId);
    },
    /**
     * Synchronously writes TypeScript declaration (.d.ts) file to the cache
     *
     * Note: TypeScript declarations are primarily cached for debugging and
     * to support TypeScript compiler plugins.
     *
     * @param {string} entryModuleId - Path to the Solidity file
     * @param {string} dtsFile - Content of the TypeScript declaration file
     * @returns {string} Path where the file was written
     */
    writeDtsSync: (entryModuleId, dtsFile) => {
      const { path: dtsPath, dir: dtsDir } = getArtifactsPath(entryModuleId, "dts", cwd, cacheDir);
      fs.mkdirSync(dtsDir, { recursive: true });
      fs.writeFileSync(dtsPath, dtsFile);
      return dtsPath;
    },
    /**
     * Asynchronously writes TypeScript declaration (.d.ts) file to the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @param {string} dtsFile - Content of the TypeScript declaration file
     * @returns {Promise<string>} Path where the file was written
     */
    writeDts: async (entryModuleId, dtsFile) => {
      const { path: dtsPath, dir: dtsDir } = getArtifactsPath(entryModuleId, "dts", cwd, cacheDir);
      await fs.mkdir(dtsDir, { recursive: true });
      await fs.writeFile(dtsPath, dtsFile);
      return dtsPath;
    },
    /**
     * Synchronously reads TypeScript declaration file from the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @returns {string|undefined} Content of the declaration file if found
     */
    readDtsSync: (entryModuleId) => {
      const { path: dtsPath } = getArtifactsPath(entryModuleId, "dts", cwd, cacheDir);
      if (!fs.existsSync(dtsPath)) {
        return void 0;
      }
      return fs.readFileSync(dtsPath, "utf8");
    },
    /**
     * Asynchronously reads TypeScript declaration file from the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @returns {Promise<string|undefined>} Content of the declaration file if found
     */
    readDts: async (entryModuleId) => {
      const { path: dtsPath } = getArtifactsPath(entryModuleId, "dts", cwd, cacheDir);
      if (!await fs.exists(dtsPath)) {
        return void 0;
      }
      return fs.readFile(dtsPath, "utf8");
    },
    /**
     * Synchronously writes ES module (.mjs) file to the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @param {string} mjsFile - Content of the ES module file
     * @returns {string} Path where the file was written
     */
    writeMjsSync: (entryModuleId, mjsFile) => {
      const { path: mjsPath, dir: mjsDir } = getArtifactsPath(entryModuleId, "mjs", cwd, cacheDir);
      fs.mkdirSync(mjsDir, { recursive: true });
      fs.writeFileSync(mjsPath, mjsFile);
      return mjsPath;
    },
    /**
     * Asynchronously writes ES module (.mjs) file to the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @param {string} mjsFile - Content of the ES module file
     * @returns {Promise<string>} Path where the file was written
     */
    writeMjs: async (entryModuleId, mjsFile) => {
      const { path: mjsPath, dir: mjsDir } = getArtifactsPath(entryModuleId, "mjs", cwd, cacheDir);
      await fs.mkdir(mjsDir, { recursive: true });
      await fs.writeFile(mjsPath, mjsFile);
      return mjsPath;
    },
    /**
     * Synchronously reads ES module file from the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @returns {string|undefined} Content of the ES module file if found
     */
    readMjsSync: (entryModuleId) => {
      const { path: mjsPath } = getArtifactsPath(entryModuleId, "mjs", cwd, cacheDir);
      if (!fs.existsSync(mjsPath)) {
        return void 0;
      }
      return fs.readFileSync(mjsPath, "utf8");
    },
    /**
     * Asynchronously reads ES module file from the cache
     * @param {string} entryModuleId - Path to the Solidity file
     * @returns {Promise<string|undefined>} Content of the ES module file if found
     */
    readMjs: async (entryModuleId) => {
      const { path: mjsPath } = getArtifactsPath(entryModuleId, "mjs", cwd, cacheDir);
      if (!await fs.exists(mjsPath)) {
        return void 0;
      }
      return fs.readFile(mjsPath, "utf8");
    }
  };
};

export { createCache };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map