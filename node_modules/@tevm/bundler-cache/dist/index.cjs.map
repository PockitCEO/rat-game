{"version":3,"sources":["../src/getArtifactsPath.js","../src/getMetadataPath.js","../src/version.js","../src/readArtifacts.js","../src/readArtifactsSync.js","../src/writeArtifacts.js","../src/writeArtifactsSync.js","../src/createCache.js"],"names":[],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Resolves the path for a cached artifact file based on the Solidity module path.\n *\n * This function calculates where cached files for a specific Solidity module should\n * be stored in the cache directory. It normalizes the module path relative to the\n * current working directory and appends the appropriate filename based on the item type.\n *\n * @param {string} entryModuleId - Path to the Solidity file (absolute path)\n * @param {import('./types.js').CachedItem} item - Type of cached item ('dts', 'artifactsJson', or 'mjs')\n * @param {string} cwd - Current working directory\n * @param {string} cacheDir - Cache directory (relative to cwd)\n * @returns {{dir: string, path: string}} Object containing the directory and full path\n *   - dir: Directory where the cached file should be stored\n *   - path: Full path to the cached file including filename\n *\n * @example\n * ```javascript\n * import { getArtifactsPath } from '@tevm/bundler-cache'\n *\n * // Get path for cached TypeScript declarations\n * const { dir, path } = getArtifactsPath(\n *   '/projects/my-dapp/contracts/Token.sol',  // Solidity file path\n *   'dts',                                   // TypeScript declarations\n *   '/projects/my-dapp',                     // Current working directory\n *   '.tevm'                                  // Cache directory\n * )\n *\n * console.log(dir)   // '/projects/my-dapp/.tevm/contracts/Token.sol'\n * console.log(path)  // '/projects/my-dapp/.tevm/contracts/Token.sol/contract.d.ts'\n * ```\n *\n * @internal\n */\nexport const getArtifactsPath = (entryModuleId, item, cwd, cacheDir) => {\n\t// Select the appropriate filename based on the item type\n\tconst fileName = {\n\t\tdts: 'contract.d.ts', // TypeScript declaration file\n\t\tartifactsJson: 'artifacts.json', // Solidity compilation artifacts\n\t\tmjs: 'contract.mjs', // ES module JavaScript file\n\t}[item]\n\n\t// Normalize the module path relative to current working directory\n\tlet normalizedEntryModuleId = entryModuleId.replace(cwd, '')\n\tif (normalizedEntryModuleId.startsWith('/')) {\n\t\tnormalizedEntryModuleId = normalizedEntryModuleId.slice(1)\n\t}\n\n\t// TODO: Fix path handling for Windows\n\t// Create the cache directory path and full file path\n\tconst dir = [cwd, cacheDir, normalizedEntryModuleId].join('/')\n\tconst path = [dir, fileName].join('/')\n\n\treturn { dir, path }\n}\n","/**\n * Resolves the path for the metadata file associated with a Solidity module.\n *\n * The metadata file contains information about the Solidity file and its dependencies,\n * including file modification timestamps which are used for cache invalidation.\n *\n * @param {string} entryModuleId - Path to the Solidity file (absolute path)\n * @param {string} cwd - Current working directory\n * @param {string} cacheDir - Cache directory (relative to cwd)\n * @returns {{dir: string, path: string}} Object containing the directory and full path\n *   - dir: Directory where the metadata file should be stored\n *   - path: Full path to the metadata.json file\n *\n * @example\n * ```javascript\n * import { getMetadataPath } from '@tevm/bundler-cache'\n *\n * // Get path for metadata file\n * const { dir, path } = getMetadataPath(\n *   '/projects/my-dapp/contracts/Token.sol',  // Solidity file path\n *   '/projects/my-dapp',                     // Current working directory\n *   '.tevm'                                  // Cache directory\n * )\n *\n * console.log(dir)   // '/projects/my-dapp/.tevm/contracts/Token.sol'\n * console.log(path)  // '/projects/my-dapp/.tevm/contracts/Token.sol/metadata.json'\n * ```\n *\n * @internal\n */\nexport const getMetadataPath = (entryModuleId, cwd, cacheDir) => {\n\t// Normalize the module path relative to current working directory\n\tlet normalizedEntryModuleId = entryModuleId.replace(cwd, '')\n\tif (normalizedEntryModuleId.startsWith('/')) {\n\t\tnormalizedEntryModuleId = normalizedEntryModuleId.slice(1)\n\t}\n\n\t// TODO: Fix path handling for Windows\n\t// Create the cache directory path and full file path for metadata\n\tconst dir = [cwd, cacheDir, normalizedEntryModuleId].join('/')\n\tconst path = [dir, 'metadata.json'].join('/')\n\n\treturn { dir, path }\n}\n","/**\n * Current cache version identifier used to track cache compatibility.\n *\n * This version string is stored in the metadata.json file and is used to\n * determine if cached files are compatible with the current bundler version.\n * When significant changes are made to the caching system, this version\n * should be updated to invalidate existing caches.\n *\n * @type {string}\n * @internal\n */\nexport const version = '1.x.x'\n","import { getArtifactsPath } from './getArtifactsPath.js'\nimport { getMetadataPath } from './getMetadataPath.js'\nimport { version } from './version.js'\n\n/**\n * Asynchronously reads Solidity compilation artifacts from the cache.\n *\n * This function checks if valid cached artifacts exist for the specified Solidity file\n * and returns them if they're up-to-date. It performs several validation steps:\n *\n * 1. Checks if both artifacts.json and metadata.json files exist\n * 2. Verifies if the cache version matches the current version\n * 3. Checks if any source files have been modified since the cache was created\n * 4. Reads and parses the artifacts JSON file\n *\n * @param {string} cacheDir - Cache directory (relative to cwd)\n * @param {import('./types.js').FileAccessObject} fs - File system interface for reading files\n * @param {string} cwd - Current working directory\n * @param {string} entryModuleId - Path to the Solidity file\n * @returns {Promise<import('@tevm/compiler').ResolvedArtifacts | undefined>}\n *   The cached artifacts if found and valid, undefined otherwise\n * @throws {Error} If the cached artifacts exist but cannot be parsed as valid JSON\n *\n * @example\n * ```javascript\n * import { readArtifacts } from '@tevm/bundler-cache'\n * import * as fs from 'node:fs'\n * import * as fsPromises from 'node:fs/promises'\n *\n * // Create file access object\n * const fileAccess = {\n *   readFile: fsPromises.readFile,\n *   exists: async (path) => fs.existsSync(path),\n *   stat: fsPromises.stat,\n *   // ...other required methods\n * }\n *\n * // Read artifacts from cache\n * const artifacts = await readArtifacts(\n *   '.tevm',                           // Cache directory\n *   fileAccess,                        // File access object\n *   process.cwd(),                     // Current working directory\n *   './contracts/Token.sol'            // Solidity file path\n * )\n *\n * if (artifacts) {\n *   console.log('Found valid cached artifacts')\n * } else {\n *   console.log('No valid cache found, need to recompile')\n * }\n * ```\n *\n * @internal\n */\nexport const readArtifacts = async (cacheDir, fs, cwd, entryModuleId) => {\n\t// Get paths to artifacts and metadata files\n\tconst { path: artifactsPath } = getArtifactsPath(entryModuleId, 'artifactsJson', cwd, cacheDir)\n\tconst { path: metadataPath } = getMetadataPath(entryModuleId, cwd, cacheDir)\n\n\t// Check if both required files exist\n\tif (!(await fs.exists(artifactsPath)) || !(await fs.exists(metadataPath))) {\n\t\treturn undefined\n\t}\n\n\t// Parse metadata file\n\tconst metadata = JSON.parse(await fs.readFile(metadataPath, 'utf8'))\n\n\t// Check if cache is still valid by:\n\t// 1. Comparing cache version\n\t// 2. Checking if any source files have been modified\n\tconst didContentChange =\n\t\tversion !== metadata.version ||\n\t\t(\n\t\t\tawait Promise.all(\n\t\t\t\tObject.entries(metadata.files).map(async ([sourcePath, timestamp]) => {\n\t\t\t\t\tconst didChange = timestamp !== (await fs.stat(sourcePath)).mtimeMs\n\t\t\t\t\treturn didChange\n\t\t\t\t}),\n\t\t\t)\n\t\t).some((didChange) => didChange)\n\n\t// If any validation fails, return undefined (cache miss)\n\tif (didContentChange) {\n\t\treturn undefined\n\t}\n\n\t// Read and parse artifacts file\n\tconst content = await fs.readFile(artifactsPath, 'utf8')\n\n\ttry {\n\t\treturn JSON.parse(content)\n\t} catch (_e) {\n\t\tthrow new Error(`Cache miss for ${entryModuleId} because it isn't valid json`)\n\t}\n}\n","import { getArtifactsPath } from './getArtifactsPath.js'\nimport { getMetadataPath } from './getMetadataPath.js'\nimport { version } from './version.js'\n\n/**\n * Synchronously reads Solidity compilation artifacts from the cache.\n *\n * This is the synchronous version of readArtifacts, used primarily in TypeScript compiler plugins\n * and other contexts where async operations can't be used. It performs the same validation steps:\n *\n * 1. Checks if both artifacts.json and metadata.json files exist\n * 2. Verifies if the cache version matches the current version\n * 3. Checks if any source files have been modified since the cache was created\n * 4. Reads and parses the artifacts JSON file\n *\n * @param {string} cacheDir - Cache directory (relative to cwd)\n * @param {import('./types.js').FileAccessObject} fs - File system interface for reading files\n * @param {string} cwd - Current working directory\n * @param {string} entryModuleId - Path to the Solidity file\n * @returns {import('@tevm/compiler').ResolvedArtifacts | undefined}\n *   The cached artifacts if found and valid, undefined otherwise\n * @throws {Error} If the cached artifacts exist but cannot be parsed as valid JSON\n *\n * @example\n * ```javascript\n * import { readArtifactsSync } from '@tevm/bundler-cache'\n * import * as fs from 'node:fs'\n *\n * // Create file access object\n * const fileAccess = {\n *   readFileSync: fs.readFileSync,\n *   existsSync: fs.existsSync,\n *   statSync: fs.statSync,\n *   // ...other required methods\n * }\n *\n * // Read artifacts from cache synchronously\n * const artifacts = readArtifactsSync(\n *   '.tevm',                          // Cache directory\n *   fileAccess,                       // File access object\n *   process.cwd(),                    // Current working directory\n *   './contracts/Token.sol'           // Solidity file path\n * )\n *\n * if (artifacts) {\n *   console.log('Found valid cached artifacts')\n * } else {\n *   console.log('No valid cache found, need to recompile')\n * }\n * ```\n *\n * @internal\n */\nexport const readArtifactsSync = (cacheDir, fs, cwd, entryModuleId) => {\n\t// Get paths to artifacts and metadata files\n\tconst { path: artifactsPath } = getArtifactsPath(entryModuleId, 'artifactsJson', cwd, cacheDir)\n\tconst { path: metadataPath } = getMetadataPath(entryModuleId, cwd, cacheDir)\n\n\t// Check if both required files exist\n\tif (!fs.existsSync(artifactsPath) || !fs.existsSync(metadataPath)) {\n\t\treturn undefined\n\t}\n\n\t// Parse metadata file\n\tconst metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf8'))\n\n\t// Check if cache is still valid by:\n\t// 1. Comparing cache version\n\t// 2. Checking if any source files have been modified\n\tconst didContentChange =\n\t\tmetadata.version !== version ||\n\t\tObject.entries(metadata.files).some(([sourcePath, timestamp]) => {\n\t\t\treturn timestamp !== fs.statSync(sourcePath).mtimeMs\n\t\t})\n\n\t// If any validation fails, return undefined (cache miss)\n\tif (didContentChange) {\n\t\treturn undefined\n\t}\n\n\t// Read and parse artifacts file\n\tconst content = fs.readFileSync(artifactsPath, 'utf8')\n\n\ttry {\n\t\treturn JSON.parse(content)\n\t} catch (_e) {\n\t\tthrow new Error(`Cache miss for ${entryModuleId} because it isn't valid json`)\n\t}\n}\n","import { getArtifactsPath } from './getArtifactsPath.js'\nimport { getMetadataPath } from './getMetadataPath.js'\nimport { version } from './version.js'\n\n/**\n * Asynchronously writes Solidity compilation artifacts to the cache.\n *\n * This function stores two files in the cache:\n * 1. artifacts.json - Contains the full compilation results (ABI, bytecode, ASTs, etc.)\n * 2. metadata.json - Contains cache validation information including:\n *    - The cache version\n *    - File modification timestamps for all source files\n *\n * The metadata file is used during cache reads to determine if the cache is still valid\n * or if the source files have changed and need to be recompiled.\n *\n * @param {string} cwd - Current working directory\n * @param {string} cacheDir - Cache directory (relative to cwd)\n * @param {string} entryModuleId - Path to the Solidity file\n * @param {import('@tevm/compiler').ResolvedArtifacts} resolvedArtifacts - Compilation results to cache\n * @param {import('./types.js').FileAccessObject} fs - File system interface for writing files\n * @returns {Promise<string>} Path where artifacts were written\n * @throws {Error} If directory creation or file writing fails\n *\n * @example\n * ```javascript\n * import { writeArtifacts } from '@tevm/bundler-cache'\n * import * as fs from 'node:fs'\n * import * as fsPromises from 'node:fs/promises'\n *\n * // Create file access object\n * const fileAccess = {\n *   writeFile: fsPromises.writeFile,\n *   exists: async (path) => fs.existsSync(path),\n *   mkdir: fsPromises.mkdir,\n *   statSync: fs.statSync,\n *   // ...other required methods\n * }\n *\n * // Write compilation artifacts to cache\n * const artifactsPath = await writeArtifacts(\n *   process.cwd(),                  // Current working directory\n *   '.tevm',                        // Cache directory\n *   './contracts/Token.sol',        // Solidity file path\n *   compilationResults,             // Results from solc compiler\n *   fileAccess                      // File access object\n * )\n *\n * console.log(`Artifacts cached at: ${artifactsPath}`)\n * ```\n *\n * @internal\n */\nexport const writeArtifacts = async (cwd, cacheDir, entryModuleId, resolvedArtifacts, fs) => {\n\t// Get paths for artifacts and metadata files\n\tconst { dir, path } = getArtifactsPath(entryModuleId, 'artifactsJson', cwd, cacheDir)\n\tconst { path: metadataPath } = getMetadataPath(entryModuleId, cwd, cacheDir)\n\n\t// Create cache directory if it doesn't exist\n\tif (!(await fs.exists(dir))) {\n\t\tawait fs.mkdir(dir, { recursive: true })\n\t}\n\n\t// Write both files in parallel for better performance\n\tawait Promise.all([\n\t\t// Write artifacts.json with the full compilation results\n\t\tfs.writeFile(path, JSON.stringify(resolvedArtifacts, null, 2)),\n\n\t\t// Write metadata.json with cache validation information\n\t\tfs.writeFile(\n\t\t\tmetadataPath,\n\t\t\tJSON.stringify(\n\t\t\t\t{\n\t\t\t\t\t// Current cache version for compatibility checks\n\t\t\t\t\tversion,\n\n\t\t\t\t\t// File modification timestamps for dependency tracking\n\t\t\t\t\tfiles: Object.fromEntries(\n\t\t\t\t\t\tObject.keys(resolvedArtifacts.solcInput?.sources || {}).map((sourcePath) => {\n\t\t\t\t\t\t\t// For efficiency, only store the last modified timestamp of each file\n\t\t\t\t\t\t\treturn [sourcePath, fs.statSync(sourcePath).mtimeMs]\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2,\n\t\t\t),\n\t\t),\n\t])\n\n\treturn path\n}\n","import { getArtifactsPath } from './getArtifactsPath.js'\nimport { getMetadataPath } from './getMetadataPath.js'\nimport { version } from './version.js'\n\n/**\n * Synchronously writes Solidity compilation artifacts to the cache.\n *\n * This is the synchronous version of writeArtifacts, used primarily in TypeScript compiler plugins\n * and other contexts where async operations can't be used. It stores the same two files:\n *\n * 1. artifacts.json - Contains the full compilation results (ABI, bytecode, ASTs, etc.)\n * 2. metadata.json - Contains cache validation information (version and file timestamps)\n *\n * @param {string} cwd - Current working directory\n * @param {string} cacheDir - Cache directory (relative to cwd)\n * @param {string} entryModuleId - Path to the Solidity file\n * @param {import('@tevm/compiler').ResolvedArtifacts} resolvedArtifacts - Compilation results to cache\n * @param {import('./types.js').FileAccessObject} fs - File system interface for writing files\n * @returns {string} Path where artifacts were written\n * @throws {Error} If directory creation or file writing fails\n *\n * @example\n * ```javascript\n * import { writeArtifactsSync } from '@tevm/bundler-cache'\n * import * as fs from 'node:fs'\n *\n * // Create file access object\n * const fileAccess = {\n *   writeFileSync: fs.writeFileSync,\n *   existsSync: fs.existsSync,\n *   mkdirSync: fs.mkdirSync,\n *   statSync: fs.statSync,\n *   // ...other required methods\n * }\n *\n * // Write compilation artifacts to cache synchronously\n * const artifactsPath = writeArtifactsSync(\n *   process.cwd(),                  // Current working directory\n *   '.tevm',                        // Cache directory\n *   './contracts/Token.sol',        // Solidity file path\n *   compilationResults,             // Results from solc compiler\n *   fileAccess                      // File access object\n * )\n *\n * console.log(`Artifacts cached at: ${artifactsPath}`)\n * ```\n *\n * @internal\n */\nexport const writeArtifactsSync = (cwd, cacheDir, entryModuleId, resolvedArtifacts, fs) => {\n\t// Get paths for artifacts and metadata files\n\tconst { dir, path } = getArtifactsPath(entryModuleId, 'artifactsJson', cwd, cacheDir)\n\tconst { path: metadataPath } = getMetadataPath(entryModuleId, cwd, cacheDir)\n\n\t// Create cache directory if it doesn't exist\n\tif (!fs.existsSync(dir)) {\n\t\tfs.mkdirSync(dir, { recursive: true })\n\t}\n\n\t// Write artifacts.json with the full compilation results\n\tfs.writeFileSync(path, JSON.stringify(resolvedArtifacts, null, 2))\n\n\t// Write metadata.json with cache validation information\n\tfs.writeFileSync(\n\t\tmetadataPath,\n\t\tJSON.stringify(\n\t\t\t{\n\t\t\t\t// Current cache version for compatibility checks\n\t\t\t\tversion,\n\n\t\t\t\t// File modification timestamps for dependency tracking\n\t\t\t\tfiles: Object.fromEntries(\n\t\t\t\t\tObject.keys(resolvedArtifacts.solcInput?.sources || {}).map((sourcePath) => {\n\t\t\t\t\t\t// For efficiency, only store the last modified timestamp of each file\n\t\t\t\t\t\treturn [sourcePath, fs.statSync(sourcePath).mtimeMs]\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t},\n\t\t\tnull,\n\t\t\t2,\n\t\t),\n\t)\n\n\treturn path\n}\n","import { getArtifactsPath } from './getArtifactsPath.js'\nimport { readArtifacts } from './readArtifacts.js'\nimport { readArtifactsSync } from './readArtifactsSync.js'\nimport { writeArtifacts } from './writeArtifacts.js'\nimport { writeArtifactsSync } from './writeArtifactsSync.js'\n\n/**\n * Creates a cache object for reading and writing Solidity compilation artifacts\n * and generated code files.\n *\n * The cache system helps improve build performance by storing compiled Solidity artifacts\n * and generated TypeScript/JavaScript files on disk, avoiding unnecessary recompilation\n * when source files haven't changed.\n *\n * This cache is used by various Tevm bundler plugins to provide consistent and efficient\n * caching across different build systems.\n *\n * @param {string} cacheDir - Directory where cache files will be stored (relative to cwd)\n * @param {import('./types.js').FileAccessObject} fs - File system interface for reading/writing\n * @param {string} cwd - Current working directory, used as base for resolving paths\n * @returns {import('./types.js').Cache} Cache object with methods for reading and writing\n *\n * @example\n * ```javascript\n * import { createCache } from '@tevm/bundler-cache'\n * import { bundler } from '@tevm/base-bundler'\n * import * as fs from 'node:fs'\n * import * as fsPromises from 'node:fs/promises'\n *\n * // Create a file access object\n * const fileAccess = {\n *   readFile: fsPromises.readFile,\n *   readFileSync: fs.readFileSync,\n *   writeFile: fsPromises.writeFile,\n *   writeFileSync: fs.writeFileSync,\n *   exists: async (path) => fs.existsSync(path),\n *   existsSync: fs.existsSync,\n *   statSync: fs.statSync,\n *   stat: fsPromises.stat,\n *   mkdirSync: fs.mkdirSync,\n *   mkdir: fsPromises.mkdir\n * }\n *\n * // Create the cache\n * const cache = createCache('.tevm', fileAccess, process.cwd())\n *\n * // Later, use with the bundler\n * const myBundler = bundler(\n *   tevmConfig,\n *   console,\n *   fileAccess,\n *   solcCompiler,\n *   cache // Pass the cache instance\n * )\n * ```\n */\nexport const createCache = (cacheDir, fs, cwd) => {\n\treturn {\n\t\t/**\n\t\t * Synchronously writes compiled Solidity artifacts to the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file being cached\n\t\t * @param {import('@tevm/compiler').ResolvedArtifacts} compiledContracts - Compilation result\n\t\t * @returns {string} Path where artifacts were written\n\t\t */\n\t\twriteArtifactsSync: (entryModuleId, compiledContracts) => {\n\t\t\treturn writeArtifactsSync(cwd, cacheDir, entryModuleId, compiledContracts, fs)\n\t\t},\n\n\t\t/**\n\t\t * Asynchronously writes compiled Solidity artifacts to the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file being cached\n\t\t * @param {import('@tevm/compiler').ResolvedArtifacts} compiledContracts - Compilation result\n\t\t * @returns {Promise<string>} Path where artifacts were written\n\t\t */\n\t\twriteArtifacts: async (entryModuleId, compiledContracts) => {\n\t\t\treturn writeArtifacts(cwd, cacheDir, entryModuleId, compiledContracts, fs)\n\t\t},\n\n\t\t/**\n\t\t * Synchronously reads compiled Solidity artifacts from the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @returns {import('@tevm/compiler').ResolvedArtifacts|undefined} Cached artifacts if found\n\t\t */\n\t\treadArtifactsSync: (entryModuleId) => {\n\t\t\treturn readArtifactsSync(cacheDir, fs, cwd, entryModuleId)\n\t\t},\n\n\t\t/**\n\t\t * Asynchronously reads compiled Solidity artifacts from the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @returns {Promise<import('@tevm/compiler').ResolvedArtifacts|undefined>} Cached artifacts if found\n\t\t */\n\t\treadArtifacts: async (entryModuleId) => {\n\t\t\treturn readArtifacts(cacheDir, fs, cwd, entryModuleId)\n\t\t},\n\n\t\t/**\n\t\t * Synchronously writes TypeScript declaration (.d.ts) file to the cache\n\t\t *\n\t\t * Note: TypeScript declarations are primarily cached for debugging and\n\t\t * to support TypeScript compiler plugins.\n\t\t *\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @param {string} dtsFile - Content of the TypeScript declaration file\n\t\t * @returns {string} Path where the file was written\n\t\t */\n\t\twriteDtsSync: (entryModuleId, dtsFile) => {\n\t\t\tconst { path: dtsPath, dir: dtsDir } = getArtifactsPath(entryModuleId, 'dts', cwd, cacheDir)\n\t\t\tfs.mkdirSync(dtsDir, { recursive: true })\n\t\t\tfs.writeFileSync(dtsPath, dtsFile)\n\t\t\treturn dtsPath\n\t\t},\n\n\t\t/**\n\t\t * Asynchronously writes TypeScript declaration (.d.ts) file to the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @param {string} dtsFile - Content of the TypeScript declaration file\n\t\t * @returns {Promise<string>} Path where the file was written\n\t\t */\n\t\twriteDts: async (entryModuleId, dtsFile) => {\n\t\t\tconst { path: dtsPath, dir: dtsDir } = getArtifactsPath(entryModuleId, 'dts', cwd, cacheDir)\n\t\t\tawait fs.mkdir(dtsDir, { recursive: true })\n\t\t\tawait fs.writeFile(dtsPath, dtsFile)\n\t\t\treturn dtsPath\n\t\t},\n\n\t\t/**\n\t\t * Synchronously reads TypeScript declaration file from the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @returns {string|undefined} Content of the declaration file if found\n\t\t */\n\t\treadDtsSync: (entryModuleId) => {\n\t\t\tconst { path: dtsPath } = getArtifactsPath(entryModuleId, 'dts', cwd, cacheDir)\n\t\t\tif (!fs.existsSync(dtsPath)) {\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t\treturn fs.readFileSync(dtsPath, 'utf8')\n\t\t},\n\n\t\t/**\n\t\t * Asynchronously reads TypeScript declaration file from the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @returns {Promise<string|undefined>} Content of the declaration file if found\n\t\t */\n\t\treadDts: async (entryModuleId) => {\n\t\t\tconst { path: dtsPath } = getArtifactsPath(entryModuleId, 'dts', cwd, cacheDir)\n\t\t\tif (!(await fs.exists(dtsPath))) {\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t\treturn fs.readFile(dtsPath, 'utf8')\n\t\t},\n\n\t\t/**\n\t\t * Synchronously writes ES module (.mjs) file to the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @param {string} mjsFile - Content of the ES module file\n\t\t * @returns {string} Path where the file was written\n\t\t */\n\t\twriteMjsSync: (entryModuleId, mjsFile) => {\n\t\t\tconst { path: mjsPath, dir: mjsDir } = getArtifactsPath(entryModuleId, 'mjs', cwd, cacheDir)\n\t\t\tfs.mkdirSync(mjsDir, { recursive: true })\n\t\t\tfs.writeFileSync(mjsPath, mjsFile)\n\t\t\treturn mjsPath\n\t\t},\n\n\t\t/**\n\t\t * Asynchronously writes ES module (.mjs) file to the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @param {string} mjsFile - Content of the ES module file\n\t\t * @returns {Promise<string>} Path where the file was written\n\t\t */\n\t\twriteMjs: async (entryModuleId, mjsFile) => {\n\t\t\tconst { path: mjsPath, dir: mjsDir } = getArtifactsPath(entryModuleId, 'mjs', cwd, cacheDir)\n\t\t\tawait fs.mkdir(mjsDir, { recursive: true })\n\t\t\tawait fs.writeFile(mjsPath, mjsFile)\n\t\t\treturn mjsPath\n\t\t},\n\n\t\t/**\n\t\t * Synchronously reads ES module file from the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @returns {string|undefined} Content of the ES module file if found\n\t\t */\n\t\treadMjsSync: (entryModuleId) => {\n\t\t\tconst { path: mjsPath } = getArtifactsPath(entryModuleId, 'mjs', cwd, cacheDir)\n\t\t\tif (!fs.existsSync(mjsPath)) {\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t\treturn fs.readFileSync(mjsPath, 'utf8')\n\t\t},\n\n\t\t/**\n\t\t * Asynchronously reads ES module file from the cache\n\t\t * @param {string} entryModuleId - Path to the Solidity file\n\t\t * @returns {Promise<string|undefined>} Content of the ES module file if found\n\t\t */\n\t\treadMjs: async (entryModuleId) => {\n\t\t\tconst { path: mjsPath } = getArtifactsPath(entryModuleId, 'mjs', cwd, cacheDir)\n\t\t\tif (!(await fs.exists(mjsPath))) {\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t\treturn fs.readFile(mjsPath, 'utf8')\n\t\t},\n\t}\n}\n"]}