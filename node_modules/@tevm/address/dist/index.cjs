'use strict';

var utils = require('@tevm/utils');
var errors = require('@tevm/errors');
var viem = require('viem');

// src/Address.js
var Address = class extends utils.EthjsAddress {
  /**
   * Returns the checksummed EIP-55 compliant address string.
   *
   * Unlike the parent EthjsAddress class which returns lowercase strings,
   * this implementation returns properly checksummed addresses for improved
   * safety, readability, and compatibility.
   *
   * @override
   * @returns {import('@tevm/utils').Address} The checksummed Ethereum address as a string.
   *
   * @example
   * ```javascript
   * import { createAddress } from '@tevm/address';
   *
   * const address = createAddress('0x8ba1f109551bd432803012645ac136ddd64dba72');
   * console.log(address.toString()); // '0x8ba1f109551bD432803012645Ac136ddd64DBA72'
   * ```
   */
  toString() {
    return utils.getAddress(utils.bytesToHex(this.bytes));
  }
};
var createAddress = (address) => {
  try {
    if (address instanceof utils.EthjsAddress) {
      return new Address(address.bytes);
    }
    if (address instanceof Uint8Array) {
      return new Address(address);
    }
    if (typeof address === "number" || typeof address === "bigint") {
      return new Address(viem.numberToBytes(address, { size: 20 }));
    }
    if (typeof address === "string" && address.startsWith("0x")) {
      return new Address(utils.hexToBytes(
        /** @type {import('viem').Hex}*/
        address,
        { size: 20 }
      ));
    }
    if (typeof address === "string") {
      return new Address(utils.hexToBytes(`0x${address}`, { size: 20 }));
    }
    throw new errors.UnreachableCodeError(address, `Received an unexpected input for createAddress ${address}`);
  } catch (e) {
    if (e instanceof errors.UnreachableCodeError) {
      throw new errors.InvalidAddressError(
        "Received an invalid address input type for createAddress. Valid input types include hex string, unprefixed hex, bytes, number, bigint, or EthjsAddress",
        { cause: e }
      );
    }
    throw new errors.InvalidAddressError(`Received an invalid address input: ${/** @type {Error} */
    e.message}`, {
      cause: (
        /** @type {Error} */
        e
      )
    });
  }
};

// src/create2ContractAddress.js
var create2ContractAddress = (from, salt, code) => {
  const saltBytes = utils.hexToBytes(salt);
  if (saltBytes.length !== 32) {
    throw new errors.InvalidSaltError("Expected salt to be of length 32 bytes");
  }
  return createAddress(
    utils.keccak256(utils.concatBytes(utils.hexToBytes("0xff"), from.bytes, saltBytes, utils.keccak256(code, "bytes")), "bytes").subarray(-20)
  );
};
var createContractAddress = (from, nonce) => {
  if (!(from.bytes instanceof Uint8Array)) {
    throw new errors.InvalidAddressError("Expected from to be an Address or ethereumjs Address");
  }
  if (nonce === 0n) {
    return createAddress(utils.keccak256(utils.toRlp([from.bytes, Uint8Array.from([])]), "bytes").subarray(-20));
  }
  return createAddress(utils.keccak256(utils.toRlp([from.bytes, viem.numberToBytes(nonce)]), "bytes").subarray(-20));
};

exports.Address = Address;
exports.create2ContractAddress = create2ContractAddress;
exports.createAddress = createAddress;
exports.createContractAddress = createContractAddress;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map