{"version":3,"sources":["../src/Address.js","../src/createAddress.js","../src/create2ContractAddress.js","../src/createContractAddress.js"],"names":["EthjsAddress","hexToBytes","InvalidAddressError","keccak256","numberToBytes"],"mappings":"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","file":"index.js","sourcesContent":["import { bytesToHex, EthjsAddress, getAddress } from '@tevm/utils'\n\n/**\n * A specialized Ethereum address class that extends EthjsAddress with TEVM-specific\n * functionality. This class provides EIP-55 compliant checksummed address formatting\n * and consistent behavior across the TEVM ecosystem.\n *\n * The Address class is the core representation of Ethereum addresses in TEVM's\n * low-level APIs. It handles the complexities of Ethereum addresses including:\n * - Proper hex encoding/decoding\n * - EIP-55 checksumming for error detection\n * - Consistent 20-byte binary representation\n *\n * This class should typically be created using the `createAddress` factory function\n * rather than being instantiated directly.\n *\n * @extends {EthjsAddress}\n * @example\n * ```javascript\n * import { createAddress } from '@tevm/address';\n *\n * // From checksummed hex string\n * let address = createAddress('0x8ba1f109551bD432803012645Ac136ddd64DBA72');\n *\n * // From lowercase hex string\n * address = createAddress('0x8ba1f109551bd432803012645ac136ddd64dba72');\n *\n * // From zero address\n * address = createAddress(`0x${'00'.repeat(20)}`);\n *\n * // From number or bigint\n * address = createAddress(0);\n * address = createAddress(123456789n);\n *\n * // From Uint8Array\n * address = createAddress(new Uint8Array(20));\n *\n * // From unprefixed hex string\n * address = createAddress('8ba1f109551bd432803012645ac136ddd64dba72');\n * ```\n *\n * @see {@link https://eips.ethereum.org/EIPS/eip-55|EIP-55: Mixed-case checksum address encoding}\n */\nexport class Address extends EthjsAddress {\n\t/**\n\t * Returns the checksummed EIP-55 compliant address string.\n\t *\n\t * Unlike the parent EthjsAddress class which returns lowercase strings,\n\t * this implementation returns properly checksummed addresses for improved\n\t * safety, readability, and compatibility.\n\t *\n\t * @override\n\t * @returns {import('@tevm/utils').Address} The checksummed Ethereum address as a string.\n\t *\n\t * @example\n\t * ```javascript\n\t * import { createAddress } from '@tevm/address';\n\t *\n\t * const address = createAddress('0x8ba1f109551bd432803012645ac136ddd64dba72');\n\t * console.log(address.toString()); // '0x8ba1f109551bD432803012645Ac136ddd64DBA72'\n\t * ```\n\t */\n\ttoString() {\n\t\treturn getAddress(bytesToHex(this.bytes))\n\t}\n}\n","import { InvalidAddressError, UnreachableCodeError } from '@tevm/errors'\nimport { EthjsAddress, hexToBytes } from '@tevm/utils'\nimport { numberToBytes } from 'viem'\nimport { Address } from './Address.js'\n\n/**\n * Creates an {@link Address} instance from various input formats for safely\n * interacting with Ethereum addresses.\n *\n * This factory function provides a flexible and robust way to create Address\n * objects, handling multiple input formats:\n *\n * - Hex strings (with or without 0x prefix)\n * - Numbers or BigInts (converted to bytes)\n * - Uint8Array (raw bytes)\n * - Existing EthjsAddress or Address instances\n *\n * The created Address objects provide convenience methods and proper EIP-55\n * checksumming for improved safety when working with Ethereum addresses.\n *\n * This is the recommended way to create Address instances throughout TEVM.\n *\n * @param {import(\"@tevm/utils\").AddressLike | number | bigint | string} address - The input to create an address from\n * @returns {Address} An Address instance representing the input\n * @throws {InvalidAddressError} If the input is not a valid address or cannot be converted to one\n *\n * @example\n * ```javascript\n * import { createAddress } from '@tevm/address'\n *\n * // From checksummed or lowercase hex strings (with 0x prefix)\n * const addr1 = createAddress('0x8ba1f109551bD432803012645Ac136ddd64DBA72')\n * const addr2 = createAddress('0x8ba1f109551bd432803012645ac136ddd64dba72')\n *\n * // From unprefixed hex string\n * const addr3 = createAddress('8ba1f109551bd432803012645ac136ddd64dba72')\n *\n * // From zero address\n * const zeroAddr = createAddress(`0x${'00'.repeat(20)}`)\n * console.log(zeroAddr.toString()) // '0x0000000000000000000000000000000000000000'\n *\n * // From numbers (not recommended for real addresses due to potential overflow)\n * const numAddr = createAddress(1) // Convert 1 to address '0x0000000000000000000000000000000000000001'\n *\n * // From bigint (useful for sequential address generation)\n * const bigintAddr = createAddress(42n) // '0x000000000000000000000000000000000000002A'\n *\n * // From bytes\n * const bytesAddr = createAddress(new Uint8Array(20).fill(1))\n * // '0x0101010101010101010101010101010101010101'\n * ```\n *\n * @example\n * ```javascript\n * // Error handling example\n * import { createAddress } from '@tevm/address'\n * import { InvalidAddressError } from '@tevm/errors'\n *\n * try {\n *   // Invalid address (too short)\n *   const address = createAddress('0x123')\n * } catch (error) {\n *   if (error instanceof InvalidAddressError) {\n *     console.error('Invalid address format:', error.message)\n *   } else {\n *     throw error\n *   }\n * }\n * ```\n */\nexport const createAddress = (address) => {\n\ttry {\n\t\tif (address instanceof EthjsAddress) {\n\t\t\treturn new Address(address.bytes)\n\t\t}\n\t\tif (address instanceof Uint8Array) {\n\t\t\treturn new Address(address)\n\t\t}\n\t\tif (typeof address === 'number' || typeof address === 'bigint') {\n\t\t\treturn new Address(numberToBytes(address, { size: 20 }))\n\t\t}\n\t\tif (typeof address === 'string' && address.startsWith('0x')) {\n\t\t\treturn new Address(hexToBytes(/** @type {import('viem').Hex}*/ (address), { size: 20 }))\n\t\t}\n\t\tif (typeof address === 'string') {\n\t\t\treturn new Address(hexToBytes(`0x${address}`, { size: 20 }))\n\t\t}\n\t\tthrow new UnreachableCodeError(address, `Received an unexpected input for createAddress ${address}`)\n\t} catch (e) {\n\t\tif (e instanceof UnreachableCodeError) {\n\t\t\tthrow new InvalidAddressError(\n\t\t\t\t'Received an invalid address input type for createAddress. Valid input types include hex string, unprefixed hex, bytes, number, bigint, or EthjsAddress',\n\t\t\t\t{ cause: e },\n\t\t\t)\n\t\t}\n\t\tthrow new InvalidAddressError(`Received an invalid address input: ${/** @type {Error} */ (e).message}`, {\n\t\t\tcause: /** @type {Error} */ (e),\n\t\t})\n\t}\n}\n","import { InvalidSaltError } from '@tevm/errors'\nimport { concatBytes, EthjsAddress, hexToBytes, keccak256 } from '@tevm/utils'\nimport { Address } from './Address.js'\nimport { createAddress } from './createAddress.js'\n\n/**\n * @typedef {import('@tevm/errors').InvalidSaltError | import('@tevm/errors').InvalidAddressError} Create2ContractAddressError\n */\n\n/**\n * Generates an {@link Address} for a contract deployed using the CREATE2 opcode.\n *\n * CREATE2 enables deterministic contract deployment regardless of deployer's nonce,\n * allowing contracts to be deployed at predetermined addresses known before deployment.\n * This is useful for:\n *\n * - Creating counterfactual contracts (contracts whose address is known before deployment)\n * - Enabling deterministic cross-chain deployments\n * - Supporting contract interactions before a contract is deployed\n * - Factory patterns with predictable addresses\n *\n * The CREATE2 address is calculated using the formula:\n *\n * `address = keccak256(0xff + sender_address + salt + keccak256(init_code))[12:]`\n *\n * Where:\n * - 0xff is a constant prefix byte\n * - salt is a 32-byte value chosen by the deployer\n * - init_code is the contract creation bytecode\n * - [12:] means taking the last 20 bytes of the 32-byte hash\n *\n * @param {EthjsAddress} from - The address of the account or factory contract initiating the deployment\n * @param {import('@tevm/utils').Hex} salt - A 32-byte value as a hex string that makes the address unique\n * @param {import('@tevm/utils').Hex} code - The contract creation bytecode (not the deployed bytecode)\n * @returns {Address} The deterministic contract address that will be generated\n * @throws {Create2ContractAddressError} If salt is not 32 bytes or if other inputs are invalid\n *\n * @example\n * ```javascript\n * import { createAddress, create2ContractAddress } from '@tevm/address'\n *\n * // Factory address (e.g., a contract that deploys other contracts)\n * const factoryAddress = createAddress('0x8ba1f109551bD432803012645Ac136ddd64DBA72')\n *\n * // Create a unique salt value (must be 32 bytes)\n * const salt = '0x' + '00'.repeat(31) + '01' // 0x0000...0001\n *\n * // Contract bytecode (the initialization/creation code, not the runtime code)\n * const initCode = '0x608060405234801561001057600080fd5b5060f78061001f6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80633fb5c1cb1460415780638381f58a146053578063d09de08a14606d575b600080fd5b6051604c3660046083565b600055565b005b605b60005481565b60405190815260200160405180910390f35b6051600080549080607c83609b565b9190505550565b600060208284031215609457600080fd5b5035919050565b60006001820160ba57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220d5d906d4f57c58cc85c7308e5d75b7f703100f6c46a6f59a07159c2104d4d25264736f6c63430008130033'\n *\n * // Calculate the address where the contract will be deployed\n * const contractAddress = create2ContractAddress(\n *   factoryAddress,\n *   salt,\n *   initCode\n * )\n *\n * console.log('Contract will be deployed at:', contractAddress.toString())\n * ```\n *\n * @example\n * ```javascript\n * // Using different salts to deploy multiple instances of the same contract\n * import { createAddress, create2ContractAddress } from '@tevm/address'\n * import { hexToBytes } from '@tevm/utils'\n *\n * const factoryAddress = createAddress('0x8ba1f109551bD432803012645Ac136ddd64DBA72')\n * const initCode = '0x608060405234801561001057600080fd5b50610150806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b61004361006e565b60405190815260200160405180910390f35b610043610067366004610105565b600055565b60008054905090565b600060208284031215610089578081fd5b5035919050565b60006020828403121561009c57600080fd5b81516001600160a01b03811681146100b257600080fd5b9392505050565b6000602082840312156100ca57600080fd5b5035919050565b6000602082840312156100e257600080fd5b5035919050565b6000602082840312156100fa57600080fd5b5035919050565b60006020828403121561011657600080fd5b5035919050565b6000602082840312156100e257600080fd5b5035919050565b60006020828403121561011657600080fd5b503591905056fea2646970667358221220d5d906d4f57c58cc85c7308e5d75b7f703100f6c46a6f59a07159c2104d4d25264736f6c63430008130033'\n *\n * // Generate addresses with sequential salts\n * const addresses = [];\n * for (let i = 0; i < 5; i++) {\n *   // Create a salt with the index as the last byte\n *   const salt = '0x' + '00'.repeat(31) + i.toString(16).padStart(2, '0')\n *   addresses.push(\n *     create2ContractAddress(factoryAddress, salt, initCode).toString()\n *   )\n * }\n *\n * console.log('Deterministic contract addresses:', addresses)\n * ```\n *\n * @see {@link https://eips.ethereum.org/EIPS/eip-1014|EIP-1014: Skinny CREATE2}\n * @see {@link https://solidity-by-example.org/app/create2/|CREATE2 Usage Example in Solidity}\n */\nexport const create2ContractAddress = (from, salt, code) => {\n\tconst saltBytes = hexToBytes(salt)\n\tif (saltBytes.length !== 32) {\n\t\tthrow new InvalidSaltError('Expected salt to be of length 32 bytes')\n\t}\n\treturn createAddress(\n\t\tkeccak256(concatBytes(hexToBytes('0xff'), from.bytes, saltBytes, keccak256(code, 'bytes')), 'bytes').subarray(-20),\n\t)\n}\n","import { InvalidAddressError } from '@tevm/errors'\nimport { EthjsAddress, keccak256, toRlp } from '@tevm/utils'\nimport { numberToBytes } from 'viem'\nimport { Address } from './Address.js'\nimport { createAddress } from './createAddress.js'\n\n/**\n * Generates an {@link Address} for a contract deployed using the standard CREATE opcode.\n *\n * In Ethereum, contract addresses are deterministically generated based on the deployer's\n * address and their current nonce. This function implements that calculation, following\n * the formula:\n *\n * `address = keccak256(rlp([sender_address, sender_nonce]))[12:]`\n *\n * Where:\n * - rlp is the RLP encoding function\n * - keccak256 is the hash function\n * - [12:] means taking the last 20 bytes of the 32-byte hash\n *\n * This is useful for:\n * - Predicting contract addresses before deployment\n * - Generating contract addresses in test environments\n * - Verifying contract deployment addresses\n *\n * @param {EthjsAddress} from - The address of the account deploying the contract\n * @param {bigint} nonce - The nonce of the deploying account at the time of deployment\n * @returns {Address} The contract address that will be (or was) generated\n * @throws {InvalidAddressError} If the 'from' parameter is not a valid EthjsAddress\n *\n * @example\n * ```javascript\n * import { createAddress, createContractAddress } from '@tevm/address'\n *\n * // Predict a contract's address before deployment\n * const deployerAddress = createAddress('0x8ba1f109551bD432803012645Ac136ddd64DBA72')\n * const deployerNonce = 5n // Current nonce of the deployer\n *\n * const predictedAddress = createContractAddress(deployerAddress, deployerNonce)\n * console.log('Contract will be deployed at:', predictedAddress.toString())\n *\n * // Using with a zero nonce (first deployment from an account)\n * const firstContractAddress = createContractAddress(deployerAddress, 0n)\n * ```\n *\n * @example\n * ```javascript\n * // Example of calculating multiple contract addresses in sequence\n * import { createAddress, createContractAddress } from '@tevm/address'\n *\n * const deployerAddress = createAddress('0x8ba1f109551bD432803012645Ac136ddd64DBA72')\n * const startingNonce = 10n\n *\n * // Calculate addresses for a series of contracts to be deployed\n * const contractAddresses = []\n * for (let i = 0; i < 5; i++) {\n *   const nonce = startingNonce + BigInt(i)\n *   contractAddresses.push(\n *     createContractAddress(deployerAddress, nonce).toString()\n *   )\n * }\n *\n * console.log('Upcoming contract addresses:', contractAddresses)\n * ```\n *\n * @see {@link https://ethereum.org/en/developers/docs/smart-contracts/deploying/#contract-creation-code|Ethereum Contract Creation}\n * @see {@link https://eips.ethereum.org/EIPS/eip-161|EIP-161: State trie clearing} for nonce rules\n */\nexport const createContractAddress = (from, nonce) => {\n\tif (!(from.bytes instanceof Uint8Array)) {\n\t\tthrow new InvalidAddressError('Expected from to be an Address or ethereumjs Address')\n\t}\n\tif (nonce === 0n) {\n\t\treturn createAddress(keccak256(toRlp([from.bytes, Uint8Array.from([])]), 'bytes').subarray(-20))\n\t}\n\treturn createAddress(keccak256(toRlp([from.bytes, numberToBytes(nonce)]), 'bytes').subarray(-20))\n}\n"]}