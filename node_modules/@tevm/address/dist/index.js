import { EthjsAddress, getAddress, bytesToHex, hexToBytes, keccak256, concatBytes, toRlp } from '@tevm/utils';
import { UnreachableCodeError, InvalidAddressError, InvalidSaltError } from '@tevm/errors';
import { numberToBytes } from 'viem';

// src/Address.js
var Address = class extends EthjsAddress {
  /**
   * Returns the checksummed EIP-55 compliant address string.
   *
   * Unlike the parent EthjsAddress class which returns lowercase strings,
   * this implementation returns properly checksummed addresses for improved
   * safety, readability, and compatibility.
   *
   * @override
   * @returns {import('@tevm/utils').Address} The checksummed Ethereum address as a string.
   *
   * @example
   * ```javascript
   * import { createAddress } from '@tevm/address';
   *
   * const address = createAddress('0x8ba1f109551bd432803012645ac136ddd64dba72');
   * console.log(address.toString()); // '0x8ba1f109551bD432803012645Ac136ddd64DBA72'
   * ```
   */
  toString() {
    return getAddress(bytesToHex(this.bytes));
  }
};
var createAddress = (address) => {
  try {
    if (address instanceof EthjsAddress) {
      return new Address(address.bytes);
    }
    if (address instanceof Uint8Array) {
      return new Address(address);
    }
    if (typeof address === "number" || typeof address === "bigint") {
      return new Address(numberToBytes(address, { size: 20 }));
    }
    if (typeof address === "string" && address.startsWith("0x")) {
      return new Address(hexToBytes(
        /** @type {import('viem').Hex}*/
        address,
        { size: 20 }
      ));
    }
    if (typeof address === "string") {
      return new Address(hexToBytes(`0x${address}`, { size: 20 }));
    }
    throw new UnreachableCodeError(address, `Received an unexpected input for createAddress ${address}`);
  } catch (e) {
    if (e instanceof UnreachableCodeError) {
      throw new InvalidAddressError(
        "Received an invalid address input type for createAddress. Valid input types include hex string, unprefixed hex, bytes, number, bigint, or EthjsAddress",
        { cause: e }
      );
    }
    throw new InvalidAddressError(`Received an invalid address input: ${/** @type {Error} */
    e.message}`, {
      cause: (
        /** @type {Error} */
        e
      )
    });
  }
};

// src/create2ContractAddress.js
var create2ContractAddress = (from, salt, code) => {
  const saltBytes = hexToBytes(salt);
  if (saltBytes.length !== 32) {
    throw new InvalidSaltError("Expected salt to be of length 32 bytes");
  }
  return createAddress(
    keccak256(concatBytes(hexToBytes("0xff"), from.bytes, saltBytes, keccak256(code, "bytes")), "bytes").subarray(-20)
  );
};
var createContractAddress = (from, nonce) => {
  if (!(from.bytes instanceof Uint8Array)) {
    throw new InvalidAddressError("Expected from to be an Address or ethereumjs Address");
  }
  if (nonce === 0n) {
    return createAddress(keccak256(toRlp([from.bytes, Uint8Array.from([])]), "bytes").subarray(-20));
  }
  return createAddress(keccak256(toRlp([from.bytes, numberToBytes(nonce)]), "bytes").subarray(-20));
};

export { Address, create2ContractAddress, createAddress, createContractAddress };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map