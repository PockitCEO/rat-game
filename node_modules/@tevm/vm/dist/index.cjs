'use strict';

var errors = require('@tevm/errors');
var utils = require('@tevm/utils');
var block = require('@tevm/block');
var common = require('@tevm/common');
var vm = require('@ethereumjs/vm');
var rlp = require('@tevm/rlp');
var trie = require('@tevm/trie');
var tx = require('@tevm/tx');
var evm = require('@tevm/evm');
var eventemitter3 = require('eventemitter3');

// src/actions/accumulateParentBeaconBlockRoot.ts
var parentBeaconBlockRootAddress = utils.createAddressFromString("0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02");

// src/actions/accumulateParentBeaconBlockRoot.ts
var accumulateParentBeaconBlockRoot = (vm) => async (root, timestamp) => {
  if (!vm.common.ethjsCommon.isActivatedEIP(4788)) {
    throw new errors.EipNotEnabledError("Cannot call `accumulateParentBeaconBlockRoot`: EIP 4788 is not active");
  }
  const historicalRootsLength = 8191n;
  const timestampIndex = timestamp % historicalRootsLength;
  const timestampExtended = timestampIndex + historicalRootsLength;
  if (await vm.stateManager.getAccount(parentBeaconBlockRootAddress) === void 0) {
    await vm.evm.journal.putAccount(parentBeaconBlockRootAddress, new utils.EthjsAccount());
  }
  await vm.stateManager.putStorage(
    parentBeaconBlockRootAddress,
    utils.setLengthLeft(utils.toBytes(timestampIndex), 32),
    utils.toBytes(timestamp)
  );
  await vm.stateManager.putStorage(parentBeaconBlockRootAddress, utils.setLengthLeft(utils.toBytes(timestampExtended), 32), root);
};
var accumulateParentBlockHash = (vm) => async (currentBlockNumber, parentHash) => {
  if (!vm.common.ethjsCommon.isActivatedEIP(2935)) {
    throw new errors.EipNotEnabledError("Cannot call `accumulateParentBlockHash`: EIP 2935 is not active");
  }
  const historyAddress = utils.createAddressFromString(
    "0x0aae40965e6800cd9b1f4b05ff21581047e3f91e"
    // numberToHex(vm.common.ethjsCommon.param('vm', 'historyStorageAddress')),
  );
  const historyServeWindow = 8192n;
  const forkTime = vm.common.ethjsCommon.eipTimestamp(2935);
  if (forkTime === null) {
    throw new errors.EipNotEnabledError("EIP 2935 should be activated by timestamp");
  }
  if (await vm.stateManager.getAccount(historyAddress) === void 0) {
    await vm.evm.journal.putAccount(historyAddress, utils.createAccount({}));
  }
  async function putBlockHash(vm2, hash, number) {
    const ringKey = number % historyServeWindow;
    const key = utils.setLengthLeft(utils.toBytes(Number(ringKey)), 32);
    await vm2.stateManager.putStorage(historyAddress, key, hash);
  }
  await putBlockHash(vm, parentHash, currentBlockNumber - 1n);
  const parentBlock = await vm.blockchain.getBlock(parentHash);
  if (parentBlock.header.timestamp < forkTime) {
    let ancestor = parentBlock;
    for (let i = 0; i < Number(historyServeWindow) - 1; i++) {
      if (ancestor.header.number === 0n) {
        break;
      }
      ancestor = await vm.blockchain.getBlock(ancestor.header.parentHash);
      await putBlockHash(vm, ancestor.hash(), ancestor.header.number);
    }
  }
};

// src/actions/errorMsg.ts
function errorMsg(msg, vm, block) {
  const blockErrorStr = "errorStr" in block ? block.errorStr() : "block";
  const errorMsg3 = `${msg} (${vm.common.ethjsCommon.hardfork.name} -> ${blockErrorStr})`;
  return errorMsg3;
}
var KECCAK256_NULL = utils.hexToBytes("0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470");

// src/actions/errorMessage.js
var errorMsg2 = (msg, block, tx) => {
  const blockErrorStr = "errorStr" in block ? block.errorStr() : "block";
  const txErrorStr = "errorStr" in tx ? tx.errorStr() : "tx";
  const errorMsg3 = `${msg} -> ${blockErrorStr} -> ${txErrorStr})`;
  return errorMsg3;
};
var generateTxReceipt = (vm) => async (tx$1, txResult, cumulativeGasUsed, blobGasUsed, blobGasPrice) => {
  const baseReceipt = {
    cumulativeBlockGasUsed: cumulativeGasUsed,
    bitvector: txResult.bloom.bitvector,
    logs: txResult.execResult.logs ?? []
  };
  let receipt;
  if (!tx$1.supports(tx.Capability.EIP2718TypedTransaction)) {
    if (vm.common.ethjsCommon.gteHardfork("byzantium") === true) {
      receipt = {
        status: txResult.execResult.exceptionError !== void 0 ? 0 : 1,
        // Receipts have a 0 as status on error
        ...baseReceipt
      };
    } else {
      const stateRoot = await vm.stateManager.getStateRoot();
      receipt = {
        stateRoot,
        ...baseReceipt
      };
    }
  } else {
    if (tx.isBlobEIP4844Tx(tx$1)) {
      receipt = {
        blobGasUsed,
        blobGasPrice,
        status: txResult.execResult.exceptionError ? 0 : 1,
        ...baseReceipt
      };
    } else {
      receipt = {
        status: txResult.execResult.exceptionError ? 0 : 1,
        ...baseReceipt
      };
    }
  }
  return receipt;
};
function txLogsBloom(logs, common) {
  const bloom = new vm.Bloom(void 0, common?.ethjsCommon);
  if (logs) {
    for (let i = 0; i < logs.length; i++) {
      const log = logs[i];
      bloom.add(log[0]);
      const topics = log[1];
      for (let q = 0; q < topics.length; q++) {
        bloom.add(topics[q]);
      }
    }
  }
  return bloom;
}

// src/actions/execHardfork.js
var execHardfork = (hardfork, preMergeHf) => {
  return hardfork !== "paris" ? hardfork : preMergeHf;
};

// src/actions/validateRunTx.js
var validateRunTx = (vm) => {
  const validateOpts = async (opts) => {
    const _opts = (
      /**
       * @type {import("../utils/RunTxOpts.js").RunTxOpts & Required<Pick<import("../utils/RunTxOpts.js").RunTxOpts, "block" | "preserveJournal">>}
       */
      {
        ...opts,
        block: opts.block !== void 0 ? opts.block : block.Block.fromBlockData({ header: {} }, { common: vm.common }),
        preserveJournal: opts.preserveJournal ?? false
      }
    );
    if (_opts.skipHardForkValidation !== true) {
      const hfs = (
        /** @type {any} */
        vm.common.ethjsCommon.hardforks()
      );
      const preMergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0) - 1;
      const preMergeHf = preMergeIndex >= 0 ? hfs[preMergeIndex]?.name : hfs[0]?.name;
      if (!preMergeHf) {
        const msg = errorMsg2("no preMerge hardfork found", _opts.block, _opts.tx);
        throw new errors.MisconfiguredClientError(msg);
      }
      if (execHardfork(_opts.tx.common.hardfork(), preMergeHf) !== execHardfork(_opts.block.common.ethjsCommon.hardfork(), preMergeHf)) {
        _opts.tx.common.setHardfork(_opts.block.common.ethjsCommon.hardfork());
      }
      if (execHardfork(_opts.block.common.ethjsCommon.hardfork(), preMergeHf) !== execHardfork(vm.common.ethjsCommon.hardfork(), preMergeHf)) {
        const msg = errorMsg2("block has a different hardfork than the vm", _opts.block, _opts.tx);
        throw new errors.MisconfiguredClientError(msg);
      }
    }
    if (_opts.skipBlockGasLimitValidation !== true && _opts.block.header.gasLimit < _opts.tx.gasLimit) {
      const msg = errorMsg2("tx has a higher gas limit than the block", _opts.block, _opts.tx);
      throw new errors.BlockGasLimitExceededError(msg);
    }
    if (_opts.tx.supports(tx.Capability.EIP2718TypedTransaction) && vm.common.ethjsCommon.isActivatedEIP(2718)) {
      if (!vm.common.ethjsCommon.isActivatedEIP(2930)) {
        await vm.evm.journal.revert();
        const msg = errorMsg2("Cannot run transaction: EIP 2930 is not activated.", _opts.block, _opts.tx);
        throw new errors.EipNotEnabledError(msg);
      }
      if (_opts.tx.supports(tx.Capability.EIP1559FeeMarket) && !vm.common.ethjsCommon.isActivatedEIP(1559)) {
        await vm.evm.journal.revert();
        const msg = errorMsg2("Cannot run transaction: EIP 1559 is not activated.", _opts.block, _opts.tx);
        throw new errors.EipNotEnabledError(msg);
      }
    }
    return _opts;
  };
  return validateOpts;
};
var warmAddresses2929 = (vm, caller, to, coinbase) => {
  if (vm.common.ethjsCommon.isActivatedEIP(2929)) {
    const activePrecompiles = vm.evm.precompiles;
    for (const [addressStr] of activePrecompiles.entries()) {
      vm.evm.journal.addAlwaysWarmAddress(addressStr);
    }
    vm.evm.journal.addAlwaysWarmAddress(caller.toString());
    if (to !== void 0) {
      vm.evm.journal.addAlwaysWarmAddress(utils.bytesToUnprefixedHex(to.bytes));
    }
    if (vm.common.ethjsCommon.isActivatedEIP(3651)) {
      vm.evm.journal.addAlwaysWarmAddress(utils.bytesToUnprefixedHex(coinbase.bytes));
    }
  }
};

// src/actions/runTx.ts
var runTx = (vm) => async (opts) => {
  await vm.ready();
  const validatedOpts = await validateRunTx(vm)(opts);
  if (!validatedOpts.preserveJournal) await vm.evm.journal.cleanup();
  if (validatedOpts.reportAccessList === true) {
    vm.evm.journal.startReportingAccessList();
  }
  if (validatedOpts.reportPreimages === true) {
    vm.evm.journal.startReportingPreimages?.();
  }
  await vm.evm.journal.checkpoint();
  if (validatedOpts.tx.supports(tx.Capability.EIP2718TypedTransaction) && vm.common.ethjsCommon.isActivatedEIP(2718)) {
    const castedTx = validatedOpts.tx;
    for (const accessListItem of castedTx.accessList ?? []) {
      vm.evm.journal.addAlwaysWarmAddress(accessListItem[0].toString(), true);
      for (const storageKey of accessListItem[1] ?? []) {
        vm.evm.journal.addAlwaysWarmSlot(accessListItem[0].toString(), storageKey.toString(), true);
      }
    }
  }
  try {
    const result = await _runTx(vm)(validatedOpts);
    if (!validatedOpts.preserveJournal) await vm.evm.journal.commit();
    return result;
  } catch (e) {
    await vm.evm.journal.revert();
    throw e;
  } finally {
    if (vm.common.ethjsCommon.isActivatedEIP(2929)) {
      vm.evm.journal.cleanJournal();
    }
  }
};
var _runTx = (vm) => async (opts) => {
  const { tx: tx$1, block } = opts;
  if (!block) {
    throw new errors.InvalidArgsError("block is required");
  }
  await vm._emit("beforeTx", tx$1);
  const caller = tx$1.getSenderAddress();
  warmAddresses2929(vm, caller, tx$1.to, block.header.coinbase);
  const txBaseFee = tx$1.getIntrinsicGas();
  let gasLimit = tx$1.gasLimit;
  if (gasLimit < txBaseFee) {
    const msg = errorMsg2(
      `tx gas limit ${Number(gasLimit)} is lower than the minimum gas limit of ${Number(txBaseFee)}`,
      block,
      tx$1
    );
    throw new errors.InvalidGasLimitError(msg);
  }
  gasLimit -= txBaseFee;
  if (vm.common.ethjsCommon.isActivatedEIP(1559)) {
    const maxFeePerGas = "maxFeePerGas" in tx$1 ? tx$1.maxFeePerGas : tx$1.gasPrice;
    const baseFeePerGas = block.header.baseFeePerGas ?? 0n;
    if (maxFeePerGas < baseFeePerGas) {
      const msg = errorMsg2(
        `Transaction's ${"maxFeePerGas" in tx$1 ? "maxFeePerGas" : "gasPrice"} (${maxFeePerGas}) is less than the block's baseFeePerGas (${baseFeePerGas})`,
        block,
        tx$1
      );
      throw new errors.InvalidParamsError(msg);
    }
  }
  let fromAccount = await vm.stateManager.getAccount(caller);
  if (fromAccount === void 0) {
    fromAccount = new utils.EthjsAccount();
  }
  const { nonce, balance } = fromAccount;
  if (vm.common.ethjsCommon.isActivatedEIP(3607) && !utils.equalsBytes(fromAccount.codeHash, KECCAK256_NULL)) {
    const msg = errorMsg2(
      "invalid sender address, address is not EOA (EIP-3607). When EIP-3607 is disabled this check is skipped",
      block,
      tx$1
    );
    throw new errors.InvalidTransactionError(msg);
  }
  const upFrontCost = tx$1.getUpfrontCost(block.header.baseFeePerGas);
  if (balance < upFrontCost) {
    if (opts.skipBalance === true && fromAccount.balance < upFrontCost) {
      if (tx$1.supports(tx.Capability.EIP1559FeeMarket) === false) {
        fromAccount.balance = upFrontCost;
        await vm.evm.journal.putAccount(caller, fromAccount);
      }
    } else {
      const msg = errorMsg2(
        `sender doesn't have enough funds to send tx. The upfront cost is: ${upFrontCost} and the sender's account (${caller}) only has: ${balance}`,
        block,
        tx$1
      );
      throw new errors.InsufficientFundsError(msg);
    }
  }
  let maxCost = tx$1.value;
  let blobGasPrice = 0n;
  let totalblobGas = 0n;
  if (tx$1.supports(tx.Capability.EIP1559FeeMarket)) {
    maxCost += tx$1.gasLimit * tx$1.maxFeePerGas;
  }
  if (tx$1 instanceof tx.BlobEIP4844Transaction) {
    if (!vm.common.ethjsCommon.isActivatedEIP(4844)) {
      const msg = errorMsg2("blob transactions are only valid with EIP4844 active", block, tx$1);
      throw new errors.EipNotEnabledError(msg);
    }
    const castTx = tx$1;
    totalblobGas = BigInt(vm.common.ethjsCommon.param("blobGasPerBlob")) * BigInt(castTx.numBlobs());
    maxCost += totalblobGas * castTx.maxFeePerBlobGas;
    if (opts.block === void 0) {
      const msg = errorMsg2("Block option must be supplied to compute blob gas price", block, tx$1);
      throw new errors.InvalidParamsError(msg);
    }
    blobGasPrice = opts.block.header.getBlobGasPrice();
    if (castTx.maxFeePerBlobGas < blobGasPrice) {
      const msg = errorMsg2(
        `Transaction's maxFeePerBlobGas ${castTx.maxFeePerBlobGas}) is less than block blobGasPrice (${blobGasPrice}).`,
        block,
        tx$1
      );
      throw new errors.InvalidGasPriceError(msg);
    }
  }
  if (fromAccount.balance < maxCost) {
    if (opts.skipBalance === true && fromAccount.balance < maxCost) {
      fromAccount.balance = maxCost;
      await vm.evm.journal.putAccount(caller, fromAccount);
    } else {
      const msg = errorMsg2(
        `sender doesn't have enough funds to send tx. The max cost is: ${maxCost} and the sender's account (${caller}) only has: ${balance}`,
        block,
        tx$1
      );
      throw new errors.InsufficientFundsError(msg);
    }
  }
  if (opts.skipNonce !== true) {
    if (nonce !== tx$1.nonce) {
      const msg = errorMsg2(
        `the tx doesn't have the correct nonce. account has nonce of: ${nonce} tx has nonce of: ${tx$1.nonce}`,
        block,
        tx$1
      );
      throw nonce > tx$1.nonce ? new errors.NonceTooLowError(msg) : new errors.NonceTooHighError(msg);
    }
  }
  let gasPrice;
  let inclusionFeePerGas;
  if (tx$1.supports(tx.Capability.EIP1559FeeMarket)) {
    const baseFee = block.header.baseFeePerGas ?? 0n;
    inclusionFeePerGas = tx$1.getEffectivePriorityFee(baseFee);
    gasPrice = inclusionFeePerGas + baseFee;
  } else {
    gasPrice = tx$1.gasPrice;
    if (vm.common.ethjsCommon.isActivatedEIP(1559)) {
      const baseFee = block.header.baseFeePerGas ?? 0n;
      inclusionFeePerGas = tx$1.gasPrice - baseFee;
    }
  }
  let blobVersionedHashes;
  if (tx$1 instanceof tx.BlobEIP4844Transaction) {
    const rawHashes = tx$1.blobVersionedHashes;
    blobVersionedHashes = rawHashes.map(
      (hash) => hash.startsWith("0x") ? hash : `0x${hash}`
    );
  }
  const txCost = tx$1.gasLimit * gasPrice;
  const blobGasCost = totalblobGas * blobGasPrice;
  fromAccount.balance -= txCost;
  fromAccount.balance -= blobGasCost;
  if (opts.skipBalance === true && fromAccount.balance < 0n) {
    fromAccount.balance = 0n;
  }
  await vm.evm.journal.putAccount(caller, fromAccount);
  const { value, data, to } = tx$1;
  const results = await vm.evm.runCall({
    block,
    gasPrice,
    caller,
    gasLimit,
    ...to !== void 0 ? { to } : {},
    ...blobVersionedHashes !== void 0 ? { blobVersionedHashes } : {},
    value,
    data,
    skipBalance: opts.skipBalance ?? false
  });
  results.bloom = txLogsBloom(results.execResult.logs, vm.common);
  results.totalGasSpent = results.execResult.executionGasUsed + txBaseFee;
  if (tx.isBlobEIP4844Tx(tx$1)) {
    results.blobGasUsed = totalblobGas;
  }
  let gasRefund = results.execResult.gasRefund ?? 0n;
  results.gasRefund = gasRefund;
  const maxRefundQuotient = BigInt(vm.common.ethjsCommon.param("maxRefundQuotient"));
  if (gasRefund !== 0n) {
    const maxRefund = results.totalGasSpent / maxRefundQuotient;
    gasRefund = gasRefund < maxRefund ? gasRefund : maxRefund;
    results.totalGasSpent -= gasRefund;
  }
  results.amountSpent = results.totalGasSpent * gasPrice;
  fromAccount = await vm.stateManager.getAccount(caller);
  if (fromAccount === void 0) {
    fromAccount = new utils.EthjsAccount();
  }
  const actualTxCost = results.totalGasSpent * gasPrice;
  const txCostDiff = txCost - actualTxCost;
  fromAccount.balance += txCostDiff;
  await vm.evm.journal.putAccount(caller, fromAccount);
  let miner;
  if (vm.common.ethjsCommon.consensusType() === common.ConsensusType.ProofOfAuthority) {
    miner = block.header.cliqueSigner();
  } else {
    miner = block.header.coinbase;
  }
  let minerAccount = await vm.stateManager.getAccount(miner);
  if (minerAccount === void 0) {
    minerAccount = new utils.EthjsAccount();
  }
  results.minerValue = vm.common.ethjsCommon.isActivatedEIP(1559) ? results.totalGasSpent * (inclusionFeePerGas ?? 0n) : results.amountSpent;
  minerAccount.balance += results.minerValue;
  await vm.evm.journal.putAccount(miner, minerAccount);
  if (results.execResult.selfdestruct !== void 0) {
    for (const addressToSelfdestructHex of results.execResult.selfdestruct) {
      const address = new utils.EthjsAddress(utils.hexToBytes(addressToSelfdestructHex));
      if (vm.common.ethjsCommon.isActivatedEIP(6780)) {
        if (!results.execResult.createdAddresses?.has(address.toString())) {
          continue;
        }
      }
      await vm.evm.journal.deleteAccount(address);
    }
  }
  if (opts.reportAccessList === true && vm.common.ethjsCommon.isActivatedEIP(2930)) {
    const accessList = [];
    if (!vm.evm.journal.accessList) {
      throw new errors.InternalError("expected journal accesslist to be defined");
    }
    for (const [address, set] of vm.evm.journal.accessList) {
      const item = {
        address,
        storageKeys: []
      };
      for (const slot of set) {
        item.storageKeys.push(slot);
      }
      accessList.push(item);
    }
    results.accessList = accessList;
  }
  if (opts.reportPreimages === true && vm.evm.journal.preimages !== void 0) {
    results.preimages = vm.evm.journal.preimages;
  }
  if (!opts.preserveJournal) await vm.evm.journal.cleanup();
  const gasUsed = (opts.blockGasUsed !== void 0 ? opts.blockGasUsed : block.header.gasUsed) ?? 0n;
  const cumulativeGasUsed = gasUsed + results.totalGasSpent;
  results.receipt = await generateTxReceipt(vm)(tx$1, results, cumulativeGasUsed, totalblobGas, blobGasPrice);
  const event = { transaction: tx$1, ...results };
  await vm._emit("afterTx", event);
  return results;
};

// src/actions/applyTransactions.ts
var applyTransactions = (vm$1) => async (block, opts) => {
  const bloom = new vm.Bloom(void 0, vm$1.common.ethjsCommon);
  let gasUsed = 0n;
  let receiptTrie;
  if (block.transactions.length !== 0) {
    receiptTrie = new trie.Trie({ common: vm$1.common.ethjsCommon });
  }
  const receipts = [];
  const txResults = [];
  for (let txIdx = 0; txIdx < block.transactions.length; txIdx++) {
    const tx = block.transactions[txIdx];
    let maxGasLimit;
    if (vm$1.common.ethjsCommon.isActivatedEIP(1559) === true) {
      maxGasLimit = block.header.gasLimit * BigInt(vm$1.common.ethjsCommon.param("elasticityMultiplier"));
    } else {
      maxGasLimit = block.header.gasLimit;
    }
    const gasLimitIsHigherThanBlock = maxGasLimit < tx.gasLimit + gasUsed;
    if (gasLimitIsHigherThanBlock) {
      const msg = errorMsg("tx has a higher gas limit than the block", vm$1, block);
      throw new errors.GasLimitExceededError(msg);
    }
    const { skipBalance = false, skipNonce = false, skipHardForkValidation = true, reportPreimages = false } = opts;
    const txRes = await runTx(vm$1)({
      tx,
      block,
      skipBalance,
      skipNonce,
      skipHardForkValidation,
      blockGasUsed: gasUsed,
      reportPreimages
    });
    txResults.push(txRes);
    gasUsed += txRes.totalGasSpent;
    bloom.or(txRes.bloom);
    receipts.push(txRes.receipt);
    const encodedReceipt = vm.encodeReceipt(txRes.receipt, tx.type);
    if (receiptTrie) {
      await receiptTrie.put(rlp.Rlp.encode(txIdx), encodedReceipt);
    }
  }
  const receiptsRoot = receiptTrie !== void 0 ? receiptTrie.root() : utils.KECCAK256_RLP;
  return {
    bloom,
    gasUsed,
    preimages: /* @__PURE__ */ new Map(),
    receiptsRoot,
    receipts,
    results: txResults
  };
};

// src/actions/calculateMinerReward.ts
function calculateMinerReward(minerReward, ommersNum) {
  const niblingReward = minerReward / BigInt(32);
  const totalNiblingReward = niblingReward * BigInt(ommersNum);
  const reward = minerReward + totalNiblingReward;
  return reward;
}

// src/actions/calculateOmmerReward.ts
function calculateOmmerReward(ommerBlockNumber, blockNumber, minerReward) {
  const heightDiff = blockNumber - ommerBlockNumber;
  let reward = (8n - heightDiff) * minerReward / 8n;
  if (reward < 0n) {
    reward = 0n;
  }
  return reward;
}
async function rewardAccount(evm, address, reward) {
  let account = await evm.stateManager.getAccount(address);
  if (account === void 0) {
    account = new utils.EthjsAccount();
  }
  account.balance += reward;
  await evm.journal.putAccount(address, account);
  return account;
}

// src/actions/assignBlockRewards.ts
var assignBlockRewards = (vm) => async (block) => {
  const minerReward = BigInt(vm.common.ethjsCommon.param("minerReward"));
  const ommers = block.uncleHeaders;
  for (const ommer of ommers) {
    const reward2 = calculateOmmerReward(ommer.number, block.header.number, minerReward);
    await rewardAccount(vm.evm, ommer.coinbase, reward2);
  }
  const reward = calculateMinerReward(minerReward, ommers.length);
  await rewardAccount(vm.evm, block.header.coinbase, reward);
};
var assignWithdrawals = (vm) => async (block) => {
  const withdrawals = block.withdrawals;
  for (const withdrawal of withdrawals) {
    const { address, amount } = withdrawal;
    await rewardAccount(vm.evm, address, utils.parseGwei(amount.toString()));
  }
};

// src/actions/applyBlock.ts
var applyBlock = (vm) => async (block, opts) => {
  if (opts.skipBlockValidation !== true) {
    if (block.header.gasLimit >= BigInt("0x8000000000000000")) {
      const msg = errorMsg("Invalid block with gas limit greater than (2^63 - 1)", vm, block);
      throw new errors.InternalError(msg);
    }
    if (opts.skipHeaderValidation !== true) {
      if (vm.blockchain && typeof vm.blockchain.validateHeader === "function") {
        await vm.blockchain.validateHeader(block.header);
      } else {
        console.warn("Skipping header validation: blockchain has no validateHeader method");
      }
    }
    if (typeof block.validateData === "function") {
      await block.validateData();
    }
  }
  if (vm.common.ethjsCommon.isActivatedEIP(4788)) {
    await accumulateParentBeaconBlockRoot(vm)(
      block.header.parentBeaconBlockRoot,
      block.header.timestamp
    );
  }
  if (vm.common.ethjsCommon.isActivatedEIP(2935)) {
    await accumulateParentBlockHash(vm)(block.header.number, block.header.parentHash);
  }
  const blockResults = await applyTransactions(vm)(block, opts);
  if (opts.reportPreimages === true) {
    if (vm.evm.stateManager.getAppliedKey === void 0) {
      throw new errors.MisconfiguredClientError(
        "applyBlock: evm.stateManager.getAppliedKey can not be undefined if reportPreimages is true"
      );
    }
    blockResults.preimages.set(
      utils.bytesToHex(vm.evm.stateManager.getAppliedKey(block.header.coinbase.toBytes())),
      block.header.coinbase.toBytes()
    );
    for (const txResult of blockResults.results) {
      if (txResult.preimages !== void 0) {
        for (const [key, preimage] of txResult.preimages) {
          blockResults.preimages.set(key, preimage);
        }
      }
    }
  }
  if (vm.common.ethjsCommon.isActivatedEIP(4895)) {
    if (opts.reportPreimages === true) vm.evm.journal.startReportingPreimages?.();
    await assignWithdrawals(vm)(block);
    if (opts.reportPreimages === true && vm.evm.journal.preimages !== void 0) {
      for (const [key, preimage] of vm.evm.journal.preimages) {
        blockResults.preimages.set(key, preimage);
      }
    }
    await vm.evm.journal.cleanup();
  }
  if (block.common.ethjsCommon.consensusType() === common.ConsensusType.ProofOfWork) {
    await assignBlockRewards(vm)(block);
  }
  return blockResults;
};

// src/actions/DAOConfig.ts
var DAOConfig = {
  DAOAccounts: [
    "d4fe7bc31cedb7bfb8a345f31e668033056b2728",
    "b3fb0e5aba0e20e5c49d252dfd30e102b171a425",
    "2c19c7f9ae8b751e37aeb2d93a699722395ae18f",
    "ecd135fa4f61a655311e86238c92adcd779555d2",
    "1975bd06d486162d5dc297798dfc41edd5d160a7",
    "a3acf3a1e16b1d7c315e23510fdd7847b48234f6",
    "319f70bab6845585f412ec7724b744fec6095c85",
    "06706dd3f2c9abf0a21ddcc6941d9b86f0596936",
    "5c8536898fbb74fc7445814902fd08422eac56d0",
    "6966ab0d485353095148a2155858910e0965b6f9",
    "779543a0491a837ca36ce8c635d6154e3c4911a6",
    "2a5ed960395e2a49b1c758cef4aa15213cfd874c",
    "5c6e67ccd5849c0d29219c4f95f1a7a93b3f5dc5",
    "9c50426be05db97f5d64fc54bf89eff947f0a321",
    "200450f06520bdd6c527622a273333384d870efb",
    "be8539bfe837b67d1282b2b1d61c3f723966f049",
    "6b0c4d41ba9ab8d8cfb5d379c69a612f2ced8ecb",
    "f1385fb24aad0cd7432824085e42aff90886fef5",
    "d1ac8b1ef1b69ff51d1d401a476e7e612414f091",
    "8163e7fb499e90f8544ea62bbf80d21cd26d9efd",
    "51e0ddd9998364a2eb38588679f0d2c42653e4a6",
    "627a0a960c079c21c34f7612d5d230e01b4ad4c7",
    "f0b1aa0eb660754448a7937c022e30aa692fe0c5",
    "24c4d950dfd4dd1902bbed3508144a54542bba94",
    "9f27daea7aca0aa0446220b98d028715e3bc803d",
    "a5dc5acd6a7968a4554d89d65e59b7fd3bff0f90",
    "d9aef3a1e38a39c16b31d1ace71bca8ef58d315b",
    "63ed5a272de2f6d968408b4acb9024f4cc208ebf",
    "6f6704e5a10332af6672e50b3d9754dc460dfa4d",
    "77ca7b50b6cd7e2f3fa008e24ab793fd56cb15f6",
    "492ea3bb0f3315521c31f273e565b868fc090f17",
    "0ff30d6de14a8224aa97b78aea5388d1c51c1f00",
    "9ea779f907f0b315b364b0cfc39a0fde5b02a416",
    "ceaeb481747ca6c540a000c1f3641f8cef161fa7",
    "cc34673c6c40e791051898567a1222daf90be287",
    "579a80d909f346fbfb1189493f521d7f48d52238",
    "e308bd1ac5fda103967359b2712dd89deffb7973",
    "4cb31628079fb14e4bc3cd5e30c2f7489b00960c",
    "ac1ecab32727358dba8962a0f3b261731aad9723",
    "4fd6ace747f06ece9c49699c7cabc62d02211f75",
    "440c59b325d2997a134c2c7c60a8c61611212bad",
    "4486a3d68fac6967006d7a517b889fd3f98c102b",
    "9c15b54878ba618f494b38f0ae7443db6af648ba",
    "27b137a85656544b1ccb5a0f2e561a5703c6a68f",
    "21c7fdb9ed8d291d79ffd82eb2c4356ec0d81241",
    "23b75c2f6791eef49c69684db4c6c1f93bf49a50",
    "1ca6abd14d30affe533b24d7a21bff4c2d5e1f3b",
    "b9637156d330c0d605a791f1c31ba5890582fe1c",
    "6131c42fa982e56929107413a9d526fd99405560",
    "1591fc0f688c81fbeb17f5426a162a7024d430c2",
    "542a9515200d14b68e934e9830d91645a980dd7a",
    "c4bbd073882dd2add2424cf47d35213405b01324",
    "782495b7b3355efb2833d56ecb34dc22ad7dfcc4",
    "58b95c9a9d5d26825e70a82b6adb139d3fd829eb",
    "3ba4d81db016dc2890c81f3acec2454bff5aada5",
    "b52042c8ca3f8aa246fa79c3feaa3d959347c0ab",
    "e4ae1efdfc53b73893af49113d8694a057b9c0d1",
    "3c02a7bc0391e86d91b7d144e61c2c01a25a79c5",
    "0737a6b837f97f46ebade41b9bc3e1c509c85c53",
    "97f43a37f595ab5dd318fb46e7a155eae057317a",
    "52c5317c848ba20c7504cb2c8052abd1fde29d03",
    "4863226780fe7c0356454236d3b1c8792785748d",
    "5d2b2e6fcbe3b11d26b525e085ff818dae332479",
    "5f9f3392e9f62f63b8eac0beb55541fc8627f42c",
    "057b56736d32b86616a10f619859c6cd6f59092a",
    "9aa008f65de0b923a2a4f02012ad034a5e2e2192",
    "304a554a310c7e546dfe434669c62820b7d83490",
    "914d1b8b43e92723e64fd0a06f5bdb8dd9b10c79",
    "4deb0033bb26bc534b197e61d19e0733e5679784",
    "07f5c1e1bc2c93e0402f23341973a0e043f7bf8a",
    "35a051a0010aba705c9008d7a7eff6fb88f6ea7b",
    "4fa802324e929786dbda3b8820dc7834e9134a2a",
    "9da397b9e80755301a3b32173283a91c0ef6c87e",
    "8d9edb3054ce5c5774a420ac37ebae0ac02343c6",
    "0101f3be8ebb4bbd39a2e3b9a3639d4259832fd9",
    "5dc28b15dffed94048d73806ce4b7a4612a1d48f",
    "bcf899e6c7d9d5a215ab1e3444c86806fa854c76",
    "12e626b0eebfe86a56d633b9864e389b45dcb260",
    "a2f1ccba9395d7fcb155bba8bc92db9bafaeade7",
    "ec8e57756626fdc07c63ad2eafbd28d08e7b0ca5",
    "d164b088bd9108b60d0ca3751da4bceb207b0782",
    "6231b6d0d5e77fe001c2a460bd9584fee60d409b",
    "1cba23d343a983e9b5cfd19496b9a9701ada385f",
    "a82f360a8d3455c5c41366975bde739c37bfeb8a",
    "9fcd2deaff372a39cc679d5c5e4de7bafb0b1339",
    "005f5cee7a43331d5a3d3eec71305925a62f34b6",
    "0e0da70933f4c7849fc0d203f5d1d43b9ae4532d",
    "d131637d5275fd1a68a3200f4ad25c71a2a9522e",
    "bc07118b9ac290e4622f5e77a0853539789effbe",
    "47e7aa56d6bdf3f36be34619660de61275420af8",
    "acd87e28b0c9d1254e868b81cba4cc20d9a32225",
    "adf80daec7ba8dcf15392f1ac611fff65d94f880",
    "5524c55fb03cf21f549444ccbecb664d0acad706",
    "40b803a9abce16f50f36a77ba41180eb90023925",
    "fe24cdd8648121a43a7c86d289be4dd2951ed49f",
    "17802f43a0137c506ba92291391a8a8f207f487d",
    "253488078a4edf4d6f42f113d1e62836a942cf1a",
    "86af3e9626fce1957c82e88cbf04ddf3a2ed7915",
    "b136707642a4ea12fb4bae820f03d2562ebff487",
    "dbe9b615a3ae8709af8b93336ce9b477e4ac0940",
    "f14c14075d6c4ed84b86798af0956deef67365b5",
    "ca544e5c4687d109611d0f8f928b53a25af72448",
    "aeeb8ff27288bdabc0fa5ebb731b6f409507516c",
    "cbb9d3703e651b0d496cdefb8b92c25aeb2171f7",
    "6d87578288b6cb5549d5076a207456a1f6a63dc0",
    "b2c6f0dfbb716ac562e2d85d6cb2f8d5ee87603e",
    "accc230e8a6e5be9160b8cdf2864dd2a001c28b6",
    "2b3455ec7fedf16e646268bf88846bd7a2319bb2",
    "4613f3bca5c44ea06337a9e439fbc6d42e501d0a",
    "d343b217de44030afaa275f54d31a9317c7f441e",
    "84ef4b2357079cd7a7c69fd7a37cd0609a679106",
    "da2fef9e4a3230988ff17df2165440f37e8b1708",
    "f4c64518ea10f995918a454158c6b61407ea345c",
    "7602b46df5390e432ef1c307d4f2c9ff6d65cc97",
    "bb9bc244d798123fde783fcc1c72d3bb8c189413",
    "807640a13483f8ac783c557fcdf27be11ea4ac7a"
  ],
  DAORefundContract: "bf4ed7b27f1d666546e30d74d50d173d20bca754"
};

// src/actions/applyDAOHardfork.ts
async function applyDAOHardfork(evm) {
  const state = evm.stateManager;
  const DAOAccountList = DAOConfig.DAOAccounts;
  const DAORefundContract = DAOConfig.DAORefundContract;
  const DAORefundContractAddress = new utils.EthjsAddress(utils.hexToBytes(`0x${DAORefundContract}`));
  if (await state.getAccount(DAORefundContractAddress) === void 0) {
    await evm.journal.putAccount(DAORefundContractAddress, new utils.EthjsAccount());
  }
  let DAORefundAccount = await state.getAccount(DAORefundContractAddress);
  if (DAORefundAccount === void 0) {
    DAORefundAccount = new utils.EthjsAccount();
  }
  for (const addr of DAOAccountList) {
    const address = new utils.EthjsAddress(utils.hexToBytes(addr));
    let account = await state.getAccount(address);
    if (account === void 0) {
      account = new utils.EthjsAccount();
    }
    DAORefundAccount.balance += account.balance;
    account.balance = 0n;
    await evm.journal.putAccount(address, account);
  }
  await evm.journal.putAccount(DAORefundContractAddress, DAORefundAccount);
}

// src/actions/BuildStatus.ts
var BuildStatus = /* @__PURE__ */ ((BuildStatus2) => {
  BuildStatus2["Reverted"] = "reverted";
  BuildStatus2["Build"] = "build";
  BuildStatus2["Pending"] = "pending";
  return BuildStatus2;
})(BuildStatus || {});

// src/actions/BlockBuilder.ts
var BlockBuilder = class {
  /**
   * The cumulative gas used by the transactions added to the block.
   */
  gasUsed = 0n;
  /**
   *  The cumulative blob gas used by the blobs in a block
   */
  blobGasUsed = 0n;
  /**
   * Value of the block, represented by the final transaction fees
   * acruing to the miner.
   */
  _minerValue = 0n;
  vm;
  blockOpts;
  headerData;
  transactions = [];
  transactionResults = [];
  withdrawals;
  checkpointed = false;
  blockStatus = { status: "pending" /* Pending */ };
  get transactionReceipts() {
    return this.transactionResults.map((result) => result.receipt);
  }
  get minerValue() {
    return this._minerValue;
  }
  constructor(vm, opts) {
    this.vm = vm;
    this.blockOpts = {
      putBlockIntoBlockchain: true,
      common: this.vm.common,
      freeze: false,
      ...opts.blockOpts
    };
    this.headerData = {
      ...opts.headerData,
      parentHash: opts.parentBlock.hash(),
      number: opts.headerData?.number ?? opts.parentBlock.header.number + 1n,
      gasLimit: opts.headerData?.gasLimit ?? opts.parentBlock.header.gasLimit,
      timestamp: opts.headerData?.timestamp ?? BigInt(Math.round(Date.now() / 1e3))
    };
    this.withdrawals = opts.withdrawals?.map((w) => utils.Withdrawal.fromWithdrawalData(w));
    if (this.vm.common.ethjsCommon.isActivatedEIP(1559) === true && typeof this.headerData.baseFeePerGas === "undefined") {
      if (this.headerData.number === vm.common.ethjsCommon.hardforkBlock("london")) {
        this.headerData.baseFeePerGas = BigInt(vm.common.ethjsCommon.param("initialBaseFee"));
      } else {
        this.headerData.baseFeePerGas = opts.parentBlock.header.calcNextBaseFee();
      }
    }
    if (typeof this.headerData.gasLimit === "undefined") {
      if (this.headerData.number === vm.common.ethjsCommon.hardforkBlock("london")) {
        this.headerData.gasLimit = opts.parentBlock.header.gasLimit * 2n;
      } else {
        this.headerData.gasLimit = opts.parentBlock.header.gasLimit;
      }
    }
    if (this.vm.common.ethjsCommon.isActivatedEIP(4844) === true && typeof this.headerData.excessBlobGas === "undefined") {
      this.headerData.excessBlobGas = opts.parentBlock.header.calcNextExcessBlobGas();
    }
  }
  /**
   * Throws if the block has already been built or reverted.
   */
  checkStatus() {
    if (this.blockStatus.status === "build" /* Build */) {
      throw new errors.InternalError("Block has already been built");
    }
    if (this.blockStatus.status === "reverted" /* Reverted */) {
      throw new errors.InternalError("State has already been reverted");
    }
  }
  getStatus() {
    return this.blockStatus;
  }
  /**
   * Calculates and returns the transactionsTrie for the block.
   */
  async transactionsTrie() {
    return block.Block.genTransactionsTrieRoot(
      this.transactions,
      new trie.Trie({ common: this.vm.common.ethjsCommon })
    );
  }
  /**
   * Calculates and returns the logs bloom for the block.
   */
  logsBloom() {
    const bloom = new vm.Bloom(void 0, this.vm.common.ethjsCommon);
    for (const txResult of this.transactionResults) {
      bloom.or(txResult.bloom);
    }
    return bloom.bitvector;
  }
  /**
   * Calculates and returns the receiptTrie for the block.
   */
  async receiptTrie() {
    if (this.transactionResults.length === 0) {
      return utils.KECCAK256_RLP;
    }
    const receiptTrie = new trie.Trie({ common: this.vm.common.ethjsCommon });
    for (const [i, txResult] of this.transactionResults.entries()) {
      const tx = this.transactions[i];
      if (!tx)
        throw new errors.InternalError(
          "expected tx to exist. This error should have been impossible and indicates a bug in tevm. Please open an issue"
        );
      const encodedReceipt = vm.encodeReceipt(txResult.receipt, tx.type);
      await receiptTrie.put(rlp.Rlp.encode(i), encodedReceipt);
    }
    return receiptTrie.root();
  }
  /**
   * Adds the block miner reward to the coinbase account.
   */
  async rewardMiner() {
    const minerReward = this.vm.common.ethjsCommon.param("minerReward");
    const reward = calculateMinerReward(minerReward, 0);
    const coinbase = this.headerData.coinbase !== void 0 ? new utils.EthjsAddress(
      this.headerData.coinbase instanceof utils.EthjsAddress ? this.headerData.coinbase.toBytes() : typeof this.headerData.coinbase === "string" ? utils.hexToBytes(this.headerData.coinbase) : this.headerData.coinbase
    ) : new utils.EthjsAddress(new Uint8Array(20));
    await rewardAccount(this.vm.evm, coinbase, reward);
  }
  /**
   * Adds the withdrawal amount to the withdrawal address
   */
  async processWithdrawals() {
    for (const withdrawal of this.withdrawals ?? []) {
      const { address, amount } = withdrawal;
      if (amount === 0n) continue;
      await rewardAccount(this.vm.evm, address, utils.parseGwei(amount.toString()));
    }
  }
  /**
   * Run and add a transaction to the block being built.
   * Please note that this modifies the state of the VM.
   * Throws if the transaction's gasLimit is greater than
   * the remaining gas in the block.
   */
  async addTransaction(tx$1, {
    skipBalance,
    skipNonce,
    skipHardForkValidation
  } = {}) {
    let _tx = tx$1;
    this.checkStatus();
    if (!this.checkpointed) {
      await this.vm.evm.journal.checkpoint();
      this.checkpointed = true;
    }
    const gasLimit = this.headerData.gasLimit ?? 0n;
    const blockGasLimit = utils.toType(gasLimit, utils.TypeOutput.BigInt) ?? 0n;
    const blobGasLimit = this.vm.common.ethjsCommon.param("targetBlobGasPerBlock");
    const blobGasPerBlob = this.vm.common.ethjsCommon.param("blobGasPerBlob");
    const blockGasRemaining = blockGasLimit - this.gasUsed;
    if (_tx.gasLimit > blockGasRemaining) {
      throw new errors.InvalidGasLimitError("tx has a higher gas limit than the remaining gas in the block");
    }
    let blobGasUsed;
    if (_tx instanceof tx.BlobEIP4844Transaction) {
      if (this.blockOpts.common?.ethjsCommon.isActivatedEIP(4844) !== true) {
        throw new errors.EipNotEnabledError("eip4844 not activated yet for adding a blob transaction");
      }
      const blobTx = _tx;
      if (blobTx.blobs === void 0) {
        throw new errors.InvalidBlobVersionedHashesError("blobs missing for 4844 transaction");
      }
      if (this.blobGasUsed + BigInt(blobTx.numBlobs()) * blobGasPerBlob > blobGasLimit) {
        throw new errors.BlockGasLimitExceededError("block blob gas limit reached");
      }
      blobGasUsed = this.blobGasUsed;
    }
    const header = {
      ...this.headerData,
      gasUsed: this.gasUsed,
      // correct excessBlobGas should already part of headerData used above
      blobGasUsed
    };
    const blockData = { header, transactions: this.transactions };
    const block$1 = block.Block.fromBlockData(blockData, this.blockOpts);
    const result = await runTx(this.vm)({
      tx: _tx,
      block: block$1,
      skipBalance,
      skipNonce,
      skipHardForkValidation
    });
    if (_tx instanceof tx.BlobEIP4844Transaction) {
      const txData = _tx;
      this.blobGasUsed += BigInt(txData.blobVersionedHashes.length) * blobGasPerBlob;
      _tx = tx.BlobEIP4844Transaction.minimalFromNetworkWrapper(txData, {
        common: this.blockOpts.common.ethjsCommon
      });
    }
    this.transactions.push(_tx);
    this.transactionResults.push(result);
    this.gasUsed += result.totalGasSpent;
    this._minerValue += result.minerValue;
    return result;
  }
  /**
   * Reverts the checkpoint on the StateManager to reset the state from any transactions that have been run.
   */
  async revert() {
    if (this.checkpointed) {
      await this.vm.evm.journal.revert();
      this.checkpointed = false;
    }
    this.blockStatus = { status: "reverted" /* Reverted */ };
  }
  /**
   * This method returns the finalized block.
   * It also:
   *  - Assigns the reward for miner (PoW)
   *  - Commits the checkpoint on the StateManager
   *  - Sets the tip of the VM's blockchain to this block
   * For PoW, optionally seals the block with params `nonce` and `mixHash`,
   * which is validated along with the block number and difficulty by ethash.
   * For PoA, please pass `blockOption.cliqueSigner` into the buildBlock constructor,
   * as the signer will be awarded the txs amount spent on gas as they are added.
   */
  async build(sealOpts) {
    this.checkStatus();
    const blockOpts = this.blockOpts;
    const consensusType = this.vm.common.ethjsCommon.consensusType();
    if (consensusType === common.ConsensusType.ProofOfWork) {
      await this.rewardMiner();
    }
    await this.processWithdrawals();
    const stateRoot = await this.vm.stateManager.getStateRoot();
    const transactionsTrie = await this.transactionsTrie();
    const withdrawalsRoot = this.withdrawals ? await block.Block.genWithdrawalsTrieRoot(this.withdrawals, new trie.Trie({ common: this.vm.common.ethjsCommon })) : void 0;
    const receiptTrie = await this.receiptTrie();
    const logsBloom = this.logsBloom();
    const gasUsed = this.gasUsed;
    const timestamp = this.headerData.timestamp ?? 0n;
    let blobGasUsed;
    if (this.vm.common.ethjsCommon.isActivatedEIP(4844) === true) {
      blobGasUsed = this.blobGasUsed;
    }
    const headerData = {
      ...this.headerData,
      stateRoot,
      transactionsTrie,
      ...withdrawalsRoot !== void 0 ? { withdrawalsRoot } : {},
      ...blobGasUsed !== void 0 ? { blobGasUsed } : {},
      receiptTrie,
      logsBloom,
      gasUsed,
      timestamp
      // correct excessBlobGas should already be part of headerData used above
    };
    if (consensusType === common.ConsensusType.ProofOfWork) {
      headerData.nonce = sealOpts?.nonce ?? headerData.nonce;
      headerData.mixHash = sealOpts?.mixHash ?? headerData.mixHash;
    }
    const blockData = {
      header: headerData,
      transactions: this.transactions,
      withdrawals: this.withdrawals ?? []
    };
    const block$1 = block.Block.fromBlockData(blockData, blockOpts);
    if (this.blockOpts.putBlockIntoBlockchain === true) {
      await this.vm.blockchain.putBlock(block$1);
    }
    this.blockStatus = { status: "build" /* Build */, block: block$1 };
    if (this.checkpointed) {
      await this.vm.evm.journal.commit();
      this.checkpointed = false;
    }
    return block$1;
  }
  async initState() {
    if (this.vm.common.ethjsCommon.isActivatedEIP(4788)) {
      if (!this.checkpointed) {
        await this.vm.evm.journal.checkpoint();
        this.checkpointed = true;
      }
      const { parentBeaconBlockRoot, timestamp } = this.headerData;
      const timestampValue = timestamp ?? 0n;
      const timestampBigInt = utils.toType(timestampValue, utils.TypeOutput.BigInt) ?? 0n;
      const parentBeaconBlockRootBuf = parentBeaconBlockRoot ? utils.toType(parentBeaconBlockRoot, utils.TypeOutput.Uint8Array) : new Uint8Array(32);
      await accumulateParentBeaconBlockRoot(this.vm)(
        parentBeaconBlockRootBuf,
        timestampBigInt
      );
    }
    if (this.vm.common.ethjsCommon.isActivatedEIP(2935)) {
      if (!this.checkpointed) {
        await this.vm.evm.journal.checkpoint();
        this.checkpointed = true;
      }
      const { parentHash, number } = this.headerData;
      const numberValue = number ?? 0n;
      const numberBigInt = utils.toType(numberValue, utils.TypeOutput.BigInt) ?? 0n;
      const parentHashSanitized = parentHash ? utils.toType(parentHash, utils.TypeOutput.Uint8Array) : new Uint8Array(32);
      await accumulateParentBlockHash(this.vm)(numberBigInt, parentHashSanitized);
    }
  }
};

// src/actions/buildBlock.ts
var buildBlock = (vm) => async (opts) => {
  await vm.ready();
  const blockBuilder = new BlockBuilder(vm, opts);
  await blockBuilder.initState();
  return blockBuilder;
};
var createBaseVm = (opts) => {
  const events = new eventemitter3.EventEmitter();
  return {
    stateManager: opts.stateManager,
    evm: opts.evm,
    blockchain: opts.blockchain,
    common: opts.common,
    events,
    _emit: async (topic, data) => {
      try {
        return new Promise((resolve, reject) => {
          try {
            const hasListeners = events.emit(topic, data, resolve);
            if (!hasListeners) {
              resolve();
            }
          } catch (e) {
            reject(e);
          }
        });
      } catch (e) {
        console.error(e);
      }
    },
    ready: async () => {
      await Promise.all([opts.blockchain.ready(), opts.stateManager.ready()]);
      return true;
    }
  };
};

// src/actions/deepCopy.js
var deepCopy = (baseVm) => async () => {
  await baseVm.ready();
  const common = baseVm.common.copy();
  common.ethjsCommon.setHardfork(baseVm.common.ethjsCommon.hardfork());
  const blockchain = await baseVm.blockchain.deepCopy();
  if (!("deepCopy" in baseVm.stateManager)) {
    throw new errors.MisconfiguredClientError("StateManager does not support deepCopy. Was a Tevm state manager used?");
  }
  const stateManager = await baseVm.stateManager.deepCopy();
  const evmCopy = await evm.createEvm({
    blockchain,
    common,
    stateManager,
    allowUnlimitedContractSize: baseVm.evm.allowUnlimitedContractSize ?? false,
    customPrecompiles: (
      /** @type {any} */
      baseVm.evm._customPrecompiles
    ),
    // customPredeploys isn't needed because it will be copied along in stateManager.deepCopy
    // customPredeploys,
    profiler: Boolean(
      /** @type {any} */
      baseVm.evm.optsCached?.profiler?.enabled
    ) ?? false
  });
  const evmAny = (
    /** @type {any}*/
    evmCopy
  );
  evmAny.DEBUG = baseVm.evm.DEBUG;
  evmAny._debug = /** @type any*/
  baseVm.evm._debug;
  return createBaseVm({
    stateManager,
    blockchain,
    common,
    evm: evmCopy
  });
};
async function genTxTrie(block) {
  if (block.transactions.length === 0) {
    return utils.KECCAK256_RLP;
  }
  const trie$1 = new trie.Trie({ common: block.common.ethjsCommon });
  for (let i = 0; i < block.transactions.length; i++) {
    const tx = block.transactions[i];
    if (tx) {
      await trie$1.put(rlp.Rlp.encode(i), tx.serialize());
    }
  }
  return trie$1.root();
}
var runBlock = (vm) => async (opts) => {
  await vm.ready();
  const state = vm.stateManager;
  const { root } = opts;
  const clearCache = opts.clearCache ?? true;
  let { block: block$1 } = opts;
  const generateFields = opts.generate === true;
  await vm._emit("beforeBlock", block$1);
  if (root) {
    await state.setStateRoot(root, clearCache);
  }
  if (vm.common.ethjsCommon.hardforkIsActiveOnBlock("dao", block$1.header.number) === true && block$1.header.number === vm.common.ethjsCommon.hardforkBlock("dao")) {
    await vm.evm.journal.checkpoint();
    await applyDAOHardfork(vm.evm);
    await vm.evm.journal.commit();
  }
  await vm.evm.journal.checkpoint();
  let result;
  try {
    result = await applyBlock(vm)(block$1, opts);
  } catch (err) {
    await vm.evm.journal.revert();
    throw err;
  }
  await vm.evm.journal.commit();
  await state.setStateRoot(block$1.header.stateRoot);
  const stateRoot = await state.getStateRoot();
  if (generateFields) {
    const bloom = result.bloom.bitvector;
    const gasUsed = result.gasUsed;
    const receiptTrie = result.receiptsRoot;
    const transactionsTrie = await genTxTrie(block$1);
    const generatedFields = { stateRoot, bloom, gasUsed, receiptTrie, transactionsTrie };
    const blockData = {
      ...block$1,
      header: { ...block$1.header, ...generatedFields }
    };
    block$1 = block.Block.fromBlockData(blockData, { common: vm.common });
  } else if (vm.common.ethjsCommon.isActivatedEIP(6800) === false) {
    if (utils.equalsBytes(result.receiptsRoot, block$1.header.receiptTrie) === false) {
      const msg = errorMsg("invalid receiptTrie", vm, block$1);
      throw new errors.InternalError(msg);
    }
    if (!(utils.equalsBytes(result.bloom.bitvector, block$1.header.logsBloom) === true)) {
      const msg = errorMsg("invalid bloom", vm, block$1);
      throw new errors.InternalError(msg);
    }
    if (result.gasUsed !== block$1.header.gasUsed) {
      const msg = errorMsg("invalid gasUsed", vm, block$1);
      throw new errors.InternalError(msg);
    }
    if (!(utils.equalsBytes(stateRoot, block$1.header.stateRoot) === true)) {
      const msg = errorMsg(
        `invalid block stateRoot, got: ${utils.bytesToHex(stateRoot)}, want: ${utils.bytesToHex(block$1.header.stateRoot)}`,
        vm,
        block$1
      );
      throw new errors.InternalError(msg);
    }
  }
  const results = {
    receipts: result.receipts,
    logsBloom: result.bloom.bitvector,
    results: result.results,
    stateRoot,
    gasUsed: result.gasUsed,
    receiptsRoot: result.receiptsRoot,
    ...result.preimages !== void 0 ? { preimages: result.preimages } : {}
  };
  const afterBlockEvent = { ...results, block: block$1 };
  await vm._emit("afterBlock", afterBlockEvent);
  return results;
};

// src/createVm.js
var createVm = (opts) => {
  const baseVm = createBaseVm(opts);
  const decorate = (baseVm2) => {
    return Object.assign(baseVm2, {
      deepCopy: () => deepCopy(baseVm2)().then((baseVm3) => decorate(baseVm3)),
      buildBlock: buildBlock(baseVm2),
      runBlock: runBlock(baseVm2),
      runTx: runTx(baseVm2)
    });
  };
  return decorate(baseVm);
};

exports.BlockBuilder = BlockBuilder;
exports.BuildStatus = BuildStatus;
exports.DAOConfig = DAOConfig;
exports.KECCAK256_NULL = KECCAK256_NULL;
exports.accumulateParentBeaconBlockRoot = accumulateParentBeaconBlockRoot;
exports.accumulateParentBlockHash = accumulateParentBlockHash;
exports.applyBlock = applyBlock;
exports.applyDAOHardfork = applyDAOHardfork;
exports.applyTransactions = applyTransactions;
exports.assignBlockRewards = assignBlockRewards;
exports.assignWithdrawals = assignWithdrawals;
exports.buildBlock = buildBlock;
exports.calculateMinerReward = calculateMinerReward;
exports.calculateOmmerReward = calculateOmmerReward;
exports.createVm = createVm;
exports.deepCopy = deepCopy;
exports.execHardfork = execHardfork;
exports.genTxTrie = genTxTrie;
exports.generateTxReceipt = generateTxReceipt;
exports.parentBeaconBlockRootAddress = parentBeaconBlockRootAddress;
exports.rewardAccount = rewardAccount;
exports.runBlock = runBlock;
exports.runTx = runTx;
exports.txLogsBloom = txLogsBloom;
exports.validateRunTx = validateRunTx;
exports.warmAddresses2929 = warmAddresses2929;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map