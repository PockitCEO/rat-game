import { Chain } from '@tevm/blockchain';
import * as _tevm_common from '@tevm/common';
import { Common } from '@tevm/common';
import { EvmResult, Evm, EvmType } from '@tevm/evm';
import { StateManager } from '@tevm/state';
import * as _tevm_utils from '@tevm/utils';
import { EthjsLog, Hex, WithdrawalData, BigIntLike, GenesisState, AsyncEventEmitter, EthjsAddress, EthjsAccount } from '@tevm/utils';
import { ClRequest, Block, BlockOptions, HeaderData } from '@tevm/block';
import * as _tevm_tx from '@tevm/tx';
import { AccessList, TypedTransaction, ImpersonatedTx } from '@tevm/tx';
import { Bloom } from '@ethereumjs/vm';
import { InvalidGasLimitError, EipNotEnabledError, BlockGasLimitExceededError, MisconfiguredClientError } from '@tevm/errors';
import * as viem from 'viem';

/**
 * Abstract interface with common transaction receipt fields
 */
interface BaseTxReceipt {
    /**
     * Cumulative gas used in the block including this tx
     */
    cumulativeBlockGasUsed: bigint;
    /**
     * Bloom bitvector
     */
    bitvector: Uint8Array;
    /**
     * Logs emitted
     */
    logs: EthjsLog[];
}

/**
 * Receipt type for Byzantium and beyond replacing the intermediary
 * state root field with a status code field (EIP-658)
 */
interface PostByzantiumTxReceipt extends BaseTxReceipt {
    /**
     * Status of transaction, `1` if successful, `0` if an exception occurred
     */
    status: 0 | 1;
}

/**
 * Transaction receipt format for EIP-4844 blob transactions.
 * Extends PostByzantiumTxReceipt with additional blob gas information.
 * @example
 * ```typescript
 * import { EIP4844BlobTxReceipt } from '@tevm/vm'
 *
 * const receipt: EIP4844BlobTxReceipt = {
 *   status: 1n,
 *   cumulativeBlockGasUsed: 100000n,
 *   bitvector: new Uint8Array([]),
 *   logs: [],
 *   blobGasUsed: 131072n,
 *   blobGasPrice: 10n
 * }
 * ```
 */
interface EIP4844BlobTxReceipt extends PostByzantiumTxReceipt {
    /**
     * blob gas consumed by a transaction
     *
     * Note: This value is not included in the receiptRLP used for encoding the receiptsRoot in a block
     * and is only provided as part of receipt metadata.
     */
    blobGasUsed: bigint;
    /**
     * blob gas price for block transaction was included in
     *
     * Note: This valus is not included in the `receiptRLP` used for encoding the `receiptsRoot` in a block
     * and is only provided as part of receipt metadata.
     */
    blobGasPrice: bigint;
}

/**
 * Pre-Byzantium receipt type with a field
 * for the intermediary state root
 */
interface PreByzantiumTxReceipt extends BaseTxReceipt {
    /**
     * Intermediary state root
     */
    stateRoot: Uint8Array;
}

/**
 * Union type representing all supported transaction receipt formats.
 * Includes pre-Byzantium, post-Byzantium, and EIP-4844 blob transaction receipts.
 * The receipt format varies based on the Ethereum hardfork in use.
 * @example
 * ```typescript
 * import { TxReceipt } from '@tevm/vm'
 *
 * // Example of a post-Byzantium receipt
 * const receipt: TxReceipt = {
 *   status: 1n, // Transaction succeeded
 *   cumulativeBlockGasUsed: 100000n,
 *   bitvector: new Uint8Array([]),
 *   logs: []
 * }
 * ```
 */
type TxReceipt = PreByzantiumTxReceipt | PostByzantiumTxReceipt | EIP4844BlobTxReceipt;

/**
 * Execution result of a transaction
 */
interface RunTxResult extends EvmResult {
    /**
     * Bloom filter resulted from transaction
     */
    bloom: Bloom;
    /**
     * The amount of ether used by this transaction
     */
    amountSpent: bigint;
    /**
     * The tx receipt
     */
    receipt: TxReceipt;
    /**
     * The amount of gas used in this transaction, which is paid for
     * This contains the gas units that have been used on execution, plus the upfront cost,
     * which consists of calldata cost, intrinsic cost and optionally the access list costs
     */
    totalGasSpent: bigint;
    /**
     * The amount of gas as that was refunded during the transaction (i.e. `gasUsed = totalGasConsumed - gasRefund`)
     */
    gasRefund: bigint;
    /**
     * EIP-2930 access list generated for the tx (see `reportAccessList` option)
     */
    accessList?: AccessList;
    /**
     * Preimages mapping of the touched accounts from the tx (see `reportPreimages` option)
     */
    preimages?: Map<Hex, Uint8Array>;
    /**
     * The value that accrues to the miner by this transaction
     */
    minerValue: bigint;
    /**
     * This is the blob gas units times the fee per blob gas for 4844 transactions
     */
    blobGasUsed?: bigint;
}

/**
 * Result of {@link applyBlock}
 */
interface ApplyBlockResult {
    /**
     * The Bloom filter
     */
    bloom: Bloom;
    /**
     * The gas used after executing the block
     */
    gasUsed: bigint;
    /**
     * The receipt root after executing the block
     */
    receiptsRoot: Uint8Array;
    /**
     * Receipts generated for transactions in the block
     */
    receipts: TxReceipt[];
    /**
     * Results of executing the transactions in the block
     */
    results: RunTxResult[];
    /**
     * Preimages mapping of the touched accounts from the block (see reportPreimages option)
     */
    preimages?: Map<Hex, Uint8Array>;
}

/**
 * Result of {@link runBlock}
 */
interface RunBlockResult extends Omit<ApplyBlockResult, 'bloom'> {
    /**
     * The stateRoot after executing the block
     */
    stateRoot: Uint8Array;
    /**
     * The bloom filter of the LOGs (events) after executing the block
     */
    logsBloom: Uint8Array;
    /**
     * The requestsRoot for any CL requests in the block
     */
    requestsRoot?: Uint8Array;
    /**
     * Any CL requests that were processed in the course of this block
     */
    requests?: ClRequest[];
}

/**
 * Event data emitted after a block has been processed.
 * Extends RunBlockResult with the block that was processed.
 * @example
 * ```typescript
 * import { AfterBlockEvent } from '@tevm/vm'
 * import { VM } from '@tevm/vm'
 *
 * // Access in VM event handlers
 * const vm = new VM()
 * vm.events.on('afterBlock', (event: AfterBlockEvent) => {
 *   console.log('Block processed:', event.block.header.number)
 *   console.log('Receipts:', event.receipts)
 * })
 * ```
 */
interface AfterBlockEvent extends RunBlockResult {
    block: Block;
}

/**
 * Event data emitted after a transaction has been executed.
 * Extends RunTxResult with the transaction that triggered the event.
 * @example
 * ```typescript
 * import { AfterTxEvent } from '@tevm/vm'
 * import { VM } from '@tevm/vm'
 *
 * // Access in VM event handlers
 * const vm = new VM()
 * vm.events.on('afterTx', (event: AfterTxEvent) => {
 *   console.log('Transaction executed:', event.transaction)
 *   console.log('Gas used:', event.gasUsed)
 * })
 * ```
 */
interface AfterTxEvent extends RunTxResult {
    /**
     * The transaction which just got finished
     */
    transaction: TypedTransaction;
}

/**
 * Options for the block builder.
 */
interface BuilderOpts extends BlockOptions {
    /**
     * Whether to put the block into the vm's blockchain after building it.
     * This is useful for completing a full cycle when building a block so
     * the only next step is to build again, however it may not be desired
     * if the block is being emulated or may be discarded as to not affect
     * the underlying blockchain.
     *
     * Default: true
     */
    putBlockIntoBlockchain?: boolean;
}

/**
 * Options for building a block.
 */
interface BuildBlockOpts {
    /**
     * The parent block
     */
    parentBlock: Block;
    /**
     * The block header data to use.
     * Defaults used for any values not provided.
     */
    headerData?: HeaderData;
    withdrawals?: WithdrawalData[];
    /**
     * The block and builder options to use.
     */
    blockOpts?: BuilderOpts;
}

/**
 * Configuration options for EVM code execution profiling.
 * Controls whether detailed execution metrics are collected.
 * @example
 * ```typescript
 * import { EVMProfilerOpts } from '@tevm/vm'
 *
 * const value: EVMProfilerOpts = {
 *   enabled: true // Enable EVM profiling to collect execution metrics
 * }
 * ```
 */
type EVMProfilerOpts = {
    enabled: boolean;
};

/**
 * Options for running a block.
 */
interface RunBlockOpts {
    /**
     * The @ethereumjs/block to process
     */
    block: Block;
    /**
     * Root of the state trie
     */
    root?: Uint8Array;
    /**
     * Clearing the StateManager cache.
     *
     * If state root is not reset for whatever reason this can be set to `false` for better performance.
     *
     * Default: true
     */
    clearCache?: boolean;
    /**
     * Whether to generate the stateRoot and other related fields.
     * If `true`, `runBlock` will set the fields `stateRoot`, `receiptTrie`, `gasUsed`, and `bloom` (logs bloom) after running the block.
     * If `false`, `runBlock` throws if any fields do not match.
     * Defaults to `false`.
     */
    generate?: boolean;
    /**
     * If true, will skip "Block validation":
     * Block validation validates the header (with respect to the blockchain),
     * the transactions, the transaction trie and the uncle hash.
     */
    skipBlockValidation?: boolean;
    /**
     * If true, skips the hardfork validation of vm, block
     * and tx
     */
    skipHardForkValidation?: boolean;
    /**
     * if true, will skip "Header validation"
     * If the block has been picked from the blockchain to be executed,
     * header has already been validated, and can be skipped especially when
     * consensus of the chain has moved ahead.
     */
    skipHeaderValidation?: boolean;
    /**
     * If true, skips the nonce check
     */
    skipNonce?: boolean;
    /**
     * If true, checks the balance of the `from` account for the transaction and sets its
     * balance equal equal to the upfront cost (gas limit * gas price + transaction value)
     */
    skipBalance?: boolean;
    /**
     * Set the hardfork either by timestamp (for HFs from Shanghai onwards) or by block number
     * for older Hfs.
     *
     * Additionally it is possible to pass in a specific TD value to support live-Merge-HF
     * transitions. Note that this should only be needed in very rare and specific scenarios.
     *
     * Default: `false` (HF is set to whatever default HF is set by the {@link Common} instance)
     */
    setHardfork?: boolean | BigIntLike;
    /**
     * If true, adds a hashedKey -> preimages mapping of all touched accounts
     * to the `RunTxResult` returned.
     */
    reportPreimages?: boolean;
}

/**
 * Options for the `runTx` method.
 */
interface RunTxOpts {
    /**
     * The `@ethereumjs/block` the `tx` belongs to.
     * If omitted, a default blank block will be used.
     */
    block?: Block;
    /**
     * An `@ethereumjs/tx` to run
     */
    tx: TypedTransaction;
    /**
     * If true, skips the nonce check
     */
    skipNonce?: boolean;
    /**
     * Skip balance checks if true. Adds transaction cost to balance to ensure execution doesn't fail.
     */
    skipBalance?: boolean;
    /**
     * If true, skips the validation of the tx's gas limit
     * against the block's gas limit.
     */
    skipBlockGasLimitValidation?: boolean;
    /**
     * If true, skips the hardfork validation of vm, block
     * and tx
     */
    skipHardForkValidation?: boolean;
    /**
     * If true, adds a generated EIP-2930 access list
     * to the `RunTxResult` returned.
     *
     * Option works with all tx types. EIP-2929 needs to
     * be activated (included in `berlin` HF).
     *
     * Note: if this option is used with a custom {@link StateManager} implementation
     * {@link StateManager.generateAccessList} must be implemented.
     */
    reportAccessList?: boolean;
    /**
     * If true, adds a hashedKey -> preimages mapping of all touched accounts
     * to the `RunTxResult` returned.
     */
    reportPreimages?: boolean;
    /**
     * To obtain an accurate tx receipt input the block gas used up until this tx.
     */
    blockGasUsed?: bigint;
    /**
     * If true, doesn't cleanup journal or commit state changes. Default is false.
     * @internal
     */
    preserveJournal?: boolean;
}

/**
 * Options for sealing a block.
 */
interface SealBlockOpts {
    /**
     * For PoW, the nonce.
     * Overrides the value passed in the constructor.
     */
    nonce?: Uint8Array;
    /**
     * For PoW, the mixHash.
     * Overrides the value passed in the constructor.
     */
    mixHash?: Uint8Array;
}

/**
 * Event handlers for the VM execution lifecycle.
 * Allows subscribing to events before and after block/transaction processing.
 * @example
 * ```typescript
 * import { VMEvents } from '@tevm/vm'
 * import { VM } from '@tevm/vm'
 *
 * const vm = new VM()
 *
 * // Add event handlers
 * const handlers: Partial<VMEvents> = {
 *   beforeBlock: (block) => {
 *     console.log(`Processing block ${block.header.number}`)
 *   },
 *   afterTx: (data) => {
 *     console.log(`Transaction executed with status: ${data.execResult.exceptionError ? 'failed' : 'success'}`)
 *   }
 * }
 *
 * // Register handlers
 * Object.entries(handlers).forEach(([event, handler]) => {
 *   vm.events.on(event, handler)
 * })
 * ```
 */
type VMEvents = {
    beforeBlock: (data: Block, resolve?: (result?: any) => void) => void;
    afterBlock: (data: AfterBlockEvent, resolve?: (result?: any) => void) => void;
    beforeTx: (data: TypedTransaction, resolve?: (result?: any) => void) => void;
    afterTx: (data: AfterTxEvent, resolve?: (result?: any) => void) => void;
};

/**
 * Configuration options for VM profiling and performance reporting.
 * Controls when and how profiling data is reported during VM execution.
 * @example
 * ```typescript
 * import { VMProfilerOpts } from '@tevm/vm'
 *
 * const value: VMProfilerOpts = {
 *   reportAfterTx: true,    // Generate reports after each transaction
 *   reportAfterBlock: false // Don't generate reports after each block
 * }
 * ```
 */
type VMProfilerOpts = {
    reportAfterTx?: boolean;
    reportAfterBlock?: boolean;
};

/**
 * Options for instantiating a {@link VM}.
 */
interface VMOpts {
    /**
     * Use a {@link Common} instance
     * if you want to change the chain setup.
     *
     * ### Possible Values
     *
     * - `chain`: all chains supported by `Common` or a custom chain
     * - `hardfork`: `mainnet` hardforks up to the `Paris` hardfork
     * - `eips`: `2537` (usage e.g. `eips: [ 2537, ]`)
     *
     * Note: check the associated `@ethereumjs/evm` instance options
     * documentation for supported EIPs.
     *
     * ### Default Setup
     *
     * Default setup if no `Common` instance is provided:
     *
     * - `chain`: `mainnet`
     * - `hardfork`: `paris`
     * - `eips`: `[]`
     */
    common?: Common;
    /**
     * A {@link StateManager} instance to use as the state store
     */
    stateManager?: StateManager;
    /**
     * A {@link Blockchain} object for storing/retrieving blocks
     */
    blockchain?: Chain;
    /**
     * If true, create entries in the state tree for the precompiled contracts, saving some gas the
     * first time each of them is called.
     *
     * If this parameter is false, each call to each of them has to pay an extra 25000 gas
     * for creating the account. If the account is still empty after this call, it will be deleted,
     * such that this extra cost has to be paid again.
     *
     * Setting this to true has the effect of precompiled contracts' gas costs matching mainnet's from
     * the very first call, which is intended for testing networks.
     *
     * Default: `false`
     */
    activatePrecompiles?: boolean;
    /**
     * A genesisState to generate canonical genesis for the "in-house" created stateManager if external
     * stateManager not provided for the VM, defaults to an empty state
     */
    genesisState?: GenesisState;
    /**
     * Set the hardfork either by timestamp (for HFs from Shanghai onwards) or by block number
     * for older Hfs.
     *
     * Additionally it is possible to pass in a specific TD value to support live-Merge-HF
     * transitions. Note that this should only be needed in very rare and specific scenarios.
     *
     * Default: `false` (HF is set to whatever default HF is set by the {@link Common} instance)
     */
    setHardfork?: boolean | BigIntLike;
    /**
     * Use a custom EVM to run Messages on. If this is not present, use the default EVM.
     */
    evm?: Evm;
    profilerOpts?: VMProfilerOpts;
}

type BaseVm = {
    common: Common;
    stateManager: StateManager;
    blockchain: Chain;
    evm: EvmType;
    events: AsyncEventEmitter<VMEvents>;
    /**
     * This is copied from ethereumjs and we want to match the interface
     * Cached emit() function, not for public usage
     * set to public due to implementation internals
     * @hidden
     */
    _emit: (topic: keyof VMEvents, data: any) => Promise<void>;
    ready: () => Promise<true>;
};

declare const accumulateParentBeaconBlockRoot: (vm: BaseVm) => (root: Uint8Array, timestamp: bigint) => Promise<void>;

/**
 * This method runs the logic of EIP 2935 (save blockhashes to state)
 * It will put the `parentHash` of the block to the storage slot of `block.number - 1` of the history storage contract.
 * This contract is used to retrieve BLOCKHASHes in EVM if EIP 2935 is activated.
 * In case that the previous block of `block` is pre-EIP-2935 (so we are on the EIP 2935 fork block), additionally
 * also add the currently available past blockhashes which are available by BLOCKHASH (so, the past 256 block hashes)
 * @param vm The VM to run on
 * @returns Function that accumulates parent block hash
 */
declare const accumulateParentBlockHash: (vm: BaseVm) => (currentBlockNumber: bigint, parentHash: Uint8Array) => Promise<void>;

/**
 * Validates and applies a block, computing the results of
 * applying its transactions. This method doesn't modify the
 * block itself. It computes the block rewards and puts
 * them on state (but doesn't persist the changes).
 * @param {Block} block
 * @param {RunBlockOpts} opts
 */
declare const applyBlock: (vm: BaseVm) => (block: Block, opts: RunBlockOpts) => Promise<ApplyBlockResult>;

/**
 * Apply the DAO fork changes to the VM
 */
declare function applyDAOHardfork(evm: Evm): Promise<void>;

/**
 * Applies the transactions in a block, computing the receipts
 * as well as gas usage and some relevant data. This method is
 * side-effect free (it doesn't modify the block nor the state).
 */
declare const applyTransactions: (vm: BaseVm) => (block: Block, opts: RunBlockOpts) => Promise<{
    bloom: Bloom;
    gasUsed: bigint;
    preimages: Map<string, Uint8Array<ArrayBufferLike>>;
    receiptsRoot: Uint8Array<ArrayBufferLike>;
    receipts: TxReceipt[];
    results: RunTxResult[];
}>;

/**
 * Calculates block rewards for miner and ommers and puts
 * the updated balances of their accounts to state.
 */
declare const assignBlockRewards: (vm: BaseVm) => (block: Block) => Promise<void>;

declare const assignWithdrawals: (vm: BaseVm) => (block: Block) => Promise<void>;

declare enum BuildStatus {
    Reverted = "reverted",
    Build = "build",
    Pending = "pending"
}

type BlockStatus = {
    status: BuildStatus.Pending | BuildStatus.Reverted;
} | {
    status: BuildStatus.Build;
    block: Block;
};

type AddTransactionError = InvalidGasLimitError | EipNotEnabledError | BlockGasLimitExceededError;
declare class BlockBuilder {
    /**
     * The cumulative gas used by the transactions added to the block.
     */
    gasUsed: bigint;
    /**
     *  The cumulative blob gas used by the blobs in a block
     */
    blobGasUsed: bigint;
    /**
     * Value of the block, represented by the final transaction fees
     * acruing to the miner.
     */
    private _minerValue;
    private readonly vm;
    private blockOpts;
    private headerData;
    private transactions;
    private transactionResults;
    private withdrawals?;
    private checkpointed;
    private blockStatus;
    get transactionReceipts(): TxReceipt[];
    get minerValue(): bigint;
    constructor(vm: BaseVm, opts: BuildBlockOpts);
    /**
     * Throws if the block has already been built or reverted.
     */
    private checkStatus;
    getStatus(): BlockStatus;
    /**
     * Calculates and returns the transactionsTrie for the block.
     */
    transactionsTrie(): Promise<Uint8Array<ArrayBufferLike>>;
    /**
     * Calculates and returns the logs bloom for the block.
     */
    logsBloom(): Uint8Array<ArrayBufferLike>;
    /**
     * Calculates and returns the receiptTrie for the block.
     */
    receiptTrie(): Promise<Uint8Array<ArrayBufferLike>>;
    /**
     * Adds the block miner reward to the coinbase account.
     */
    private rewardMiner;
    /**
     * Adds the withdrawal amount to the withdrawal address
     */
    private processWithdrawals;
    /**
     * Run and add a transaction to the block being built.
     * Please note that this modifies the state of the VM.
     * Throws if the transaction's gasLimit is greater than
     * the remaining gas in the block.
     */
    addTransaction(tx: TypedTransaction | ImpersonatedTx, { skipBalance, skipNonce, skipHardForkValidation, }?: Pick<RunTxOpts, 'skipBalance' | 'skipNonce' | 'skipHardForkValidation'>): Promise<RunTxResult>;
    /**
     * Reverts the checkpoint on the StateManager to reset the state from any transactions that have been run.
     */
    revert(): Promise<void>;
    /**
     * This method returns the finalized block.
     * It also:
     *  - Assigns the reward for miner (PoW)
     *  - Commits the checkpoint on the StateManager
     *  - Sets the tip of the VM's blockchain to this block
     * For PoW, optionally seals the block with params `nonce` and `mixHash`,
     * which is validated along with the block number and difficulty by ethash.
     * For PoA, please pass `blockOption.cliqueSigner` into the buildBlock constructor,
     * as the signer will be awarded the txs amount spent on gas as they are added.
     */
    build(sealOpts?: SealBlockOpts): Promise<Block>;
    initState(): Promise<void>;
}

type BuildBlock = (opts: BuildBlockOpts) => Promise<BlockBuilder>;
declare const buildBlock: (vm: BaseVm) => BuildBlock;

declare function calculateMinerReward(minerReward: bigint, ommersNum: number): bigint;

declare function calculateOmmerReward(ommerBlockNumber: bigint, blockNumber: bigint, minerReward: bigint): bigint;

declare const KECCAK256_NULL: viem.ByteArray;

declare const DAOConfig: {
    readonly DAOAccounts: readonly ["d4fe7bc31cedb7bfb8a345f31e668033056b2728", "b3fb0e5aba0e20e5c49d252dfd30e102b171a425", "2c19c7f9ae8b751e37aeb2d93a699722395ae18f", "ecd135fa4f61a655311e86238c92adcd779555d2", "1975bd06d486162d5dc297798dfc41edd5d160a7", "a3acf3a1e16b1d7c315e23510fdd7847b48234f6", "319f70bab6845585f412ec7724b744fec6095c85", "06706dd3f2c9abf0a21ddcc6941d9b86f0596936", "5c8536898fbb74fc7445814902fd08422eac56d0", "6966ab0d485353095148a2155858910e0965b6f9", "779543a0491a837ca36ce8c635d6154e3c4911a6", "2a5ed960395e2a49b1c758cef4aa15213cfd874c", "5c6e67ccd5849c0d29219c4f95f1a7a93b3f5dc5", "9c50426be05db97f5d64fc54bf89eff947f0a321", "200450f06520bdd6c527622a273333384d870efb", "be8539bfe837b67d1282b2b1d61c3f723966f049", "6b0c4d41ba9ab8d8cfb5d379c69a612f2ced8ecb", "f1385fb24aad0cd7432824085e42aff90886fef5", "d1ac8b1ef1b69ff51d1d401a476e7e612414f091", "8163e7fb499e90f8544ea62bbf80d21cd26d9efd", "51e0ddd9998364a2eb38588679f0d2c42653e4a6", "627a0a960c079c21c34f7612d5d230e01b4ad4c7", "f0b1aa0eb660754448a7937c022e30aa692fe0c5", "24c4d950dfd4dd1902bbed3508144a54542bba94", "9f27daea7aca0aa0446220b98d028715e3bc803d", "a5dc5acd6a7968a4554d89d65e59b7fd3bff0f90", "d9aef3a1e38a39c16b31d1ace71bca8ef58d315b", "63ed5a272de2f6d968408b4acb9024f4cc208ebf", "6f6704e5a10332af6672e50b3d9754dc460dfa4d", "77ca7b50b6cd7e2f3fa008e24ab793fd56cb15f6", "492ea3bb0f3315521c31f273e565b868fc090f17", "0ff30d6de14a8224aa97b78aea5388d1c51c1f00", "9ea779f907f0b315b364b0cfc39a0fde5b02a416", "ceaeb481747ca6c540a000c1f3641f8cef161fa7", "cc34673c6c40e791051898567a1222daf90be287", "579a80d909f346fbfb1189493f521d7f48d52238", "e308bd1ac5fda103967359b2712dd89deffb7973", "4cb31628079fb14e4bc3cd5e30c2f7489b00960c", "ac1ecab32727358dba8962a0f3b261731aad9723", "4fd6ace747f06ece9c49699c7cabc62d02211f75", "440c59b325d2997a134c2c7c60a8c61611212bad", "4486a3d68fac6967006d7a517b889fd3f98c102b", "9c15b54878ba618f494b38f0ae7443db6af648ba", "27b137a85656544b1ccb5a0f2e561a5703c6a68f", "21c7fdb9ed8d291d79ffd82eb2c4356ec0d81241", "23b75c2f6791eef49c69684db4c6c1f93bf49a50", "1ca6abd14d30affe533b24d7a21bff4c2d5e1f3b", "b9637156d330c0d605a791f1c31ba5890582fe1c", "6131c42fa982e56929107413a9d526fd99405560", "1591fc0f688c81fbeb17f5426a162a7024d430c2", "542a9515200d14b68e934e9830d91645a980dd7a", "c4bbd073882dd2add2424cf47d35213405b01324", "782495b7b3355efb2833d56ecb34dc22ad7dfcc4", "58b95c9a9d5d26825e70a82b6adb139d3fd829eb", "3ba4d81db016dc2890c81f3acec2454bff5aada5", "b52042c8ca3f8aa246fa79c3feaa3d959347c0ab", "e4ae1efdfc53b73893af49113d8694a057b9c0d1", "3c02a7bc0391e86d91b7d144e61c2c01a25a79c5", "0737a6b837f97f46ebade41b9bc3e1c509c85c53", "97f43a37f595ab5dd318fb46e7a155eae057317a", "52c5317c848ba20c7504cb2c8052abd1fde29d03", "4863226780fe7c0356454236d3b1c8792785748d", "5d2b2e6fcbe3b11d26b525e085ff818dae332479", "5f9f3392e9f62f63b8eac0beb55541fc8627f42c", "057b56736d32b86616a10f619859c6cd6f59092a", "9aa008f65de0b923a2a4f02012ad034a5e2e2192", "304a554a310c7e546dfe434669c62820b7d83490", "914d1b8b43e92723e64fd0a06f5bdb8dd9b10c79", "4deb0033bb26bc534b197e61d19e0733e5679784", "07f5c1e1bc2c93e0402f23341973a0e043f7bf8a", "35a051a0010aba705c9008d7a7eff6fb88f6ea7b", "4fa802324e929786dbda3b8820dc7834e9134a2a", "9da397b9e80755301a3b32173283a91c0ef6c87e", "8d9edb3054ce5c5774a420ac37ebae0ac02343c6", "0101f3be8ebb4bbd39a2e3b9a3639d4259832fd9", "5dc28b15dffed94048d73806ce4b7a4612a1d48f", "bcf899e6c7d9d5a215ab1e3444c86806fa854c76", "12e626b0eebfe86a56d633b9864e389b45dcb260", "a2f1ccba9395d7fcb155bba8bc92db9bafaeade7", "ec8e57756626fdc07c63ad2eafbd28d08e7b0ca5", "d164b088bd9108b60d0ca3751da4bceb207b0782", "6231b6d0d5e77fe001c2a460bd9584fee60d409b", "1cba23d343a983e9b5cfd19496b9a9701ada385f", "a82f360a8d3455c5c41366975bde739c37bfeb8a", "9fcd2deaff372a39cc679d5c5e4de7bafb0b1339", "005f5cee7a43331d5a3d3eec71305925a62f34b6", "0e0da70933f4c7849fc0d203f5d1d43b9ae4532d", "d131637d5275fd1a68a3200f4ad25c71a2a9522e", "bc07118b9ac290e4622f5e77a0853539789effbe", "47e7aa56d6bdf3f36be34619660de61275420af8", "acd87e28b0c9d1254e868b81cba4cc20d9a32225", "adf80daec7ba8dcf15392f1ac611fff65d94f880", "5524c55fb03cf21f549444ccbecb664d0acad706", "40b803a9abce16f50f36a77ba41180eb90023925", "fe24cdd8648121a43a7c86d289be4dd2951ed49f", "17802f43a0137c506ba92291391a8a8f207f487d", "253488078a4edf4d6f42f113d1e62836a942cf1a", "86af3e9626fce1957c82e88cbf04ddf3a2ed7915", "b136707642a4ea12fb4bae820f03d2562ebff487", "dbe9b615a3ae8709af8b93336ce9b477e4ac0940", "f14c14075d6c4ed84b86798af0956deef67365b5", "ca544e5c4687d109611d0f8f928b53a25af72448", "aeeb8ff27288bdabc0fa5ebb731b6f409507516c", "cbb9d3703e651b0d496cdefb8b92c25aeb2171f7", "6d87578288b6cb5549d5076a207456a1f6a63dc0", "b2c6f0dfbb716ac562e2d85d6cb2f8d5ee87603e", "accc230e8a6e5be9160b8cdf2864dd2a001c28b6", "2b3455ec7fedf16e646268bf88846bd7a2319bb2", "4613f3bca5c44ea06337a9e439fbc6d42e501d0a", "d343b217de44030afaa275f54d31a9317c7f441e", "84ef4b2357079cd7a7c69fd7a37cd0609a679106", "da2fef9e4a3230988ff17df2165440f37e8b1708", "f4c64518ea10f995918a454158c6b61407ea345c", "7602b46df5390e432ef1c307d4f2c9ff6d65cc97", "bb9bc244d798123fde783fcc1c72d3bb8c189413", "807640a13483f8ac783c557fcdf27be11ea4ac7a"];
    readonly DAORefundContract: "bf4ed7b27f1d666546e30d74d50d173d20bca754";
};

declare function deepCopy(baseVm: BaseVm): DeepCopy;
type DeepCopyError = MisconfiguredClientError;
type DeepCopy = () => Promise<BaseVm>;

declare function execHardfork(hardfork: _tevm_common.Hardfork | string, preMergeHf: _tevm_common.Hardfork | string): string | _tevm_common.Hardfork;

/**
 * Returns the tx receipt.
 * @param this The vm instance
 * @param tx The transaction
 * @param txResult The tx result
 * @param cumulativeGasUsed The gas used in the block including this tx
 * @param blobGasUsed The blob gas used in the tx
 * @param blobGasPrice The blob gas price for the block including this tx
 */
declare const generateTxReceipt: (vm: BaseVm) => (tx: TypedTransaction, txResult: RunTxResult, cumulativeGasUsed: bigint, blobGasUsed?: bigint, blobGasPrice?: bigint) => Promise<TxReceipt>;

/**
 * Generate the transaction trie for a block.
 * This is an intermediate step for computing the block header's
 * transaction root.
 * @param block - The block to generate the transaction trie for
 * @returns The transaction trie root
 */
declare function genTxTrie(block: Block): Promise<Uint8Array<ArrayBufferLike>>;

declare const parentBeaconBlockRootAddress: _tevm_utils.EthjsAddress;

declare function rewardAccount(evm: Evm, address: EthjsAddress, reward: bigint): Promise<EthjsAccount>;

type RunBlock = (opts: RunBlockOpts) => Promise<RunBlockResult>;
/**
 * @ignore
 */
declare const runBlock: (vm: BaseVm) => RunBlock;

type RunTx = (opts: RunTxOpts) => Promise<RunTxResult>;
/**
 * @ignore
 */
declare const runTx: (vm: BaseVm) => RunTx;

/**
 * @internal
 * Creates a bloom filter from the logs.
 * @param {any[] | undefined} logs - The logs to create the bloom filter from.
 * @param {import('@tevm/common').Common} common - The common object.')}
 * @returns {Bloom}
 * @throws {never}
 */
declare function txLogsBloom(logs: any[] | undefined, common: _tevm_common.Common): Bloom;

declare function validateRunTx(vm: BaseVm): (opts: RunTxOpts) => Promise<{
    block: Block;
    preserveJournal: boolean;
    tx: _tevm_tx.TypedTransaction;
    skipNonce?: boolean;
    skipBalance?: boolean;
    skipBlockGasLimitValidation?: boolean;
    skipHardForkValidation?: boolean;
    reportAccessList?: boolean;
    reportPreimages?: boolean;
    blockGasUsed?: bigint;
}>;

declare function warmAddresses2929(vm: BaseVm, caller: _tevm_utils.EthjsAddress, to: _tevm_utils.EthjsAddress | undefined, coinbase: _tevm_utils.EthjsAddress): void;

type CreateVmOptions = {
    stateManager: StateManager;
    evm: EvmType;
    blockchain: Chain;
    common: Common;
};

type Vm = BaseVm & {
    deepCopy: () => Promise<Vm>;
    buildBlock: BuildBlock;
    runBlock: RunBlock;
    runTx: RunTx;
};

/**
 * Options for instantiating a {@link VM}.
 */
interface VmOpts {
    /**
     * Use a {@link Common} instance
     * if you want to change the chain setup.
     *
     * ### Possible Values
     *
     * - `chain`: all chains supported by `Common` or a custom chain
     * - `hardfork`: `mainnet` hardforks up to the `Paris` hardfork
     * - `eips`: `1559` (usage e.g. `eips: [ 1559, ]`)
     *
     * Note: check the associated `@ethereumjs/evm` instance options
     * documentation for supported EIPs.
     */
    common: Common;
    /**
     * A {@link StateManager} instance to use as the state store
     */
    stateManager: StateManager;
    /**
     * A {@link Blockchain} object for storing/retrieving blocks
     */
    blockchain: Chain;
    evm: EvmType;
    /**
     * If true, create entries in the state tree for the precompiled contracts, saving some gas the
     * first time each of them is called.
     *
     * If this parameter is false, each call to each of them has to pay an extra 25000 gas
     * for creating the account. If the account is still empty after this call, it will be deleted,
     * such that this extra cost has to be paid again.
     *
     * Setting this to true has the effect of precompiled contracts' gas costs matching mainnet's from
     * the very first call, which is intended for testing networks.
     *
     * Default: `false`
     */
    activatePrecompiles?: boolean;
}

declare function createVm(opts: VmOpts): Vm;

export { type AddTransactionError, type AfterBlockEvent, type AfterTxEvent, type ApplyBlockResult, type BaseTxReceipt, BlockBuilder, type BlockStatus, type BuildBlock, type BuildBlockOpts, BuildStatus, type BuilderOpts, type CreateVmOptions, DAOConfig, type DeepCopy, type DeepCopyError, type EIP4844BlobTxReceipt, type EVMProfilerOpts, KECCAK256_NULL, type PostByzantiumTxReceipt, type PreByzantiumTxReceipt, type RunBlock, type RunBlockOpts, type RunBlockResult, type RunTx, type RunTxOpts, type RunTxResult, type SealBlockOpts, type TxReceipt, type VMEvents, type VMOpts, type VMProfilerOpts, type Vm, accumulateParentBeaconBlockRoot, accumulateParentBlockHash, applyBlock, applyDAOHardfork, applyTransactions, assignBlockRewards, assignWithdrawals, buildBlock, calculateMinerReward, calculateOmmerReward, createVm, deepCopy, execHardfork, genTxTrie, generateTxReceipt, parentBeaconBlockRootAddress, rewardAccount, runBlock, runTx, txLogsBloom, validateRunTx, warmAddresses2929 };
