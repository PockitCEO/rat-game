import { StorageCache, CacheType, AccountCache } from '@ethereumjs/statemanager';
export { AccountCache, CacheType, StorageCache } from '@ethereumjs/statemanager';
import { bytesToHex, createPublicClient, createTransport, hexToBytes, numberToHex, keccak256, toHex as toHex$1 } from 'viem';
import { createAddress } from '@tevm/address';
import { toBytes, getAddress, bytesToHex as bytesToHex$1, toHex, bytesToUnprefixedHex, createAccount, hexToBytes as hexToBytes$1, isHex, hexToBigInt, keccak256 as keccak256$1 } from '@tevm/utils';
import { Rlp } from '@tevm/rlp';
import { InternalError, InvalidParamsError } from '@tevm/errors';
import { createLogger } from '@tevm/logger';
import { hexToBytes as hexToBytes$2 } from 'ethereum-cryptography/utils';

// src/index.ts

// src/actions/checkpoint.js
var checkpoint = (baseState) => () => {
  baseState.caches.accounts.checkpoint();
  baseState.caches.storage.checkpoint();
  baseState.caches.contracts.checkpoint();
  baseState.logger.debug("checkpointed state!");
  return Promise.resolve();
};

// src/actions/clearCaches.js
var clearCaches = (baseState) => () => {
  baseState.caches.storage.clear();
  baseState.caches.contracts.clear();
  baseState.caches.accounts.clear();
  baseState.logger.debug("State manager cleared.");
};

// src/actions/clearContractStorage.js
var clearContractStorage = (baseState) => (address) => {
  baseState.caches.storage.clearStorage(address);
  baseState.logger.debug({ address: address.toString() }, "State manager cleared storage at address.");
  return Promise.resolve();
};
function fromRlpSerializedAccount(serialized) {
  const decoded = Rlp.decode(serialized);
  if (!Array.isArray(decoded) || decoded.length !== 4) {
    throw new Error("Invalid RLP serialized account");
  }
  const [nonce, balance, storageRoot, codeHash] = decoded;
  const accountData = {
    nonce,
    balance,
    storageRoot,
    codeHash
  };
  return createAccount(accountData);
}
function fromAccountData(accountData) {
  return createAccount(accountData);
}
var dumpStorage = (vm) => (address) => {
  const {
    caches: { storage }
  } = vm;
  const storageMap = storage.dump(address);
  const dump = {};
  if (storageMap !== void 0) {
    for (const slot of storageMap) {
      dump[slot[0]] = bytesToHex(slot[1]);
    }
  }
  return Promise.resolve(dump);
};

// src/actions/getForkBlockTag.js
var getForkBlockTag = ({ options: { fork } }) => {
  if (!fork) {
    return void 0;
  }
  if (fork.blockTag === void 0) {
    return { blockTag: "latest" };
  }
  if (typeof fork.blockTag === "bigint") {
    return { blockNumber: fork.blockTag };
  }
  return { blockTag: fork.blockTag };
};
var NoForkError = class extends Error {
  /**
   * @override
   * @type {'NoForkError'}
   */
  name = "NoForkError";
  /**
   * @type {'NoForkError'}
   */
  _tag = "NoForkError";
};
var getForkClient = ({ options: { fork } }) => {
  if (!fork) {
    throw new NoForkError("Cannot initialize a client with no fork url set");
  }
  return createPublicClient({
    name: "TevmStateManagerForkClient",
    transport: () => createTransport({
      type: "tevm",
      key: "tevm",
      name: "TevmStateManagerForkClientTransport",
      request: typeof fork.transport === "function" ? fork.transport({}).request : fork.transport.request
    })
  });
};

// src/actions/getAccountFromProvider.js
var getAccountFromProvider = (baseState) => async (address) => {
  const client = getForkClient(baseState);
  const blockTag = getForkBlockTag(baseState);
  const accountData = await client.getProof({
    address: (
      /** @type {import('@tevm/utils').Address}*/
      address.toString()
    ),
    storageKeys: [],
    ...blockTag
  });
  const account = fromAccountData({
    balance: BigInt(accountData.balance),
    nonce: BigInt(accountData.nonce),
    codeHash: toBytes(accountData.codeHash),
    storageRoot: toBytes(accountData.storageHash)
  });
  return account;
};

// src/actions/getAccount.js
var getAccount = (baseState, skipFetchingFromFork = false) => async (address) => {
  const {
    caches: { accounts },
    forkCache: { accounts: forkAccounts }
  } = baseState;
  const elem = accounts.get(address);
  if (elem !== void 0) {
    return elem.accountRLP !== void 0 ? fromRlpSerializedAccount(elem.accountRLP) : void 0;
  }
  if (baseState.options.fork?.transport) {
    const forkElem = forkAccounts.get(address);
    if (forkElem !== void 0) {
      if (forkElem.accountRLP !== void 0) {
        const account2 = fromRlpSerializedAccount(forkElem.accountRLP);
        accounts.put(address, account2);
        baseState.logger.debug({ address }, "Retrieved account from fork cache");
        return account2;
      }
      accounts.put(address, void 0);
      baseState.logger.debug({ address }, "Retrieved empty account from fork cache");
      return void 0;
    }
  }
  if (!baseState.options.fork?.transport) {
    return void 0;
  }
  if (skipFetchingFromFork) {
    return void 0;
  }
  baseState.logger.debug({ address }, "fetching account from remote RPC");
  const account = await getAccountFromProvider(baseState)(address);
  if (account.nonce === 0n && account.balance === 0n && account.codeHash.every((d) => d === 0) && account.storageRoot.every((d) => d === 0)) {
    accounts.put(address, void 0);
    forkAccounts.put(address, void 0);
    return void 0;
  }
  accounts.put(address, account);
  forkAccounts.put(address, account);
  baseState.logger.debug({ address, account }, "Cached forked account in state manager and fork cache");
  return account;
};
var getAccountAddresses = (baseState) => () => {
  const accountAddresses = /* @__PURE__ */ new Set();
  baseState.caches.accounts._orderedMapCache?.forEach((e) => {
    accountAddresses.add(getAddress(e[0].startsWith("0x") ? e[0] : `0x${e[0]}`));
  });
  const { _lruCache, _orderedMapCache } = baseState.caches.accounts;
  if (_lruCache !== void 0) {
    for (const address of _lruCache.rkeys()) {
      accountAddresses.add(getAddress(address.startsWith("0x") ? address : `0x${address}`));
    }
  }
  if (_orderedMapCache !== void 0) {
    _orderedMapCache.forEach(([address]) => {
      accountAddresses.add(getAddress(address.startsWith("0x") ? address : `0x${address}`));
    });
  }
  return accountAddresses;
};
var EMPTY_CODE = Object.freeze(new Uint8Array());
var getContractCode = (baseState, skipFetchingFromFork = false) => async (address) => {
  const {
    options,
    caches: { contracts },
    forkCache: { contracts: forkContracts }
  } = baseState;
  const codeBytes = contracts.get(address);
  if (codeBytes !== void 0) {
    return codeBytes;
  }
  if (options.fork?.transport) {
    const forkCodeBytes = forkContracts.get(address);
    if (forkCodeBytes !== void 0) {
      contracts.put(address, forkCodeBytes);
      baseState.logger.debug({ address }, "Retrieved contract code from fork cache");
      return forkCodeBytes;
    }
  }
  if (!options.fork?.transport) {
    return EMPTY_CODE;
  }
  if (skipFetchingFromFork) {
    return EMPTY_CODE;
  }
  baseState.logger.debug({ address }, "Fetching contract code from remote RPC...");
  const client = getForkClient(baseState);
  const blockTag = getForkBlockTag(baseState);
  if (contracts.has(address)) {
    return EMPTY_CODE;
  }
  const remoteCode = await client.getBytecode({
    address: (
      /** @type {import('@tevm/utils').Address}*/
      address.toString()
    ),
    ...blockTag
  });
  if (!remoteCode) {
    baseState.logger.debug({ address }, "No remote code found");
    contracts.put(address, EMPTY_CODE);
    forkContracts.put(address, EMPTY_CODE);
    return EMPTY_CODE;
  }
  const remoteCodeBytes = hexToBytes(remoteCode);
  contracts.put(address, remoteCodeBytes);
  forkContracts.put(address, remoteCodeBytes);
  baseState.logger.debug(
    { address, deployedBytecode: bytesToHex$1(remoteCodeBytes) },
    "Cached forked contract bytecode to state and fork cache"
  );
  return remoteCodeBytes;
};

// src/actions/dumpCannonicalGenesis.js
var dumpCanonicalGenesis = (baseState) => async () => {
  const accountAddresses = getAccountAddresses(baseState)();
  const state = {};
  for (const address of accountAddresses) {
    const hexAddress = getAddress(address.startsWith("0x") ? address : `0x${address}`);
    const ethAddress = createAddress(hexAddress);
    const account = await getAccount(baseState, true)(ethAddress) ?? fromAccountData({});
    const storage = await dumpStorage(baseState)(ethAddress);
    const deployedBytecode = await getContractCode(baseState, true)(ethAddress);
    const dump = {
      nonce: account.nonce,
      balance: account.balance,
      storageRoot: bytesToHex$1(account.storageRoot),
      codeHash: bytesToHex$1(account.codeHash),
      storage,
      ...baseState.caches.contracts.has(ethAddress) ? { deployedBytecode: toHex(deployedBytecode) } : {}
    };
    baseState.logger.debug({ address: hexAddress, ...dump }, "dumping address");
    state[hexAddress] = dump;
  }
  return state;
};

// src/actions/commit.js
var commit = (baseState) => async (createNewStateRoot = false) => {
  const state = await dumpCanonicalGenesis(baseState)();
  const newStateRoot = (() => {
    if (!createNewStateRoot) {
      baseState.logger.debug("Comitting to existing state root...");
      return baseState.getCurrentStateRoot();
    }
    const jsonSerializableState = {};
    for (const [k, v] of Object.entries(state)) {
      const { nonce, balance, storageRoot, codeHash, deployedBytecode } = v;
      jsonSerializableState[k] = {
        ...v,
        nonce: numberToHex(nonce),
        balance: numberToHex(balance),
        storageRoot,
        codeHash,
        ...deployedBytecode !== void 0 ? { deployedBytecode } : {}
      };
    }
    const root = keccak256(toHex$1(JSON.stringify(jsonSerializableState)));
    baseState.logger.debug({ root }, "Committing to new state root...");
    return root;
  })();
  baseState.stateRoots.set(newStateRoot, state);
  baseState.logger.debug({ stateRoot: newStateRoot }, "Saving state roots...");
  baseState.setCurrentStateRoot(newStateRoot);
  baseState.caches.accounts.commit();
  baseState.caches.contracts.commit();
  baseState.caches.storage.commit();
  baseState.logger.debug("State roots are comitted successfully");
  baseState.options.onCommit?.(baseState);
  return;
};
var oneBytes = Uint8Array.from([1]);
var ContractCache = class {
  constructor(storageCache = new StorageCache({
    size: 1e5,
    type: CacheType.LRU
  })) {
    this.storageCache = storageCache;
  }
  /**
   * @returns {void}
   */
  commit() {
    this.storageCache.commit();
  }
  /**
   * @returns {void}
   */
  clear() {
    this.storageCache.clear();
  }
  /**
   * @param {import('@tevm/utils').EthjsAddress} address
   * @returns {Uint8Array | undefined}
   */
  get(address) {
    return this.storageCache.get(address, oneBytes);
  }
  /**
   * @param {import('@tevm/utils').EthjsAddress} address
   * @param {Uint8Array} bytecode
   * @returns {void}
   */
  put(address, bytecode) {
    this.storageCache.put(address, oneBytes, bytecode);
  }
  /**
   * @param {import('@tevm/utils').EthjsAddress} address
   * @returns {void}
   */
  del(address) {
    this.storageCache.del(address, oneBytes);
  }
  /**
   * @returns {void}
   */
  checkpoint() {
    this.storageCache.checkpoint();
  }
  /**
   * @param {import('@tevm/utils').EthjsAddress} address
   * @returns {boolean} if the cache has the key
   */
  has(address) {
    const storageMap = this.storageCache._orderedMapCache?.getElementByKey(bytesToUnprefixedHex(address.bytes));
    const hasOrderedMapCache = storageMap?.has(bytesToUnprefixedHex(oneBytes)) ?? false;
    const hasLruCache = this.storageCache._lruCache?.has(bytesToUnprefixedHex(address.bytes));
    return Boolean(hasOrderedMapCache || hasLruCache);
  }
  get _checkpoints() {
    return this.storageCache._checkpoints;
  }
  size() {
    return this.storageCache.size();
  }
  /**
   * @returns {void}
   */
  revert() {
    this.storageCache.revert();
  }
};
var stripZeros = (bytes) => {
  if (!(bytes instanceof Uint8Array)) {
    throw new InternalError("Unexpected type");
  }
  return bytes.slice(bytes.findIndex(
    /** @param {number} entry*/
    (entry) => entry !== 0
  ));
};

// src/actions/putContractStorage.js
var putContractStorage = (baseState) => async (address, key, value) => {
  if (key.length !== 32) {
    throw new InternalError(`Storage key must be 32 bytes long. Received ${key}`);
  }
  const account = await getAccount(baseState)(address);
  if (!account) {
    throw new InternalError(
      "cannot putContractStorage on non existing acccount! Consider checking if account exists first"
    );
  }
  baseState.caches.storage.put(address, key, stripZeros(value));
};

// src/actions/generateCannonicalGenesis.js
var generateCanonicalGenesis = (baseState) => async (state) => {
  if (baseState.caches.accounts._checkpoints > 0 || baseState.caches.storage._checkpoints > 0 || baseState.caches.contracts._checkpoints > 0) {
    throw new InternalError("Attempted to generateCanonicalGenesis state with uncommitted checkpoints");
  }
  const { caches: oldCaches } = baseState;
  baseState.caches = {
    contracts: new ContractCache(),
    accounts: new AccountCache({
      size: 1e5,
      type: CacheType.LRU
    }),
    storage: new StorageCache({
      size: 1e5,
      type: CacheType.LRU
    })
  };
  try {
    for (const [k, v] of Object.entries(
      /** @type {import('../state-types/TevmState.js').TevmState}*/
      state
    )) {
      const { nonce, balance, storageRoot, codeHash, storage, deployedBytecode } = v;
      const account = createAccount({
        nonce,
        balance,
        storageRoot: hexToBytes$1(storageRoot, { size: 32 }),
        codeHash: hexToBytes$1(codeHash, { size: 32 })
      });
      const address = createAddress(k);
      baseState.caches.accounts?.put(address, account);
      if (deployedBytecode) {
        baseState.caches.contracts.put(address, hexToBytes$1(deployedBytecode));
      }
      if (storage !== void 0) {
        for (const [storageKey, storageData] of Object.entries(storage)) {
          const key = hexToBytes$1(isHex(storageKey) ? storageKey : `0x${storageKey}`);
          const data = (
            /** @type {Uint8Array}*/
            hexToBytes$1(isHex(storageData) ? storageData : `0x${storageData}`)
          );
          await putContractStorage(baseState)(address, key, data);
        }
      }
    }
  } catch (e) {
    baseState.logger.debug(state);
    baseState.logger.error(e, "There was an error generating cannonical genesis. Reverting back to old state");
    baseState.caches = oldCaches;
    throw e;
  }
};

// src/createBaseState.js
var INITIAL_STATE_ROOT = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
var createBaseState = (options) => {
  const logger = createLogger({
    level: options.loggingLevel ?? "warn",
    name: "@tevm/state-manager"
  });
  const stateRoots = options.stateRoots ?? /* @__PURE__ */ new Map();
  if (options.genesisState && options.currentStateRoot) {
    stateRoots.set(options.currentStateRoot, options.genesisState);
  } else {
    stateRoots.set(INITIAL_STATE_ROOT, options.genesisState ?? {});
  }
  let currentStateRoot = options.currentStateRoot ?? INITIAL_STATE_ROOT;
  const state = {
    logger,
    getCurrentStateRoot: () => currentStateRoot,
    setCurrentStateRoot: (root) => {
      if (!state.stateRoots.has(root)) {
        throw new InternalError("Cannot set state root to non existing state root");
      }
      currentStateRoot = root;
    },
    stateRoots,
    options,
    caches: {
      contracts: options.contractCache ?? new ContractCache(new StorageCache({ size: 1e5, type: CacheType.LRU })),
      accounts: options.accountsCache ?? new AccountCache({
        size: 1e5,
        type: CacheType.LRU
      }),
      storage: options.storageCache ?? new StorageCache({
        size: 1e5,
        type: CacheType.LRU
      })
    },
    forkCache: {
      contracts: options.contractCache ?? new ContractCache(new StorageCache({ size: 1e5, type: CacheType.LRU })),
      accounts: options.accountsCache ?? new AccountCache({
        size: 1e5,
        type: CacheType.LRU
      }),
      storage: options.storageCache ?? new StorageCache({
        size: 1e5,
        type: CacheType.LRU
      })
    },
    ready: () => genesisPromise.then(() => true)
  };
  const genesisPromise = (options.genesisState !== void 0 && options.currentStateRoot === void 0 ? (async () => {
    const fn = generateCanonicalGenesis(state);
    if (fn && options.genesisState) {
      return fn(options.genesisState);
    }
  })() : Promise.resolve().then(() => {
    if (options.currentStateRoot) {
      state.setCurrentStateRoot(options.currentStateRoot);
      const fn = generateCanonicalGenesis(state);
      const genesis = options.genesisState ?? stateRoots.get(options.currentStateRoot);
      if (fn && genesis) {
        return fn(genesis);
      }
    }
    return Promise.resolve();
  })).then(async () => {
    await checkpoint(state)();
    await commit(state)();
    logger.debug("StateManager is ready");
  });
  return state;
};

// src/actions/deepCopy.js
var deepCopy = (baseState) => async () => {
  await baseState.ready();
  if (baseState.caches.accounts._checkpoints > 0 || baseState.caches.storage._checkpoints > 0 || baseState.caches.contracts._checkpoints > 0) {
    throw new InternalError("Attempted to deepCopy state with uncommitted checkpoints");
  }
  const newState = createBaseState({
    ...baseState.options,
    genesisState: await dumpCanonicalGenesis(baseState)(),
    stateRoots: new Map(baseState.stateRoots),
    currentStateRoot: baseState.getCurrentStateRoot()
  });
  await newState.ready();
  if (baseState.forkCache) {
    newState.forkCache = baseState.forkCache;
    baseState.logger.debug("Sharing fork cache reference between original and copied state");
  }
  baseState.logger.debug("Successfully deepCopy'd StateManager with shared fork cache");
  return newState;
};

// src/actions/deleteAccount.js
var deleteAccount = (baseState) => async (address) => {
  await baseState.ready();
  baseState.caches.accounts.del(address);
  baseState.logger.debug({ address }, "Deleted account");
  return;
};
var dumpStorageRange = (state) => (_address, _startKey, _limit) => {
  const storage = state.caches.storage.dump(_address);
  if (!storage) {
    throw new InvalidParamsError(`No storage found at address ${getAddress(_address.toString())}`);
  }
  const entries = [];
  let nextKey = null;
  let started = false;
  for (const [storageKey, storageValue] of storage.entries()) {
    if (entries.length === _limit) {
      nextKey = /** @type {import("@tevm/utils").Hex}*/
      storageKey;
      break;
    }
    if (!started) {
      if (hexToBigInt(
        /** @type {import('@tevm/utils').Hex}*/
        storageKey
      ) === _startKey) {
        started = true;
      } else {
        continue;
      }
    }
    const key = (
      /** @type {import("@tevm/utils").Hex}*/
      storageKey
    );
    const value = bytesToHex$1(storageValue);
    entries.push([key, { key, value }]);
  }
  return Promise.resolve({
    nextKey,
    storage: Object.fromEntries(entries)
  });
};
var getAppliedKey = () => (address) => {
  return keccak256(address, "bytes");
};
var getContractStorage = (baseState) => async (address, key) => {
  const {
    caches: { storage: storageCache },
    forkCache: { storage: forkStorageCache }
  } = baseState;
  if (key.length !== 32) {
    throw new InternalError(
      `Storage key must be 32 bytes long. Received ${key.length}. If using numberToHex make the length 32.`
    );
  }
  const cachedValue = storageCache.get(address, key);
  if (cachedValue !== void 0) {
    return cachedValue;
  }
  if (baseState.options.fork?.transport) {
    const forkedValue = forkStorageCache.get(address, key);
    if (forkedValue !== void 0) {
      await putContractStorage(baseState)(address, key, forkedValue);
      baseState.logger.debug({ address, key, forkedValue }, "Retrieved storage from fork cache");
      return forkedValue;
    }
  }
  const isContractAtAddress = (await getAccount(baseState)(address))?.isContract();
  if (!isContractAtAddress) {
    baseState.logger.debug(`No contract found at address ${address}. Cannot getContractStorage if there is no contract`);
    return hexToBytes("0x0");
  }
  if (!baseState.options.fork?.transport) {
    return hexToBytes("0x0");
  }
  baseState.logger.debug({ address, key }, "Fetching storage from remote RPC");
  const client = getForkClient(baseState);
  const blockTag = getForkBlockTag(baseState);
  const storage = await client.getStorageAt({
    address: (
      /** @type {import('@tevm/utils').Address} */
      address.toString()
    ),
    slot: bytesToHex(key),
    ...blockTag
  });
  const value = hexToBytes(storage ?? "0x0");
  await putContractStorage(baseState)(address, key, value);
  forkStorageCache.put(address, key, value);
  baseState.logger.debug({ address, key, value }, "Cached forked storage to state and fork cache");
  return value;
};
var getProof = (baseState) => async (address, storageSlots = []) => {
  if (!baseState.options.fork?.transport) {
    throw new Error(
      "getProof only implemented in fork mode atm because tevm at this moment does not merkilize the state"
    );
  }
  const client = getForkClient(baseState);
  const blockTag = getForkBlockTag(baseState);
  const proof = await client.getProof({
    address: (
      /** @type {import('@tevm/utils').Address}*/
      address.toString()
    ),
    storageKeys: storageSlots.map((slot) => bytesToHex$1(slot)),
    ...blockTag
  });
  return {
    address: proof.address,
    accountProof: proof.accountProof,
    balance: toHex(proof.balance),
    codeHash: proof.codeHash,
    nonce: toHex(proof.nonce),
    storageHash: proof.storageHash,
    storageProof: proof.storageProof.map((p) => ({
      proof: p.proof,
      value: toHex(p.value),
      key: p.key
    }))
  };
};
var getStateRoot = (baseState) => async () => {
  return hexToBytes$2(baseState.getCurrentStateRoot());
};
var hasStateRoot = (baseState) => (root) => {
  return Promise.resolve(baseState.stateRoots.has(bytesToHex$1(root)));
};

// src/actions/putAccount.js
var putAccount = (baseState) => async (address, account) => {
  if (account !== void 0) {
    baseState.caches.accounts?.put(address, account);
  } else {
    baseState.caches.accounts?.del(address);
  }
};

// src/actions/modifyAccountFields.js
var modifyAccountFields = (baseState) => async (address, accountFields) => {
  const account = await getAccount(baseState)(address) ?? createAccount({});
  account.nonce = accountFields.nonce ?? account.nonce;
  account.balance = accountFields.balance ?? account.balance;
  account.storageRoot = accountFields.storageRoot ?? account.storageRoot;
  account.codeHash = accountFields.codeHash ?? account.codeHash;
  await putAccount(baseState)(address, account);
};
var originalStorageCache = (baseState) => {
  const state = /* @__PURE__ */ new Map();
  const put = (address, key, value) => {
    const addressHex = bytesToUnprefixedHex(address.bytes);
    let map = state.get(addressHex);
    if (map === void 0) {
      map = /* @__PURE__ */ new Map();
      state.set(addressHex, map);
    }
    const keyHex = bytesToUnprefixedHex(key);
    if (map.has(keyHex) === false) {
      map.set(keyHex, value);
    }
  };
  return {
    async get(address, key) {
      const addressHex = bytesToUnprefixedHex(address.bytes);
      const map = state.get(addressHex);
      if (map !== void 0) {
        const keyHex = bytesToUnprefixedHex(key);
        const value2 = map.get(keyHex);
        if (value2 !== void 0) {
          return value2;
        }
      }
      const value = await getContractStorage(baseState)(address, key);
      put(address, key, value);
      return value;
    },
    clear() {
    }
  };
};
var putContractCode = (baseState) => async (address, value) => {
  const account = await getAccount(baseState)(address);
  const accountData = {
    nonce: account?.nonce ?? 0n,
    balance: account?.balance ?? 0n,
    codeHash: keccak256$1(value, "bytes")
  };
  if (account?.storageRoot !== void 0) {
    accountData.storageRoot = account.storageRoot;
  }
  await putAccount(baseState)(address, createAccount(accountData));
  baseState.caches.contracts.put(address, value);
  return;
};

// src/actions/revert.js
var revert = (baseState) => () => {
  baseState.caches.accounts.revert();
  baseState.caches.storage.revert();
  baseState.caches.contracts.revert();
  baseState.logger.debug("State reverted");
  return Promise.resolve();
};
var NoStateRootExistsError = class extends Error {
  /**
   * @override
   * @type {'NoStateRootExistsError'}
   */
  name = "NoStateRootExistsError";
  /**
   * @type {'NoStateRootExistsError'}
   */
  _tag = "NoStateRootExistsError";
};
var setStateRoot = (baseState) => async (root) => {
  if (baseState.caches.accounts._checkpoints > 0 || baseState.caches.storage._checkpoints > 0 || baseState.caches.contracts._checkpoints > 0) {
    throw new Error("Attempted to setStateRoot with uncommitted checkpoints");
  }
  const genesis = baseState.stateRoots.get(bytesToHex(root));
  if (!genesis) {
    throw new NoStateRootExistsError(`State root for ${bytesToHex(root)} does not exist`);
  }
  const oldStateRoot = baseState.getCurrentStateRoot();
  try {
    baseState.setCurrentStateRoot(bytesToHex(root));
    const generateFn = generateCanonicalGenesis(baseState);
    if (generateFn) {
      await generateFn(genesis);
    }
    baseState.logger.debug({ oldStateRoot, newStateRoot: root }, "state root changed");
    return;
  } catch (e) {
    baseState.setCurrentStateRoot(oldStateRoot);
    throw e;
  }
};
var shallowCopy = (baseState) => () => {
  const newState = createBaseState(baseState.options);
  newState.caches.contracts = new ContractCache();
  newState.caches.storage = new StorageCache({
    size: 1e5,
    type: CacheType.LRU
  });
  newState.caches.accounts = new AccountCache({
    size: 1e5,
    type: CacheType.LRU
  });
  if (baseState.forkCache) {
    newState.forkCache = baseState.forkCache;
    baseState.logger.debug("Sharing fork cache reference between original and shallow copied state");
  }
  return newState;
};
var saveStateRoot = (baseState) => (root, value) => {
  baseState.stateRoots.set(bytesToHex$1(root), value);
  baseState.logger.debug({ root: bytesToHex$1(root), value }, "Saved state root");
};

// src/createStateManager.js
var createStateManager = (options) => {
  return decorate(createBaseState(options));
};
var decorate = (state) => {
  const wrappedState = {
    ready: state.ready,
    _baseState: state,
    deepCopy: async () => {
      return decorate(await deepCopy(state)());
    },
    shallowCopy: () => {
      return decorate(shallowCopy(state)());
    },
    dumpCanonicalGenesis: () => dumpCanonicalGenesis(state)(),
    generateCanonicalGenesis: generateCanonicalGenesis(state),
    putAccount: putAccount(state),
    clearCaches: clearCaches(state),
    commit: commit(state),
    checkpoint: checkpoint(state),
    revert: revert(state),
    getProof: getProof(state),
    getCode: getContractCode(state),
    getCodeSize: (address) => getContractCode(state)(address).then((code) => code.length),
    getAccount: getAccount(state),
    dumpStorage: dumpStorage(state),
    getStateRoot: getStateRoot(state),
    hasStateRoot: hasStateRoot(state),
    setStateRoot: setStateRoot(state),
    saveStateRoot: saveStateRoot(state),
    deleteAccount: deleteAccount(state),
    putCode: putContractCode(state),
    dumpStorageRange: dumpStorageRange(state),
    getStorage: getContractStorage(state),
    putStorage: putContractStorage(state),
    clearStorage: clearContractStorage(state),
    modifyAccountFields: modifyAccountFields(state),
    clearContractStorage: clearContractStorage(state),
    getAccountAddresses: getAccountAddresses(state),
    // Unused provided to fulfill interface
    getAppliedKey: (
      /** @type {any}*/
      getAppliedKey()
    ),
    originalStorageCache: originalStorageCache(state)
  };
  return wrappedState;
};

export { ContractCache, checkpoint, clearCaches, clearContractStorage, commit, createBaseState, createStateManager, deepCopy, deleteAccount, dumpCanonicalGenesis, dumpStorage, dumpStorageRange, generateCanonicalGenesis, getAccount, getAccountAddresses, getAccountFromProvider, getAppliedKey, getContractCode, getContractStorage, getForkBlockTag, getForkClient, getProof, getStateRoot, hasStateRoot, modifyAccountFields, originalStorageCache, putAccount, putContractCode, putContractStorage, revert, setStateRoot, shallowCopy };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map