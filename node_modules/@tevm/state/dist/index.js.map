{"version":3,"sources":["../src/actions/checkpoint.js","../src/actions/clearCaches.js","../src/actions/clearContractStorage.js","../src/utils/accountHelpers.js","../src/actions/dumpStorage.js","../src/actions/getForkBlockTag.js","../src/actions/getForkClient.js","../src/actions/getAccountFromProvider.js","../src/actions/getAccount.js","../src/actions/getAccountAddresses.js","../src/actions/getContractCode.js","../src/actions/dumpCannonicalGenesis.js","../src/actions/commit.js","../src/ContractCache.js","../src/utils/stripZeros.js","../src/actions/putContractStorage.js","../src/actions/generateCannonicalGenesis.js","../src/createBaseState.js","../src/actions/deepCopy.js","../src/actions/deleteAccount.js","../src/actions/dumpStorageRange.js","../src/actions/getAppliedKey.js","../src/actions/getContractStorage.js","../src/actions/getProof.js","../src/actions/getStateRoot.js","../src/actions/hasStateRoot.js","../src/actions/putAccount.js","../src/actions/modifyAccountFields.js","../src/actions/originalStorageCache.js","../src/actions/putContractCode.js","../src/actions/revert.js","../src/actions/setStateRoot.js","../src/actions/shallowCopy.js","../src/actions/saveStateRoot.js","../src/createStateManager.js"],"names":["account","bytesToHex","getAddress","createAddress","toHex","InternalError","CacheType","StorageCache","createAccount","hexToBytes","AccountCache","keccak256","bytesToUnprefixedHex","value"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Checkpoints the current change-set to the instance since the\n * last call to checkpoint.\n * @type {import(\"../state-types/index.js\").StateAction<'checkpoint'>}\n */\nexport const checkpoint = (baseState) => () => {\n\tbaseState.caches.accounts.checkpoint()\n\tbaseState.caches.storage.checkpoint()\n\tbaseState.caches.contracts.checkpoint()\n\tbaseState.logger.debug('checkpointed state!')\n\treturn Promise.resolve()\n}\n","/**\n * Resets all internal caches\n * @type {import(\"../state-types/index.js\").StateAction<'clearCaches'>}\n */\nexport const clearCaches = (baseState) => () => {\n\tbaseState.caches.storage.clear()\n\tbaseState.caches.contracts.clear()\n\tbaseState.caches.accounts.clear()\n\tbaseState.logger.debug('State manager cleared.')\n}\n","/**\n * Clears all storage entries for the account corresponding to `address`.\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {(address: import('@tevm/utils').EthjsAddress) => Promise<void>}\n */\nexport const clearContractStorage = (baseState) => (address) => {\n\t// Use the new clearStorage method from the updated StorageCache\n\tbaseState.caches.storage.clearStorage(address)\n\tbaseState.logger.debug({ address: address.toString() }, 'State manager cleared storage at address.')\n\treturn Promise.resolve()\n}\n","import { Rlp } from '@tevm/rlp'\nimport { createAccount, createAddressFromString as createAddress } from '@tevm/utils'\n\n/**\n * Helper to create an address from a string\n * @param {string} addressString - The address string\n * @returns {import('@tevm/utils').EthjsAddress} The address\n */\nexport function createAddressFromString(addressString) {\n\treturn createAddress(addressString)\n}\n\n/**\n * Creates an account from RLP serialized data\n * @param {Uint8Array} serialized - The RLP serialized account data\n * @returns {import('@tevm/utils').EthjsAccount} The account\n */\nexport function fromRlpSerializedAccount(serialized) {\n\tconst decoded = Rlp.decode(serialized)\n\tif (!Array.isArray(decoded) || decoded.length !== 4) {\n\t\tthrow new Error('Invalid RLP serialized account')\n\t}\n\n\tconst [nonce, balance, storageRoot, codeHash] = decoded\n\n\t/** @type {{nonce: any, balance: any, storageRoot: any, codeHash: any}} */\n\tconst accountData = {\n\t\tnonce,\n\t\tbalance,\n\t\tstorageRoot,\n\t\tcodeHash,\n\t}\n\n\treturn createAccount(accountData)\n}\n\n/**\n * Creates an account from account data\n * @param {{nonce?: bigint, balance?: bigint, storageRoot?: Uint8Array, codeHash?: Uint8Array}} accountData - The account data\n * @returns {import('@tevm/utils').EthjsAccount} The account\n */\nexport function fromAccountData(accountData) {\n\treturn createAccount(accountData)\n}\n","import { bytesToHex } from 'viem'\n\n/**\n * Dumps the RLP-encoded storage values for an `account` specified by `address`.\n * Keys are the storage keys, values are the storage values as strings.\n * Both are represented as `0x` prefixed hex strings.\n * @type {import(\"../state-types/index.js\").StateAction<'dumpStorage'>}\n */\nexport const dumpStorage = (vm) => (address) => {\n\tconst {\n\t\tcaches: { storage },\n\t} = vm\n\tconst storageMap = storage.dump(address)\n\t/**\n\t * @type {import(\"@tevm/common\").StorageDump}\n\t */\n\tconst dump = {}\n\tif (storageMap !== undefined) {\n\t\tfor (const slot of storageMap) {\n\t\t\tdump[slot[0]] = bytesToHex(slot[1])\n\t\t}\n\t}\n\treturn Promise.resolve(dump)\n}\n","/**\n * If this does not exist an empty `Uint8Array` is returned.\n * @param {import(\"../BaseState.js\").BaseState} baseState\n * @returns {undefined | {blockTag: import(\"viem\").BlockTag} | { blockNumber: bigint}}\n */\nexport const getForkBlockTag = ({ options: { fork } }) => {\n\tif (!fork) {\n\t\treturn undefined\n\t}\n\tif (fork.blockTag === undefined) {\n\t\treturn { blockTag: 'latest' }\n\t}\n\tif (typeof fork.blockTag === 'bigint') {\n\t\treturn { blockNumber: fork.blockTag }\n\t}\n\treturn { blockTag: fork.blockTag }\n}\n","import { createPublicClient, createTransport } from 'viem'\n\nexport class NoForkError extends Error {\n\t/**\n\t * @override\n\t * @type {'NoForkError'}\n\t */\n\tname = 'NoForkError'\n\t/**\n\t * @type {'NoForkError'}\n\t */\n\t_tag = 'NoForkError'\n}\n\n/**\n * Creates a viem public client for the fork\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {import('viem').PublicClient}\n */\nexport const getForkClient = ({ options: { fork } }) => {\n\tif (!fork) {\n\t\tthrow new NoForkError('Cannot initialize a client with no fork url set')\n\t}\n\treturn createPublicClient({\n\t\tname: 'TevmStateManagerForkClient',\n\t\ttransport: () =>\n\t\t\tcreateTransport({\n\t\t\t\ttype: 'tevm',\n\t\t\t\tkey: 'tevm',\n\t\t\t\tname: 'TevmStateManagerForkClientTransport',\n\t\t\t\trequest: typeof fork.transport === 'function' ? fork.transport({}).request : fork.transport.request,\n\t\t\t}),\n\t})\n}\n","import { toBytes } from '@tevm/utils'\nimport { fromAccountData } from '../utils/accountHelpers.js'\nimport { getForkBlockTag } from './getForkBlockTag.js'\nimport { getForkClient } from './getForkClient.js'\n\n/**\n * Retrieves an account from the provider and stores in the local trie\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {(address: import('@tevm/utils').EthjsAddress) => Promise<import('@tevm/utils').EthjsAccount>}\n * @private\n */\nexport const getAccountFromProvider = (baseState) => async (address) => {\n\tconst client = getForkClient(baseState)\n\tconst blockTag = getForkBlockTag(baseState)\n\tconst accountData = await client.getProof({\n\t\taddress: /** @type {import('@tevm/utils').Address}*/ (address.toString()),\n\t\tstorageKeys: [],\n\t\t...blockTag,\n\t})\n\tconst account = fromAccountData({\n\t\tbalance: BigInt(accountData.balance),\n\t\tnonce: BigInt(accountData.nonce),\n\t\tcodeHash: toBytes(accountData.codeHash),\n\t\tstorageRoot: toBytes(accountData.storageHash),\n\t})\n\treturn account\n}\n","import { fromRlpSerializedAccount } from '../utils/accountHelpers.js'\nimport { getAccountFromProvider } from './getAccountFromProvider.js'\n\n/**\n * Gets the account corresponding to the provided `address`.\n * Returns undefined if account does not exist.\n *\n * When running in fork mode:\n * 1. First checks main cache for the account\n * 2. Then checks fork cache if main cache misses\n * 3. Finally fetches from remote provider if neither cache has the account\n * 4. When fetched from remote, stores in both main and fork caches\n *\n * @type {import(\"../state-types/index.js\").StateAction<'getAccount'>}\n */\nexport const getAccount =\n\t(baseState, skipFetchingFromFork = false) =>\n\tasync (address) => {\n\t\tconst {\n\t\t\tcaches: { accounts },\n\t\t\tforkCache: { accounts: forkAccounts },\n\t\t} = baseState\n\n\t\t// First check main cache\n\t\tconst elem = accounts.get(address)\n\t\tif (elem !== undefined) {\n\t\t\treturn elem.accountRLP !== undefined ? fromRlpSerializedAccount(elem.accountRLP) : undefined\n\t\t}\n\n\t\t// Then check fork cache if we have a fork\n\t\tif (baseState.options.fork?.transport) {\n\t\t\tconst forkElem = forkAccounts.get(address)\n\t\t\tif (forkElem !== undefined) {\n\t\t\t\t// Convert to account and update main cache with value from fork cache\n\t\t\t\tif (forkElem.accountRLP !== undefined) {\n\t\t\t\t\tconst account = fromRlpSerializedAccount(forkElem.accountRLP)\n\t\t\t\t\taccounts.put(address, account)\n\t\t\t\t\tbaseState.logger.debug({ address }, 'Retrieved account from fork cache')\n\t\t\t\t\treturn account\n\t\t\t\t}\n\t\t\t\t// Handle undefined account case\n\t\t\t\taccounts.put(address, undefined)\n\t\t\t\tbaseState.logger.debug({ address }, 'Retrieved empty account from fork cache')\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t}\n\n\t\tif (!baseState.options.fork?.transport) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (skipFetchingFromFork) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tbaseState.logger.debug({ address }, 'fetching account from remote RPC')\n\t\tconst account = await getAccountFromProvider(baseState)(address)\n\n\t\tif (\n\t\t\taccount.nonce === 0n &&\n\t\t\taccount.balance === 0n &&\n\t\t\taccount.codeHash.every((/** @type {number} */ d) => d === 0) &&\n\t\t\taccount.storageRoot.every((/** @type {number} */ d) => d === 0)\n\t\t) {\n\t\t\t// Store empty account in both caches\n\t\t\taccounts.put(address, undefined)\n\t\t\tforkAccounts.put(address, undefined)\n\t\t\treturn undefined\n\t\t}\n\n\t\t// Store in both caches\n\t\taccounts.put(address, account)\n\t\tforkAccounts.put(address, account)\n\n\t\tbaseState.logger.debug({ address, account }, 'Cached forked account in state manager and fork cache')\n\t\treturn account\n\t}\n","import { getAddress } from '@tevm/utils'\n\n/**\n * @type {import(\"../state-types/index.js\").StateAction<'getAccountAddresses'>}\n */\nexport const getAccountAddresses = (baseState) => () => {\n\t/**\n\t * @type {Set<import('@tevm/utils').Address>}\n\t */\n\tconst accountAddresses = new Set()\n\t//Tevm initializes stateManager account cache with an ordered map cache\n\tbaseState.caches.accounts._orderedMapCache?.forEach((e) => {\n\t\taccountAddresses.add(getAddress(e[0].startsWith('0x') ? e[0] : `0x${e[0]}`))\n\t})\n\tconst { _lruCache, _orderedMapCache } = baseState.caches.accounts\n\tif (_lruCache !== undefined) {\n\t\tfor (const address of _lruCache.rkeys()) {\n\t\t\taccountAddresses.add(getAddress(address.startsWith('0x') ? address : `0x${address}`))\n\t\t}\n\t}\n\tif (_orderedMapCache !== undefined) {\n\t\t_orderedMapCache.forEach(([address]) => {\n\t\t\taccountAddresses.add(getAddress(address.startsWith('0x') ? address : `0x${address}`))\n\t\t})\n\t}\n\n\treturn accountAddresses\n}\n","import { bytesToHex } from '@tevm/utils'\nimport { hexToBytes } from 'viem'\nimport { getForkBlockTag } from './getForkBlockTag.js'\nimport { getForkClient } from './getForkClient.js'\n\nconst EMPTY_CODE = Object.freeze(new Uint8Array())\n\n/**\n * Gets the code corresponding to the provided `address`.\n * Returns an empty `Uint8Array` if the account has no associated code.\n *\n * When running in fork mode:\n * 1. First checks main cache for the code\n * 2. Then checks fork cache if main cache misses\n * 3. Finally fetches from remote provider if neither cache has the code\n * 4. When fetched from remote, stores in both main and fork caches\n *\n * @param {import('../BaseState.js').BaseState} baseState\n * @param {boolean} [skipFetchingFromFork=false]\n * @returns {(address: import('@tevm/utils').EthjsAddress) => Promise<Uint8Array>}\n */\nexport const getContractCode =\n\t(baseState, skipFetchingFromFork = false) =>\n\tasync (address) => {\n\t\tconst {\n\t\t\toptions,\n\t\t\tcaches: { contracts },\n\t\t\tforkCache: { contracts: forkContracts },\n\t\t} = baseState\n\n\t\t// First check main cache\n\t\tconst codeBytes = contracts.get(address)\n\t\tif (codeBytes !== undefined) {\n\t\t\treturn codeBytes\n\t\t}\n\n\t\t// Then check fork cache if we have a fork\n\t\tif (options.fork?.transport) {\n\t\t\tconst forkCodeBytes = forkContracts.get(address)\n\t\t\tif (forkCodeBytes !== undefined) {\n\t\t\t\t// Also update main cache with value from fork cache\n\t\t\t\tcontracts.put(address, forkCodeBytes)\n\t\t\t\tbaseState.logger.debug({ address }, 'Retrieved contract code from fork cache')\n\t\t\t\treturn forkCodeBytes\n\t\t\t}\n\t\t}\n\n\t\tif (!options.fork?.transport) {\n\t\t\treturn EMPTY_CODE\n\t\t}\n\n\t\tif (skipFetchingFromFork) {\n\t\t\treturn EMPTY_CODE\n\t\t}\n\n\t\tbaseState.logger.debug({ address }, 'Fetching contract code from remote RPC...')\n\n\t\tconst client = getForkClient(baseState)\n\t\tconst blockTag = getForkBlockTag(baseState)\n\n\t\t// don't fetch if we cached empty code already\n\t\tif (contracts.has(address)) {\n\t\t\treturn EMPTY_CODE\n\t\t}\n\n\t\tconst remoteCode = await client.getBytecode({\n\t\t\taddress: /** @type {import('@tevm/utils').Address}*/ (address.toString()),\n\t\t\t...blockTag,\n\t\t})\n\n\t\tif (!remoteCode) {\n\t\t\tbaseState.logger.debug({ address }, 'No remote code found')\n\t\t\t// Store empty code in both caches\n\t\t\tcontracts.put(address, EMPTY_CODE)\n\t\t\tforkContracts.put(address, EMPTY_CODE)\n\t\t\treturn EMPTY_CODE\n\t\t}\n\n\t\tconst remoteCodeBytes = hexToBytes(remoteCode)\n\n\t\t// Store in both caches\n\t\tcontracts.put(address, remoteCodeBytes)\n\t\tforkContracts.put(address, remoteCodeBytes)\n\n\t\tbaseState.logger.debug(\n\t\t\t{ address, deployedBytecode: bytesToHex(remoteCodeBytes) },\n\t\t\t'Cached forked contract bytecode to state and fork cache',\n\t\t)\n\n\t\treturn remoteCodeBytes\n\t}\n","import { createAddress } from '@tevm/address'\nimport { bytesToHex, getAddress, toHex } from '@tevm/utils'\nimport { fromAccountData } from '../utils/accountHelpers.js'\nimport { dumpStorage } from './dumpStorage.js'\nimport { getAccount } from './getAccount.js'\nimport { getAccountAddresses } from './getAccountAddresses.js'\nimport { getContractCode } from './getContractCode.js'\n\n// might be good to cache this to optimize perf and memory\n\n/**\n * Dumps the state of the state manager as a {@link TevmState}\n * @type {import(\"../state-types/index.js\").StateAction<'dumpCanonicalGenesis'>}\n */\nexport const dumpCanonicalGenesis = (baseState) => async () => {\n\tconst accountAddresses = getAccountAddresses(baseState)()\n\n\t/**\n\t * @type {import('../state-types/TevmState.js').TevmState}\n\t */\n\tconst state = {}\n\n\tfor (const address of accountAddresses) {\n\t\tconst hexAddress = getAddress(address.startsWith('0x') ? address : `0x${address}`)\n\t\tconst ethAddress = createAddress(hexAddress)\n\t\tconst account = (await getAccount(baseState, true)(ethAddress)) ?? fromAccountData({})\n\n\t\tconst storage = await dumpStorage(baseState)(ethAddress)\n\n\t\tconst deployedBytecode = await getContractCode(baseState, true)(ethAddress)\n\n\t\tconst dump = {\n\t\t\tnonce: account.nonce,\n\t\t\tbalance: account.balance,\n\t\t\tstorageRoot: bytesToHex(account.storageRoot),\n\t\t\tcodeHash: bytesToHex(account.codeHash),\n\t\t\tstorage,\n\t\t\t...(baseState.caches.contracts.has(ethAddress) ? { deployedBytecode: toHex(deployedBytecode) } : {}),\n\t\t}\n\n\t\tbaseState.logger.debug({ address: hexAddress, ...dump }, 'dumping address')\n\n\t\tstate[hexAddress] = dump\n\t}\n\n\treturn state\n}\n","import { keccak256, numberToHex, toHex } from 'viem'\nimport { dumpCanonicalGenesis } from './dumpCannonicalGenesis.js'\n\n/**\n * Commits the current change-set to the instance since the\n * last call to checkpoint.\n * @type {import(\"../state-types/index.js\").StateAction<'commit'>}\n */\nexport const commit =\n\t(baseState) =>\n\tasync (createNewStateRoot = false) => {\n\t\tconst state = await dumpCanonicalGenesis(baseState)()\n\t\t// This is kinda hacky we are just ranodmly generating new state roots\n\t\t// since we don't use a trie we are kinda hacking this\n\t\t// This might be needlessy slow as state gets big but for now it feels the most rubust wrt correctness\n\n\t\tconst newStateRoot = (() => {\n\t\t\tif (!createNewStateRoot) {\n\t\t\t\tbaseState.logger.debug('Comitting to existing state root...')\n\t\t\t\treturn baseState.getCurrentStateRoot()\n\t\t\t}\n\t\t\t/**\n\t\t\t * @type {import('../state-types/ParameterizedTevmState.js').ParameterizedTevmState}\n\t\t\t */\n\t\t\tconst jsonSerializableState = {}\n\n\t\t\tfor (const [k, v] of Object.entries(state)) {\n\t\t\t\tconst { nonce, balance, storageRoot, codeHash, deployedBytecode } = v\n\t\t\t\tjsonSerializableState[k] = {\n\t\t\t\t\t...v,\n\t\t\t\t\tnonce: numberToHex(nonce),\n\t\t\t\t\tbalance: numberToHex(balance),\n\t\t\t\t\tstorageRoot: storageRoot,\n\t\t\t\t\tcodeHash: codeHash,\n\t\t\t\t\t...(deployedBytecode !== undefined ? { deployedBytecode } : {}),\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst root = keccak256(toHex(JSON.stringify(jsonSerializableState)))\n\t\t\tbaseState.logger.debug({ root }, 'Committing to new state root...')\n\t\t\treturn root\n\t\t})()\n\n\t\tbaseState.stateRoots.set(newStateRoot, state)\n\t\tbaseState.logger.debug({ stateRoot: newStateRoot }, 'Saving state roots...')\n\t\tbaseState.setCurrentStateRoot(newStateRoot)\n\n\t\tbaseState.caches.accounts.commit()\n\t\tbaseState.caches.contracts.commit()\n\t\tbaseState.caches.storage.commit()\n\n\t\tbaseState.logger.debug('State roots are comitted successfully')\n\n\t\tbaseState.options.onCommit?.(baseState)\n\n\t\treturn\n\t}\n","import { CacheType, StorageCache } from '@ethereumjs/statemanager'\nimport { bytesToUnprefixedHex } from '@tevm/utils'\n\nconst oneBytes = Uint8Array.from([1])\n\n/**\n * Contract cache is a mapping of addresses to deployedBytecode\n * It is implemented via extending StorageCache and hardcoding slot 0\n */\nexport class ContractCache {\n\tconstructor(\n\t\tstorageCache = new StorageCache({\n\t\t\tsize: 100_000,\n\t\t\ttype: CacheType.LRU,\n\t\t}),\n\t) {\n\t\tthis.storageCache = storageCache\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tcommit() {\n\t\tthis.storageCache.commit()\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tclear() {\n\t\tthis.storageCache.clear()\n\t}\n\n\t/**\n\t * @param {import('@tevm/utils').EthjsAddress} address\n\t * @returns {Uint8Array | undefined}\n\t */\n\tget(address) {\n\t\treturn this.storageCache.get(address, oneBytes)\n\t}\n\n\t/**\n\t * @param {import('@tevm/utils').EthjsAddress} address\n\t * @param {Uint8Array} bytecode\n\t * @returns {void}\n\t */\n\tput(address, bytecode) {\n\t\tthis.storageCache.put(address, oneBytes, bytecode)\n\t}\n\n\t/**\n\t * @param {import('@tevm/utils').EthjsAddress} address\n\t * @returns {void}\n\t */\n\tdel(address) {\n\t\tthis.storageCache.del(address, oneBytes)\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tcheckpoint() {\n\t\tthis.storageCache.checkpoint()\n\t}\n\n\t/**\n\t * @param {import('@tevm/utils').EthjsAddress} address\n\t * @returns {boolean} if the cache has the key\n\t */\n\thas(address) {\n\t\tconst storageMap = this.storageCache._orderedMapCache?.getElementByKey(bytesToUnprefixedHex(address.bytes))\n\t\tconst hasOrderedMapCache = storageMap?.has(bytesToUnprefixedHex(oneBytes)) ?? false\n\t\tconst hasLruCache = this.storageCache._lruCache?.has(bytesToUnprefixedHex(address.bytes))\n\t\treturn Boolean(hasOrderedMapCache || hasLruCache)\n\t}\n\n\tget _checkpoints() {\n\t\treturn this.storageCache._checkpoints\n\t}\n\n\tsize() {\n\t\treturn this.storageCache.size()\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\trevert() {\n\t\tthis.storageCache.revert()\n\t}\n}\n","import { InternalError } from '@tevm/errors'\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Uint8Array}\n */\nexport const stripZeros = (bytes) => {\n\tif (!(bytes instanceof Uint8Array)) {\n\t\tthrow new InternalError('Unexpected type')\n\t}\n\treturn bytes.slice(bytes.findIndex(/** @param {number} entry*/ (entry) => entry !== 0))\n}\n","import { InternalError } from '@tevm/errors'\nimport { stripZeros } from '../utils/stripZeros.js'\nimport { getAccount } from './getAccount.js'\n\n/**\n * Adds value to the cache for the `account`\n * corresponding to `address` at the provided `key`.\n * Cannot be more than 32 bytes. Leading zeros are stripped.\n * If it is empty or filled with zeros, deletes the value.\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {(address: import('@tevm/utils').EthjsAddress, key: Uint8Array, value: Uint8Array) => Promise<void>}\n */\nexport const putContractStorage = (baseState) => async (address, key, value) => {\n\tif (key.length !== 32) {\n\t\tthrow new InternalError(`Storage key must be 32 bytes long. Received ${key}`)\n\t}\n\n\tconst account = await getAccount(baseState)(address)\n\tif (!account) {\n\t\tthrow new InternalError(\n\t\t\t'cannot putContractStorage on non existing acccount! Consider checking if account exists first',\n\t\t)\n\t}\n\tbaseState.caches.storage.put(address, key, stripZeros(value))\n}\n","import { AccountCache, CacheType, StorageCache } from '@ethereumjs/statemanager'\nimport { createAddress } from '@tevm/address'\nimport { InternalError } from '@tevm/errors'\nimport { createAccount, hexToBytes, isHex } from '@tevm/utils'\nimport { ContractCache } from '../ContractCache.js'\nimport { putContractStorage } from './putContractStorage.js'\n\n/**\n * Loads a {@link TevmState} into the state manager\n * @type {import(\"../state-types/index.js\").StateAction<'generateCanonicalGenesis'>}\n */\nexport const generateCanonicalGenesis = (baseState) => async (state) => {\n\tif (\n\t\tbaseState.caches.accounts._checkpoints > 0 ||\n\t\tbaseState.caches.storage._checkpoints > 0 ||\n\t\tbaseState.caches.contracts._checkpoints > 0\n\t) {\n\t\tthrow new InternalError('Attempted to generateCanonicalGenesis state with uncommitted checkpoints')\n\t}\n\tconst { caches: oldCaches } = baseState\n\tbaseState.caches = {\n\t\tcontracts: new ContractCache(),\n\t\taccounts: new AccountCache({\n\t\t\tsize: 100_000,\n\t\t\ttype: CacheType.LRU,\n\t\t}),\n\t\tstorage: new StorageCache({\n\t\t\tsize: 100_000,\n\t\t\ttype: CacheType.LRU,\n\t\t}),\n\t}\n\ttry {\n\t\tfor (const [k, v] of Object.entries(/** @type {import('../state-types/TevmState.js').TevmState}*/ (state))) {\n\t\t\tconst { nonce, balance, storageRoot, codeHash, storage, deployedBytecode } = v\n\t\t\tconst account = createAccount({\n\t\t\t\tnonce,\n\t\t\t\tbalance,\n\t\t\t\tstorageRoot: hexToBytes(storageRoot, { size: 32 }),\n\t\t\t\tcodeHash: hexToBytes(codeHash, { size: 32 }),\n\t\t\t})\n\t\t\tconst address = createAddress(k)\n\n\t\t\tbaseState.caches.accounts?.put(address, account)\n\t\t\tif (deployedBytecode) {\n\t\t\t\tbaseState.caches.contracts.put(address, hexToBytes(deployedBytecode))\n\t\t\t}\n\t\t\tif (storage !== undefined) {\n\t\t\t\tfor (const [storageKey, storageData] of Object.entries(storage)) {\n\t\t\t\t\tconst key = hexToBytes(isHex(storageKey) ? storageKey : `0x${storageKey}`)\n\t\t\t\t\tconst data = /** @type {Uint8Array}*/ (hexToBytes(isHex(storageData) ? storageData : `0x${storageData}`))\n\t\t\t\t\tawait putContractStorage(baseState)(address, key, data)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tbaseState.logger.debug(state)\n\t\tbaseState.logger.error(e, 'There was an error generating cannonical genesis. Reverting back to old state')\n\t\tbaseState.caches = oldCaches\n\t\tthrow e\n\t}\n}\n","import { AccountCache, CacheType, StorageCache } from '@ethereumjs/statemanager'\nimport { InternalError } from '@tevm/errors'\nimport { createLogger } from '@tevm/logger'\nimport { checkpoint } from './actions/checkpoint.js'\nimport { commit } from './actions/commit.js'\nimport { generateCanonicalGenesis } from './actions/generateCannonicalGenesis.js'\nimport { ContractCache } from './ContractCache.js'\n\n/**\n * @type {import('viem').Hex}\n */\nconst INITIAL_STATE_ROOT = '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421'\n\n/**\n * @internal\n * Creates the core data structure for ethereum state\n * @param {import('./state-types/index.js').StateOptions} options\n * @returns {import('./BaseState.js').BaseState}\n * Creates the core data structure the state manager operates on\n */\nexport const createBaseState = (options) => {\n\tconst logger = createLogger({\n\t\tlevel: options.loggingLevel ?? 'warn',\n\t\tname: '@tevm/state-manager',\n\t})\n\t/**\n\t * @type {import('./state-types/StateRoots.js').StateRoots}\n\t */\n\tconst stateRoots = options.stateRoots ?? new Map()\n\tif (options.genesisState && options.currentStateRoot) {\n\t\tstateRoots.set(options.currentStateRoot, options.genesisState)\n\t} else {\n\t\tstateRoots.set(INITIAL_STATE_ROOT, options.genesisState ?? {})\n\t}\n\tlet currentStateRoot = options.currentStateRoot ?? INITIAL_STATE_ROOT\n\t/**\n\t * @type {import('./BaseState.js').BaseState}\n\t */\n\tconst state = {\n\t\tlogger,\n\t\tgetCurrentStateRoot: () => currentStateRoot,\n\t\tsetCurrentStateRoot: (root) => {\n\t\t\tif (!state.stateRoots.has(root)) {\n\t\t\t\tthrow new InternalError('Cannot set state root to non existing state root')\n\t\t\t}\n\t\t\tcurrentStateRoot = root\n\t\t},\n\t\tstateRoots,\n\t\toptions,\n\t\tcaches: {\n\t\t\tcontracts: options.contractCache ?? new ContractCache(new StorageCache({ size: 100_000, type: CacheType.LRU })),\n\t\t\taccounts:\n\t\t\t\toptions.accountsCache ??\n\t\t\t\tnew AccountCache({\n\t\t\t\t\tsize: 100_000,\n\t\t\t\t\ttype: CacheType.LRU,\n\t\t\t\t}),\n\t\t\tstorage:\n\t\t\t\toptions.storageCache ??\n\t\t\t\tnew StorageCache({\n\t\t\t\t\tsize: 100_000,\n\t\t\t\t\ttype: CacheType.LRU,\n\t\t\t\t}),\n\t\t},\n\t\tforkCache: {\n\t\t\tcontracts: options.contractCache ?? new ContractCache(new StorageCache({ size: 100_000, type: CacheType.LRU })),\n\t\t\taccounts:\n\t\t\t\toptions.accountsCache ??\n\t\t\t\tnew AccountCache({\n\t\t\t\t\tsize: 100_000,\n\t\t\t\t\ttype: CacheType.LRU,\n\t\t\t\t}),\n\t\t\tstorage:\n\t\t\t\toptions.storageCache ??\n\t\t\t\tnew StorageCache({\n\t\t\t\t\tsize: 100_000,\n\t\t\t\t\ttype: CacheType.LRU,\n\t\t\t\t}),\n\t\t},\n\t\tready: () => genesisPromise.then(() => true),\n\t}\n\tconst genesisPromise = (\n\t\toptions.genesisState !== undefined && options.currentStateRoot === undefined\n\t\t\t? (async () => {\n\t\t\t\t\tconst fn = generateCanonicalGenesis(state)\n\t\t\t\t\tif (fn && options.genesisState) {\n\t\t\t\t\t\treturn fn(options.genesisState)\n\t\t\t\t\t}\n\t\t\t\t})()\n\t\t\t: Promise.resolve().then(() => {\n\t\t\t\t\tif (options.currentStateRoot) {\n\t\t\t\t\t\tstate.setCurrentStateRoot(options.currentStateRoot)\n\t\t\t\t\t\tconst fn = generateCanonicalGenesis(state)\n\t\t\t\t\t\tconst genesis = options.genesisState ?? stateRoots.get(options.currentStateRoot)\n\t\t\t\t\t\tif (fn && genesis) {\n\t\t\t\t\t\t\treturn fn(genesis)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn Promise.resolve()\n\t\t\t\t})\n\t).then(async () => {\n\t\tawait checkpoint(state)()\n\t\tawait commit(state)()\n\t\tlogger.debug('StateManager is ready')\n\t})\n\n\treturn state\n}\n","import { InternalError } from '@tevm/errors'\nimport { createBaseState } from '../createBaseState.js'\nimport { dumpCanonicalGenesis } from './dumpCannonicalGenesis.js'\n\n/**\n * Returns a new instance of the ForkStateManager with the same opts and all storage copied over.\n *\n * IMPORTANT: The fork cache is NOT copied but instead is shared between the original state\n * and the copied state. This is intentional and safe because:\n * 1. Fork cache is read-only relative to the forked blockchain state at a specific block\n * 2. Sharing the cache improves performance by preventing duplicate remote fetches\n * 3. It enables persistent caching of fork data across VM instances\n *\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {() => Promise<import('../BaseState.js').BaseState>}\n */\nexport const deepCopy = (baseState) => async () => {\n\tawait baseState.ready()\n\tif (\n\t\tbaseState.caches.accounts._checkpoints > 0 ||\n\t\tbaseState.caches.storage._checkpoints > 0 ||\n\t\tbaseState.caches.contracts._checkpoints > 0\n\t) {\n\t\tthrow new InternalError('Attempted to deepCopy state with uncommitted checkpoints')\n\t}\n\tconst newState = createBaseState({\n\t\t...baseState.options,\n\t\tgenesisState: await dumpCanonicalGenesis(baseState)(),\n\t\tstateRoots: new Map(baseState.stateRoots),\n\t\tcurrentStateRoot: baseState.getCurrentStateRoot(),\n\t})\n\n\tawait newState.ready()\n\n\t// Share the fork cache object between instances rather than copying it\n\t// This is safe because the fork cache is conceptually read-only\n\t// relative to the forked blockchain at a specific block\n\tif (baseState.forkCache) {\n\t\t// Directly assign the same fork cache object\n\t\tnewState.forkCache = baseState.forkCache\n\t\tbaseState.logger.debug('Sharing fork cache reference between original and copied state')\n\t}\n\n\tbaseState.logger.debug(\"Successfully deepCopy'd StateManager with shared fork cache\")\n\treturn newState\n}\n","/**\n * Deletes an account from state under the provided `address`.\n * @type {import(\"../state-types/index.js\").StateAction<'deleteAccount'>}\n */\nexport const deleteAccount = (baseState) => async (address) => {\n\tawait baseState.ready()\n\tbaseState.caches.accounts.del(address)\n\t// TODO known bug for unused api. we should delete bytecode too\n\tbaseState.logger.debug({ address }, 'Deleted account')\n\treturn\n}\n","import { InvalidParamsError } from '@tevm/errors'\nimport { bytesToHex, getAddress, hexToBigInt } from '@tevm/utils'\n\n/**\n * @type {import(\"../state-types/index.js\").StateAction<'dumpStorageRange'>}\n */\nexport const dumpStorageRange = (state) => (_address, _startKey, _limit) => {\n\tconst storage = state.caches.storage.dump(_address)\n\tif (!storage) {\n\t\tthrow new InvalidParamsError(`No storage found at address ${getAddress(_address.toString())}`)\n\t}\n\t/**\n\t * @type {Array<[import(\"viem\").Hex, {key: import(\"@tevm/utils\").Hex, value: import('@tevm/utils').Hex}]>}\n\t */\n\tconst entries = []\n\t/**\n\t * @type {import(\"viem\").Hex | null}\n\t */\n\tlet nextKey = null\n\tlet started = false\n\tfor (const [storageKey, storageValue] of storage.entries()) {\n\t\tif (entries.length === _limit) {\n\t\t\tnextKey = /** @type {import(\"@tevm/utils\").Hex}*/ (storageKey)\n\t\t\tbreak\n\t\t}\n\t\tif (!started) {\n\t\t\tif (hexToBigInt(/** @type {import('@tevm/utils').Hex}*/ (storageKey)) === _startKey) {\n\t\t\t\tstarted = true\n\t\t\t} else {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tconst key = /** @type {import(\"@tevm/utils\").Hex}*/ (storageKey)\n\t\tconst value = bytesToHex(storageValue)\n\t\tentries.push([key, { key, value }])\n\t}\n\treturn Promise.resolve({\n\t\tnextKey,\n\t\tstorage: Object.fromEntries(entries),\n\t})\n}\n","import { keccak256 } from 'viem'\n\n/**\n * @deprecated\n * Returns the applied key for a given address\n * Used for saving preimages\n * @type {import(\"../state-types/index.js\").StateAction<'getAppliedKey'>}\n */\nexport const getAppliedKey = () => (address) => {\n\treturn keccak256(address, 'bytes')\n}\n","import { InternalError } from '@tevm/errors'\nimport { bytesToHex, hexToBytes } from 'viem'\nimport { getAccount } from './getAccount.js'\nimport { getForkBlockTag } from './getForkBlockTag.js'\nimport { getForkClient } from './getForkClient.js'\nimport { putContractStorage } from './putContractStorage.js'\n\n/**\n * Gets the storage value associated with the provided `address` and `key`. This method returns\n * the shortest representation of the stored value.\n * corresponding to the provided address at the provided key.\n * If this does not exist an empty `Uint8Array` is returned.\n *\n * When running in fork mode:\n * 1. First checks main cache for the value\n * 2. Then checks fork cache if main cache misses\n * 3. Finally fetches from remote provider if neither cache has the value\n * 4. When fetched from remote, stores in both main and fork caches\n *\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {(address: import('@tevm/utils').EthjsAddress, key: Uint8Array) => Promise<Uint8Array>}\n */\nexport const getContractStorage = (baseState) => async (address, key) => {\n\tconst {\n\t\tcaches: { storage: storageCache },\n\t\tforkCache: { storage: forkStorageCache },\n\t} = baseState\n\t// Check storage slot in cache\n\tif (key.length !== 32) {\n\t\tthrow new InternalError(\n\t\t\t`Storage key must be 32 bytes long. Received ${key.length}. If using numberToHex make the length 32.`,\n\t\t)\n\t}\n\n\t// First check main cache\n\tconst cachedValue = storageCache.get(address, key)\n\tif (cachedValue !== undefined) {\n\t\treturn cachedValue\n\t}\n\n\t// Then check fork cache if we have a fork\n\tif (baseState.options.fork?.transport) {\n\t\tconst forkedValue = forkStorageCache.get(address, key)\n\t\tif (forkedValue !== undefined) {\n\t\t\t// Also update main cache with value from fork cache\n\t\t\tawait putContractStorage(baseState)(address, key, forkedValue)\n\t\t\tbaseState.logger.debug({ address, key, forkedValue }, 'Retrieved storage from fork cache')\n\t\t\treturn forkedValue\n\t\t}\n\t}\n\n\tconst isContractAtAddress = (await getAccount(baseState)(address))?.isContract()\n\tif (!isContractAtAddress) {\n\t\tbaseState.logger.debug(`No contract found at address ${address}. Cannot getContractStorage if there is no contract`)\n\t\treturn hexToBytes('0x0')\n\t}\n\n\tif (!baseState.options.fork?.transport) {\n\t\treturn hexToBytes('0x0')\n\t}\n\n\tbaseState.logger.debug({ address, key }, 'Fetching storage from remote RPC')\n\n\tconst client = getForkClient(baseState)\n\tconst blockTag = getForkBlockTag(baseState)\n\n\tconst storage = await client.getStorageAt({\n\t\taddress: /** @type {import('@tevm/utils').Address} */ (address.toString()),\n\t\tslot: bytesToHex(key),\n\t\t...blockTag,\n\t})\n\tconst value = hexToBytes(storage ?? '0x0')\n\n\t// Store in both caches\n\tawait putContractStorage(baseState)(address, key, value)\n\n\t// Also store in fork cache to persist original values\n\tforkStorageCache.put(address, key, value)\n\n\tbaseState.logger.debug({ address, key, value }, 'Cached forked storage to state and fork cache')\n\n\treturn value\n}\n","import { bytesToHex, toHex } from '@tevm/utils'\nimport { getForkBlockTag } from './getForkBlockTag.js'\nimport { getForkClient } from './getForkClient.js'\n\n// TODO only works in forked mode\n/**\n * Get an EIP-1186 proof from the provider\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {(address: import('@tevm/utils').EthjsAddress, storageSlots?: Uint8Array[]) => Promise<import('@ethereumjs/statemanager').Proof>}\n */\nexport const getProof =\n\t(baseState) =>\n\tasync (address, storageSlots = []) => {\n\t\tif (!baseState.options.fork?.transport) {\n\t\t\tthrow new Error(\n\t\t\t\t'getProof only implemented in fork mode atm because tevm at this moment does not merkilize the state',\n\t\t\t)\n\t\t}\n\t\tconst client = getForkClient(baseState)\n\t\tconst blockTag = getForkBlockTag(baseState)\n\t\tconst proof = await client.getProof({\n\t\t\taddress: /** @type {import('@tevm/utils').Address}*/ (address.toString()),\n\t\t\tstorageKeys: storageSlots.map((slot) => bytesToHex(slot)),\n\t\t\t...blockTag,\n\t\t})\n\t\treturn {\n\t\t\taddress: proof.address,\n\t\t\taccountProof: proof.accountProof,\n\t\t\tbalance: toHex(proof.balance),\n\t\t\tcodeHash: proof.codeHash,\n\t\t\tnonce: toHex(proof.nonce),\n\t\t\tstorageHash: proof.storageHash,\n\t\t\tstorageProof: proof.storageProof.map((p) => ({\n\t\t\t\tproof: p.proof,\n\t\t\t\tvalue: toHex(p.value),\n\t\t\t\tkey: p.key,\n\t\t\t})),\n\t\t}\n\t}\n","import { hexToBytes } from 'ethereum-cryptography/utils'\n\n/**\n * Gets the current state root\n * @type {import(\"../state-types/index.js\").StateAction<'getStateRoot'>}\n */\nexport const getStateRoot = (baseState) => async () => {\n\treturn hexToBytes(baseState.getCurrentStateRoot())\n}\n","import { bytesToHex } from '@tevm/utils'\n\n/**\n * Returns true if state root exists\n * @type {import(\"../state-types/index.js\").StateAction<'hasStateRoot'>}\n */\nexport const hasStateRoot = (baseState) => (root) => {\n\treturn Promise.resolve(baseState.stateRoots.has(bytesToHex(root)))\n}\n","/**\n * Saves an account into state under the provided `address`.\n * @type {import(\"../state-types/index.js\").StateAction<'putAccount'>}\n */\nexport const putAccount = (baseState) => async (address, account) => {\n\tif (account !== undefined) {\n\t\tbaseState.caches.accounts?.put(address, account)\n\t} else {\n\t\tbaseState.caches.accounts?.del(address)\n\t}\n}\n","import { createAccount } from '@tevm/utils'\nimport { getAccount } from './getAccount.js'\nimport { putAccount } from './putAccount.js'\n\n/**\n * Gets the account associated with `address`, modifies the given account\n * fields, then saves the account into state. Account fields can include\n * `nonce`, `balance`, `storageRoot`, and `codeHash`.\n * @type {import(\"../state-types/index.js\").StateAction<'modifyAccountFields'>}\n */\nexport const modifyAccountFields = (baseState) => async (address, accountFields) => {\n\tconst account = (await getAccount(baseState)(address)) ?? createAccount({})\n\taccount.nonce = accountFields.nonce ?? account.nonce\n\taccount.balance = accountFields.balance ?? account.balance\n\taccount.storageRoot = accountFields.storageRoot ?? account.storageRoot\n\taccount.codeHash = accountFields.codeHash ?? account.codeHash\n\tawait putAccount(baseState)(address, account)\n}\n","import { bytesToUnprefixedHex } from '@tevm/utils'\nimport { getContractStorage } from './getContractStorage.js'\n\n/**\n * Commits the current change-set to the instance since the\n * last call to checkpoint.\n * @type {import(\"../state-types/index.js\").StateAction<'originalStorageCache'>}\n */\nexport const originalStorageCache = (baseState) => {\n\tconst state = new Map()\n\t/**\n\t * @param {import(\"@tevm/utils\").EthjsAddress} address\n\t * @param {Uint8Array} key\n\t * @param {Uint8Array} value\n\t */\n\tconst put = (address, key, value) => {\n\t\tconst addressHex = bytesToUnprefixedHex(address.bytes)\n\t\tlet map = state.get(addressHex)\n\t\tif (map === undefined) {\n\t\t\tmap = new Map()\n\t\t\tstate.set(addressHex, map)\n\t\t}\n\t\tconst keyHex = bytesToUnprefixedHex(key)\n\t\tif (map.has(keyHex) === false) {\n\t\t\tmap.set(keyHex, value)\n\t\t}\n\t}\n\n\treturn {\n\t\tasync get(address, key) {\n\t\t\tconst addressHex = bytesToUnprefixedHex(address.bytes)\n\t\t\tconst map = state.get(addressHex)\n\t\t\tif (map !== undefined) {\n\t\t\t\tconst keyHex = bytesToUnprefixedHex(key)\n\t\t\t\tconst value = map.get(keyHex)\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst value = await getContractStorage(baseState)(address, key)\n\t\t\tput(address, key, value)\n\t\t\treturn value\n\t\t},\n\t\tclear() {},\n\t}\n}\n","import { createAccount, keccak256 } from '@tevm/utils'\nimport { getAccount } from './getAccount.js'\nimport { putAccount } from './putAccount.js'\n\n/**\n * Adds `value` to the state trie as code, and sets `codeHash` on the account\n * corresponding to `address` to reference this.\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {(address: import('@tevm/utils').EthjsAddress, value: Uint8Array) => Promise<void>}\n */\nexport const putContractCode = (baseState) => async (address, value) => {\n\tconst account = await getAccount(baseState)(address)\n\n\t// Create account data object, conditionally including storageRoot\n\t/** @type {{nonce: bigint, balance: bigint, codeHash: Uint8Array, storageRoot?: Uint8Array}} */\n\tconst accountData = {\n\t\tnonce: account?.nonce ?? 0n,\n\t\tbalance: account?.balance ?? 0n,\n\t\tcodeHash: keccak256(value, 'bytes'),\n\t}\n\n\t// Only include storageRoot if it exists\n\tif (account?.storageRoot !== undefined) {\n\t\taccountData.storageRoot = account.storageRoot\n\t}\n\n\tawait putAccount(baseState)(address, createAccount(accountData))\n\tbaseState.caches.contracts.put(address, value)\n\treturn\n}\n","/**\n * Commits the current change-set to the instance since the\n * last call to checkpoint.\n * @type {import(\"../state-types/index.js\").StateAction<'revert'>}\n */\nexport const revert = (baseState) => () => {\n\tbaseState.caches.accounts.revert()\n\tbaseState.caches.storage.revert()\n\tbaseState.caches.contracts.revert()\n\tbaseState.logger.debug('State reverted')\n\treturn Promise.resolve()\n}\n","import { bytesToHex } from 'viem'\nimport { generateCanonicalGenesis } from './generateCannonicalGenesis.js'\n\n/**\n * Error thrown if state root doesn't exist\n */\nexport class NoStateRootExistsError extends Error {\n\t/**\n\t * @override\n\t * @type {'NoStateRootExistsError'}\n\t */\n\tname = 'NoStateRootExistsError'\n\t/**\n\t * @type {'NoStateRootExistsError'}\n\t */\n\t_tag = 'NoStateRootExistsError'\n}\n\n/**\n * Changes the currently loaded state root\n * @type {import(\"../state-types/index.js\").StateAction<'setStateRoot'>}\n */\nexport const setStateRoot = (baseState) => async (root) => {\n\tif (\n\t\tbaseState.caches.accounts._checkpoints > 0 ||\n\t\tbaseState.caches.storage._checkpoints > 0 ||\n\t\tbaseState.caches.contracts._checkpoints > 0\n\t) {\n\t\tthrow new Error('Attempted to setStateRoot with uncommitted checkpoints')\n\t}\n\tconst genesis = baseState.stateRoots.get(bytesToHex(root))\n\t// TODO we need to handle the fok case here\n\tif (!genesis) {\n\t\tthrow new NoStateRootExistsError(`State root for ${bytesToHex(root)} does not exist`)\n\t}\n\tconst oldStateRoot = baseState.getCurrentStateRoot()\n\ttry {\n\t\tbaseState.setCurrentStateRoot(bytesToHex(root))\n\t\tconst generateFn = generateCanonicalGenesis(baseState)\n\t\tif (generateFn) {\n\t\t\tawait generateFn(genesis)\n\t\t}\n\t\tbaseState.logger.debug({ oldStateRoot, newStateRoot: root }, 'state root changed')\n\t\treturn\n\t} catch (e) {\n\t\tbaseState.setCurrentStateRoot(oldStateRoot)\n\t\tthrow e\n\t}\n}\n","import { AccountCache, CacheType, StorageCache } from '@ethereumjs/statemanager'\nimport { ContractCache } from '../ContractCache.js'\nimport { createBaseState } from '../createBaseState.js'\n\n/**\n * Returns a new instance of the ForkStateManager with the same opts but no storage copied over.\n *\n * IMPORTANT: The fork cache is NOT copied but instead is shared between the original state\n * and the copied state. This is intentional and safe because:\n * 1. Fork cache is read-only relative to the forked blockchain state at a specific block\n * 2. Sharing the cache improves performance by preventing duplicate remote fetches\n * 3. It enables persistent caching of fork data across VM instances\n *\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {() => import('../BaseState.js').BaseState}\n */\nexport const shallowCopy = (baseState) => () => {\n\tconst newState = createBaseState(baseState.options)\n\tnewState.caches.contracts = new ContractCache()\n\tnewState.caches.storage = new StorageCache({\n\t\tsize: 100000,\n\t\ttype: CacheType.LRU,\n\t})\n\tnewState.caches.accounts = new AccountCache({\n\t\tsize: 100000,\n\t\ttype: CacheType.LRU,\n\t})\n\n\t// Share the fork cache object between instances rather than creating a new one\n\t// This is safe because the fork cache is conceptually read-only\n\t// relative to the forked blockchain at a specific block\n\tif (baseState.forkCache) {\n\t\t// Directly assign the same fork cache object\n\t\tnewState.forkCache = baseState.forkCache\n\t\tbaseState.logger.debug('Sharing fork cache reference between original and shallow copied state')\n\t}\n\n\treturn newState\n}\n","import { bytesToHex } from '@tevm/utils'\n\n/**\n * Saves a given state root and value to the state root mapping\n * @param {import('../BaseState.js').BaseState} baseState\n * @returns {(root: Uint8Array, state: import('../state-types/TevmState.js').TevmState) => void}\n */\nexport const saveStateRoot = (baseState) => (root, value) => {\n\tbaseState.stateRoots.set(bytesToHex(root), value)\n\tbaseState.logger.debug({ root: bytesToHex(root), value }, 'Saved state root')\n}\n","import {\n\tcheckpoint,\n\tclearCaches,\n\tclearContractStorage,\n\tcommit,\n\tdeepCopy,\n\tdeleteAccount,\n\tdumpCanonicalGenesis,\n\tdumpStorage,\n\tdumpStorageRange,\n\tgenerateCanonicalGenesis,\n\tgetAccount,\n\tgetAccountAddresses,\n\tgetAppliedKey,\n\tgetContractCode,\n\tgetContractStorage,\n\tgetProof,\n\tgetStateRoot,\n\thasStateRoot,\n\tmodifyAccountFields,\n\tputAccount,\n\tputContractCode,\n\tputContractStorage,\n\trevert,\n\tsetStateRoot,\n\tshallowCopy,\n} from './actions/index.js'\nimport { originalStorageCache } from './actions/originalStorageCache.js'\nimport { saveStateRoot } from './actions/saveStateRoot.js'\nimport { createBaseState } from './createBaseState.js'\n\n/**\n * @param {import('./state-types/StateOptions.js').StateOptions} options\n * @returns {import('./StateManager.js').StateManager}\n */\nexport const createStateManager = (options) => {\n\treturn decorate(createBaseState(options))\n}\n\n/**\n * @param {import('./BaseState.js').BaseState} state\n * @returns {import('./StateManager.js').StateManager}\n */\nconst decorate = (state) => {\n\t/**\n\t * @type {import('./StateManager.js').StateManager}\n\t */\n\tconst wrappedState = {\n\t\tready: state.ready,\n\t\t_baseState: state,\n\t\tdeepCopy: async () => {\n\t\t\treturn decorate(await deepCopy(state)())\n\t\t},\n\t\tshallowCopy: () => {\n\t\t\treturn decorate(shallowCopy(state)())\n\t\t},\n\t\tdumpCanonicalGenesis: () => dumpCanonicalGenesis(state)(),\n\t\tgenerateCanonicalGenesis: generateCanonicalGenesis(state),\n\t\tputAccount: putAccount(state),\n\t\tclearCaches: clearCaches(state),\n\t\tcommit: commit(state),\n\t\tcheckpoint: checkpoint(state),\n\t\trevert: revert(state),\n\t\tgetProof: getProof(state),\n\t\tgetCode: getContractCode(state),\n\t\tgetCodeSize: (address) => getContractCode(state)(address).then((code) => code.length),\n\t\tgetAccount: getAccount(state),\n\t\tdumpStorage: dumpStorage(state),\n\t\tgetStateRoot: getStateRoot(state),\n\t\thasStateRoot: hasStateRoot(state),\n\t\tsetStateRoot: setStateRoot(state),\n\t\tsaveStateRoot: saveStateRoot(state),\n\t\tdeleteAccount: deleteAccount(state),\n\t\tputCode: putContractCode(state),\n\t\tdumpStorageRange: dumpStorageRange(state),\n\t\tgetStorage: getContractStorage(state),\n\t\tputStorage: putContractStorage(state),\n\t\tclearStorage: clearContractStorage(state),\n\t\tmodifyAccountFields: modifyAccountFields(state),\n\t\tclearContractStorage: clearContractStorage(state),\n\t\tgetAccountAddresses: getAccountAddresses(state),\n\t\t// Unused provided to fulfill interface\n\t\tgetAppliedKey: /** @type {any}*/ (getAppliedKey(state)),\n\t\toriginalStorageCache: originalStorageCache(state),\n\t}\n\treturn wrappedState\n}\n"]}