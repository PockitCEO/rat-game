import * as viem from 'viem';
import { ContractFunctionName, Chain, WriteContractReturnType, WriteContractErrorType, WaitForTransactionReceiptReturnType, Account, ContractFunctionArgs, WriteContractParameters, Transport } from 'viem';
import * as _tevm_memory_client from '@tevm/memory-client';
import * as _tevm_decorators from '@tevm/decorators';
import { TevmClient } from '@tevm/client-types';
import { Abi } from 'abitype';
import { ContractResult } from '@tevm/actions';

declare function tevmTransport({ request }: Pick<_tevm_decorators.Eip1193RequestProvider, "request"> | Pick<_tevm_memory_client.MemoryClient, "request">, options?: Pick<viem.TransportConfig, "name" | "key" | "timeout" | "retryCount" | "retryDelay">): viem.Transport;

/**
 * @deprecated in favor of the viem transport
 * The decorated properties added by the `tevmViemExtension`
 */
type ViemTevmClient = {
    tevm: TevmClient;
};

/**
 * @deprecated in favor of the viem transport
 * A viem decorator for `tevmViemExtension`
 */
type ViemTevmClientDecorator = (client: any) => ViemTevmClient;

/**
* @deprecated in favor of the viem transport
* @experimental
* This extension is highly experimental and should not be used in production.
*
* Creates a decorator to a viem wallet client that adds the `writeContractOptimistic` method to the `tevm` property.
* This enables viem to optimistically update the tevm state before the transaction is mined.
* @example
* ```ts
* import { tevmViemExtensionOptimistic } from 'tevmViemExtensionOptimistic'
* import { walletClient } from './walletClient.js'
*
* const client = walletClient.extend(tevmViemExtensionOptimistic())
*
* for (const result of client.transport.tevm.writeContractOptimistic({
*   from: '0x...',
*   to: '0x...',
*   abi: [...],
*   functionName: 'transferFrom',
*   args: ['0x...', '0x...', '1000000000000000000'],
* })) {
*	if (result.tag === 'OPTIMISTIC_RESULT') {
*		expect(result).toEqual({
*			data: mockRequestResponse as any,
*			success: true,
*			tag: 'OPTIMISTIC_RESULT',
*		})
*		expect((client.request as jest.Mock).mock.lastCall[0]).toEqual({
*			method: 'tevm_contract',
params: params,
*			jsonrpc: '2.0',
*		})
*		expect((client.writeContract as jest.Mock).mock.lastCall[0]).toEqual({
*			abi: params.abi,
*			functionName: params.functionName,
*			args: params.args,
*			caller: params.caller,
*			address: params.address,
*			account: params.account,
*			chain: params.chain,
*		})
*	} else if (result.tag === 'HASH') {
*		expect(result).toEqual({
*			data: mockWriteContractResponse,
*			success: true,
*			tag: 'HASH',
*		})
*	} else if (result.tag === 'RECEIPT') {
*		expect(result).toEqual({
*			data: mockTxReciept,
*			success: true,
*			tag: 'RECEIPT',
*		})
*		expect(mockWaitForTransactionReceipt.mock.lastCall[0]).toEqual(client)
*		expect(mockWaitForTransactionReceipt.mock.lastCall[1]).toEqual({
*			hash: mockWriteContractResponse,
*		})
*	}
* }
*/
type ViemTevmExtension = () => ViemTevmClientDecorator;

/**
 * Decorates a viem [public client](https://viem.sh/) with the [tevm api](https://tevm.sh/generated/tevm/api/type-aliases/tevm/)
 * @type {import('./ViemTevmExtension.js').ViemTevmExtension}
 * @example
 * ```js
 * import { createClient, parseEth } from 'viem'
 * import { tevmViemExtension } from '@tevm/viem-extension'
 *
 * const client = createClient('https://mainnet.optimism.io')
 *   .extend(tevmViemExtension())
 *
 * await client.transport.tevm.account({
 *   address: `0x${'12'.repeat(20)}`,
 *   balance: parseEth('420'),
 * })
 * ```
 * @see [@tevm/server](https://tevm.sh/generated/tevm/server/functions/createserver) for documentation on creating a tevm backend
 */
declare const tevmViemExtension: ViemTevmExtension;

/**
 * An error with a tag
 */
type TypedError<T> = Error & {
    tag: T;
};

/**
 * An error yield of writeContractOptimistic
 * Errors are yielded rather than throwing
 */
type GenError<TErrorType, TTag extends string> = {
    errors?: ReadonlyArray<TypedError<string>>;
    error: TErrorType;
    success: false;
    tag: TTag;
};

/**
 * @experimental
 * A result type for a single yield of writeContractOptimistic
 */
type GenResult<TDataType, TTag extends string> = {
    success: true;
    tag: TTag;
    data: TDataType;
    errors?: ReadonlyArray<TypedError<string>>;
};

/**
 * @experimental
 * The result of an optimistic write
 */
type OptimisticResult<TAbi extends Abi | readonly unknown[], TFunctionName extends ContractFunctionName<TAbi>, TChain extends Chain | undefined> = GenResult<ContractResult<TAbi, TFunctionName>, 'OPTIMISTIC_RESULT'> | GenError<Error, 'OPTIMISTIC_RESULT'> | GenResult<WriteContractReturnType, 'HASH'> | GenError<WriteContractErrorType, 'HASH'> | GenResult<WaitForTransactionReceiptReturnType<TChain>, 'RECEIPT'> | GenError<WriteContractErrorType, 'RECEIPT'>;

/**
 * @deprecated in favor of the viem transport
 * @experimental
 * The decorated methods added to a viem wallet client by `tevmViemExtensionOptimistic`
 */
type ViemTevmOptimisticClient<TChain extends Chain | undefined = Chain, TAccount extends Account | undefined = Account | undefined> = {
    tevm: Omit<TevmClient, 'request'> & {
        writeContractOptimistic<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends ContractFunctionName<TAbi> = ContractFunctionName<TAbi>, TArgs extends ContractFunctionArgs<TAbi, 'nonpayable' | 'payable', TFunctionName> = ContractFunctionArgs<TAbi, 'nonpayable' | 'payable', TFunctionName>, TChainOverride extends Chain | undefined = Chain | undefined>(action: WriteContractParameters<TAbi, TFunctionName, TArgs, TChain, TAccount, TChainOverride>): AsyncGenerator<OptimisticResult<TAbi, TFunctionName, TChain>>;
    };
};

/**
 * @deprecated in favor of the viem transport
 * @experimental
 * A viem decorator for `tevmViemExtension`
 */
type ViemTevmOptimisticClientDecorator = <TTransport extends Transport = Transport, TChain extends Chain | undefined = Chain | undefined, TAccount extends Account | undefined = Account | undefined>(client: Pick<viem.WalletClient<TTransport, TChain, TAccount>, 'request' | 'writeContract'>) => ViemTevmOptimisticClient<TChain, TAccount>;

declare function tevmViemExtensionOptimistic(): ViemTevmOptimisticClientDecorator;

export { tevmTransport, tevmViemExtension, tevmViemExtensionOptimistic };
