import { createTransport, numberToHex, hexToBigInt, encodeFunctionData, decodeFunctionResult } from 'viem';
import { mnemonicToAccount } from 'viem/accounts';
import { waitForTransactionReceipt } from 'viem/actions';

// src/tevmTransport.js
var tevmTransport = ({ request }, options) => {
  return () => {
    return createTransport({
      request: (
        /** @type any*/
        request
      ),
      type: "tevm",
      name: options?.name ?? "Tevm transport",
      key: options?.key ?? "tevm",
      timeout: options?.timeout ?? 2e4,
      retryCount: options?.retryCount ?? 3,
      retryDelay: options?.retryDelay ?? 150
    });
  };
};
var oneToTen = Array.from(Array(10).keys());
var mnemonic = "test test test test test test test test test test test junk";
var testAccounts = (
  /**
   * @type {[import("viem").HDAccount, import("viem").HDAccount,import("viem").HDAccount, import("viem").HDAccount,import("viem").HDAccount, import("viem").HDAccount,import("viem").HDAccount, import("viem").HDAccount,import("viem").HDAccount, import("viem").HDAccount]}
   */
  oneToTen.map((i) => mnemonicToAccount(mnemonic, { addressIndex: i }))
);

// src/tevmViemExtension.js
var formatBlockTag = (blockTag) => {
  if (blockTag === void 0) {
    return "pending";
  }
  if (typeof blockTag === "bigint") {
    return numberToHex(blockTag);
  }
  return blockTag;
};
var tevmViemExtension = () => {
  return (client) => {
    const formatResult = (response) => {
      if ("error" in response) {
        return {
          errors: [
            {
              _tag: response.error.code,
              name: response.error.code,
              message: response.error.message
            }
          ]
        };
      }
      return response.result;
    };
    const request = async (req) => {
      try {
        const result = await client.request(
          /** @type any*/
          req
        );
        return (
          /** @type any */
          {
            jsonrpc: "2.0",
            method: req.method,
            ...req.id ? { id: req.id } : {},
            result
          }
        );
      } catch (e) {
        return (
          /** @type any*/
          {
            jsonrpc: "2.0",
            ...req.id ? { id: req.id } : {},
            method: req.method,
            error: {
              code: (
                /** @type Error */
                e.name
              ),
              message: (
                /** @type {Error}*/
                e.message
              )
            },
            errors: [
              {
                _tag: (
                  /** @type Error */
                  e.name
                ),
                message: (
                  /** @type {Error}*/
                  e.message
                ),
                name: (
                  /** @type {Error}*/
                  e.name
                )
              }
            ]
          }
        );
      }
    };
    const requestBulk = async () => {
      throw new Error("Bulk json rpc requests are not yet implemented");
    };
    const getAccount = async (params) => {
      return formatResult(
        await request({
          method: "tevm_setAccount",
          jsonrpc: "2.0",
          params: [params]
        })
      );
    };
    const setAccount = async (params) => {
      return formatResult(
        await request({
          method: "tevm_setAccount",
          jsonrpc: "2.0",
          params: [
            {
              address: params.address,
              ...params.balance ? { balance: numberToHex(params.balance) } : {},
              ...params.nonce ? { nonce: numberToHex(params.nonce) } : {},
              ...params.storageRoot ? { storageRoot: params.storageRoot } : {},
              ...params.deployedBytecode ? { deployedBytecode: params.deployedBytecode } : {}
            }
          ]
        })
      );
    };
    const getCallArgs = (params) => {
      return {
        ...params.code ? { code: params.code } : {},
        ...params.blobVersionedHashes ? { blobVersionedHashes: params.blobVersionedHashes } : {},
        ...params.caller ? { caller: params.caller } : {},
        ..."data" in params && params.data ? { data: params.data } : {},
        ...params.depth ? { depth: params.depth } : {},
        ...params.gas ? { gas: numberToHex(params.gas) } : {},
        ...params.gasPrice ? { gasPrice: numberToHex(params.gasPrice) } : {},
        ...params.gasRefund ? { gasRefund: numberToHex(params.gasRefund) } : {},
        ...params.origin ? { origin: params.origin } : {},
        ..."salt" in params && params.salt ? { salt: params.salt } : {},
        ...params.selfdestruct ? { selfdestruct: [...params.selfdestruct] } : {},
        ...params.skipBalance ? { skipBalance: params.skipBalance } : {},
        ...params.blockTag ? { blockTag: formatBlockTag(params.blockTag) } : {},
        ...params.to ? { to: params.to } : {},
        ...params.value ? { value: numberToHex(params.value) } : {}
      };
    };
    const call = async (params) => {
      const response = await request({
        method: "tevm_call",
        jsonrpc: "2.0",
        params: [getCallArgs(params)]
      });
      if ("error" in response) {
        return (
          /** @type any*/
          {
            errors: [
              {
                _tag: response.error.code,
                message: response.error.message,
                name: response.error.code
              }
            ]
          }
        );
      }
      return parseCallResponse(response);
    };
    const parseCallResponse = (response) => {
      if ("error" in response) {
        console.error(response.error);
        throw new Error("No result in response");
      }
      const { result } = response;
      return {
        executionGasUsed: hexToBigInt(result.executionGasUsed),
        rawData: result.rawData,
        ...result.selfdestruct ? { selfdestruct: new Set(result.selfdestruct) } : {},
        ...result.gasRefund ? { gasRefund: hexToBigInt(result.gasRefund) } : {},
        ...result.gas ? { gas: hexToBigInt(result.gas) } : {},
        ...result.logs ? { logs: result.logs } : {},
        ...result.blobGasUsed ? { blobGasUsed: hexToBigInt(result.blobGasUsed) } : {},
        ...result.createdAddress ? { createdAddress: result.createdAddress } : {},
        ...result.createdAddresses ? { createdAddresses: new Set(result.createdAddresses) } : {}
      };
    };
    const contract = async (params) => {
      const out = await call({
        ...params,
        data: encodeFunctionData(
          /** @type any*/
          {
            abi: params.abi,
            functionName: params.functionName,
            args: params.args
          }
        )
      });
      let data;
      try {
        data = decodeFunctionResult(
          /** @type any*/
          {
            data: out.rawData,
            abi: params.abi,
            functionName: params.functionName,
            args: params.args
          }
        );
      } catch (e) {
        if (out.rawData === "0x") {
          console.error("UnexpectedError: data is 0x");
        }
        throw e;
      }
      return (
        /** @type any*/
        {
          ...out,
          rawData: out.rawData,
          data: (
            /**@type any*/
            data
          )
        }
      );
    };
    const blockNumber = async () => {
      return hexToBigInt(
        formatResult(
          await request({
            method: "eth_blockNumber",
            jsonrpc: "2.0",
            params: []
          })
        )
      );
    };
    const ethCall = async ({ blockTag = "latest", to, gas, data, from = `0x${"0".repeat(40)}`, value, gasPrice: gasPrice2 }) => {
      return (
        /** @type {any} */
        formatResult(
          await request({
            method: "eth_call",
            jsonrpc: "2.0",
            params: [
              {
                from,
                ...gas ? { gas: numberToHex(gas) } : {},
                ...gasPrice2 ? { gasPrice: numberToHex(gasPrice2) } : {},
                ...to ? { to } : {},
                ...value ? { value: numberToHex(value) } : {},
                ...data ? { data } : {}
              },
              formatBlockTag(blockTag)
            ]
          })
        )
      );
    };
    const dumpState = async () => {
      return (
        /** @type {any} */
        formatResult(
          await request({
            method: "tevm_dumpState",
            jsonrpc: "2.0",
            params: []
          })
        )
      );
    };
    const chainId = async () => {
      return hexToBigInt(
        formatResult(
          await request({
            method: "eth_chainId",
            jsonrpc: "2.0",
            params: []
          })
        )
      );
    };
    const loadState = async (params) => {
      return (
        /** @type {any} */
        formatResult(
          await request({
            method: "tevm_loadState",
            jsonrpc: "2.0",
            params: [{ state: params.state }]
          })
        )
      );
    };
    const gasPrice = async () => {
      return hexToBigInt(
        formatResult(
          await request({
            method: "eth_gasPrice",
            jsonrpc: "2.0",
            params: []
          })
        )
      );
    };
    const getBalance = async (params) => {
      return hexToBigInt(
        formatResult(
          await request({
            method: "eth_getBalance",
            jsonrpc: "2.0",
            params: [params.address, formatBlockTag(params.blockTag)]
          })
        )
      );
    };
    const getCode = async (params) => {
      return (
        /** @type {any} */
        formatResult(
          await request({
            method: "eth_getCode",
            jsonrpc: "2.0",
            params: [params.address, formatBlockTag(params.blockTag)]
          })
        )
      );
    };
    const getStorageAt = async (params) => {
      return (
        /** @type {any} */
        formatResult(
          await request({
            method: "eth_getStorageAt",
            jsonrpc: "2.0",
            params: [params.address, params.position, formatBlockTag(params.blockTag)]
          })
        )
      );
    };
    return {
      tevm: {
        eth: {
          call: ethCall,
          blockNumber,
          chainId,
          gasPrice,
          getBalance,
          getCode,
          getStorageAt
        },
        accounts: testAccounts,
        request,
        requestBulk,
        getAccount,
        setAccount,
        call,
        contract,
        dumpState,
        loadState
      }
    };
  };
};
var tevmViemExtensionOptimistic = () => {
  const decorator = (client) => {
    const tevmClient = tevmViemExtension()(client);
    const writeContractOptimistic = async function* (action) {
      const errors = [];
      const getErrorsIfExist = () => errors.length > 0 ? { errors } : {};
      const writeContractResult = client.writeContract(
        /** @type any*/
        action
      );
      const optimisticResult = client.request({
        jsonrpc: "2.0",
        method: (
          /** @type {any}*/
          "tevm_contract"
        ),
        params: (
          /** @type {any}*/
          action
        )
      });
      try {
        yield {
          success: true,
          tag: "OPTIMISTIC_RESULT",
          data: (
            /** @type {any} */
            await optimisticResult
          ),
          ...getErrorsIfExist()
        };
      } catch (error) {
        errors.push(
          /** @type {any}*/
          error
        );
        yield {
          success: false,
          tag: "OPTIMISTIC_RESULT",
          error: (
            /** @type {any} */
            error
          ),
          ...getErrorsIfExist()
        };
      }
      let hash;
      try {
        hash = await writeContractResult;
        yield {
          success: true,
          tag: "HASH",
          data: (
            /** @type {any}*/
            hash
          ),
          ...getErrorsIfExist()
        };
      } catch (error) {
        errors.push(
          /** @type {any}*/
          error
        );
        yield {
          success: false,
          tag: "HASH",
          error: (
            /** @type {any}*/
            error
          ),
          ...getErrorsIfExist()
        };
      }
      if (hash) {
        try {
          const receipt = await waitForTransactionReceipt(
            /** @type{any}*/
            client,
            { hash }
          );
          yield {
            success: true,
            tag: "RECEIPT",
            data: (
              /** @type {any} */
              receipt
            ),
            ...getErrorsIfExist()
          };
        } catch (error) {
          errors.push(
            /** @type {any}*/
            error
          );
          yield {
            success: false,
            tag: "RECEIPT",
            error: (
              /** @type {any} */
              error
            ),
            errors,
            ...getErrorsIfExist()
          };
        }
      }
      return;
    };
    return {
      ...tevmClient,
      tevm: {
        ...tevmClient.tevm,
        writeContractOptimistic: (
          /** @type any */
          writeContractOptimistic
        )
      }
    };
  };
  return decorator;
};

export { tevmTransport, tevmViemExtension, tevmViemExtensionOptimistic };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map