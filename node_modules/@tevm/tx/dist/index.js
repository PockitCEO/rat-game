import { FeeMarket1559Tx } from '@ethereumjs/tx';
export { AccessList2930Tx as AccessListEIP2930Transaction, Blob4844Tx as BlobEIP4844Transaction, Capability, FeeMarket1559Tx as FeeMarketEIP1559Transaction, LegacyTx as LegacyTransaction, createTx as TransactionFactory, TransactionType, createTxFromBlockBodyData, createTxFromRLP, isAccessList2930Tx as isAccessListEIP2930Tx, isBlob4844Tx as isBlobEIP4844Tx, isFeeMarket1559Tx as isFeeMarketEIP1559Tx, isLegacyTx } from '@ethereumjs/tx';
import { InternalError, InvalidGasLimitError } from '@tevm/errors';
import { keccak256 } from '@tevm/utils';

// src/index.ts
var createImpersonatedTx = (txData, opts) => {
  let tx;
  try {
    tx = new FeeMarket1559Tx(txData, opts);
  } catch (e) {
    if (!(e instanceof Error)) {
      throw new InternalError("Unknown Error", { cause: (
        /** @type any*/
        e
      ) });
    }
    if (e.message.includes("EIP-1559 not enabled on Common")) {
      throw new InternalError(
        "EIP-1559 is not enabled on Common. Tevm currently only supports 1559 and it should be enabled by default",
        { cause: e }
      );
    }
    if (e.message.includes("gasLimit cannot exceed MAX_UINT64 (2^64-1)") || e.message.includes("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)")) {
      throw new InvalidGasLimitError(e.message, { cause: e });
    }
    if (e.message.includes(
      "maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)"
    )) {
      throw new InvalidGasLimitError(e.message, { cause: e });
    }
    throw new InternalError(e.message, { cause: e });
  }
  return (
    /** @type {import('./ImpersonatedTx.js').ImpersonatedTx}*/
    new Proxy(tx, {
      get(target, prop) {
        if (prop === "isImpersonated") {
          return true;
        }
        if (prop === "hash") {
          return () => {
            try {
              return target.hash();
            } catch (_e) {
              return keccak256(target.getHashedMessageToSign(), "bytes");
            }
          };
        }
        if (prop === "isSigned") {
          return () => true;
        }
        if (prop === "getSenderAddress") {
          return () => txData.impersonatedAddress;
        }
        return Reflect.get(target, prop);
      }
    })
  );
};

export { createImpersonatedTx };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map