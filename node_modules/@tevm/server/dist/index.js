import { tevmSend } from '@tevm/decorators';
import { BaseError, InvalidRequestError, InternalError, UnsupportedProviderMethodError, MethodNotFoundError } from '@tevm/errors';
import { z, treeifyError } from 'zod';
import { createServer as createServer$1 } from 'http';

// src/createHttpHandler.js
var InvalidJsonError = class extends BaseError {
  /**
   * Constructs an InvalidJsonError.
   *
   * @param {string} message - Human-readable error message.
   * @param {InvalidJsonErrorParameters} [args={}] - Additional parameters for the InvalidJsonError.
   */
  constructor(message, args = {}) {
    super(
      message,
      {
        ...args,
        docsBaseUrl: "https://tevm.sh",
        docsPath: "/reference/tevm/errors/classes/invalidjsonerror/"
      },
      "InvalidJsonError",
      -32700
    );
  }
};
var ReadRequestBodyError = class extends BaseError {
  /**
   * Constructs a ReadRequestBodyError.
   *
   * @param {string} message - Human-readable error message.
   * @param {ReadRequestBodyErrorParameters} [args={}] - Additional parameters for the ReadRequestBodyError.
   */
  constructor(message, args = {}) {
    super(
      message,
      {
        ...args,
        docsBaseUrl: "https://tevm.sh",
        docsPath: "/reference/tevm/errors/classes/readrequestbodyerror/"
      },
      "ReadRequestBodyError"
    );
  }
};

// src/internal/getRequestBody.js
var getRequestBody = (req) => {
  if ("body" in req && req.body !== void 0) {
    return Promise.resolve(req.body);
  }
  return new Promise((resolve) => {
    let body = "";
    if ("on" in req) {
      req.on("error", (err) => {
        resolve(new ReadRequestBodyError(err.message, { cause: err }));
      });
      req.on("data", (chunk) => {
        body += chunk.toString();
      });
      req.on("end", () => {
        return resolve(body);
      });
    } else {
      resolve(new ReadRequestBodyError("Request object is not a valid stream", {}));
    }
  });
};
var handleBulkRequest = async (client, requests) => {
  const { send } = client.transport.tevm.extend(tevmSend());
  const responses = await Promise.allSettled(
    requests.map((request) => {
      return send(
        /** @type any*/
        request
      );
    })
  );
  return responses.map((response, i) => {
    const request = (
      /** @type {import("@tevm/jsonrpc").JsonRpcRequest<string, object>} */
      requests[i]
    );
    if (response.status === "rejected") {
      client.transport.tevm.logger.error(response.reason);
      const err = new InternalError(request.method, { cause: response.reason });
      return {
        ...request.id !== void 0 ? { id: request.id } : {},
        method: request.method,
        jsonrpc: "2.0",
        error: {
          code: err.code,
          message: err.message
        }
      };
    }
    return response.value;
  });
};

// src/internal/handleError.js
var handleError = (client, error, res, jsonRpcReq = { method: "unknown" }) => {
  client.transport.tevm.logger.error(error);
  res.writeHead(400, { "Content-Type": "application/json" });
  res.end(
    JSON.stringify({
      ...jsonRpcReq.id ? { id: jsonRpcReq.id } : {},
      method: jsonRpcReq.method,
      jsonrpc: "2.0",
      error: {
        code: error.code,
        message: error.message
      }
    })
  );
};
var zJsonRpcRequest = z.object({
  jsonrpc: z.literal("2.0").optional(),
  id: z.union([z.string(), z.number(), z.null()]).optional(),
  method: z.string(),
  params: z.unknown().optional()
});
var zBulkRequest = z.array(zJsonRpcRequest);
var parseRequest = (body) => {
  let raw;
  try {
    raw = JSON.parse(body);
  } catch (e) {
    const err = (
      /** @type {Error} */
      e
    );
    return new InvalidJsonError(err.message, { cause: err });
  }
  if (Array.isArray(raw)) {
    const parsedRequest = zBulkRequest.safeParse(raw);
    if (!parsedRequest.success) {
      return new InvalidRequestError(JSON.stringify(treeifyError(parsedRequest.error)));
    }
    return parsedRequest.data;
  } else {
    const parsedRequest = zJsonRpcRequest.safeParse(raw);
    if (!parsedRequest.success) {
      return new InvalidRequestError(JSON.stringify(treeifyError(parsedRequest.error)));
    }
    return parsedRequest.data;
  }
};

// src/createHttpHandler.js
var createHttpHandler = (client) => {
  return async (req, res) => {
    var _a, _b;
    const body = await getRequestBody(req);
    if (body instanceof ReadRequestBodyError) {
      return handleError(client, body, res);
    }
    const parsedRequest = parseRequest(body);
    if (parsedRequest instanceof InvalidJsonError || parsedRequest instanceof InvalidRequestError) {
      return handleError(client, parsedRequest, res);
    }
    if (Array.isArray(parsedRequest)) {
      const responses = await handleBulkRequest(
        client,
        /** @type {any}*/
        parsedRequest
      );
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify(responses));
      return;
    }
    const response = await client.transport.tevm.extend(tevmSend()).send(
      /** @type any*/
      parsedRequest
    ).catch((e) => {
      console.log("e", e);
      return "code" in e ? e : new InternalError("Unexpeced error", { cause: e });
    });
    if ("code" in response && "message" in response) {
      return handleError(client, response, res, parsedRequest);
    }
    if (((_a = response.error) == null ? void 0 : _a.code) === UnsupportedProviderMethodError.code || ((_b = response.error) == null ? void 0 : _b.code) === MethodNotFoundError.code) {
      return handleError(client, response.error, res, parsedRequest);
    }
    console.log("response", response);
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify(response));
    return;
  };
};

// src/adapters/createExpressMiddleware.js
function createExpressMiddleware(client) {
  const handler = createHttpHandler(client);
  return async (req, res) => {
    handler(req, res);
  };
}

// src/adapters/createNextApiHandler.js
var createNextApiHandler = (client) => {
  const handler = createHttpHandler(client);
  return async (req, res) => {
    handler(req, res);
  };
};
var createServer = (client, serverOptions = {}) => {
  return createServer$1(serverOptions, createHttpHandler(client));
};

export { InvalidJsonError, ReadRequestBodyError, createExpressMiddleware, createHttpHandler, createNextApiHandler, createServer };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map