import { EvmError } from '@tevm/evm';
import { decodeFunctionData, hexToBytes, encodeFunctionResult, toBytes, encodeEventTopics, encodeAbiParameters, createAddressFromString, toHex } from '@tevm/utils';
import { p256 } from '@noble/curves/nist.js';
import { createAddress } from '@tevm/address';

// src/defineCall.ts
var logToEthjsLog = (abi, log) => {
  const topics = encodeEventTopics({
    abi,
    eventName: log.eventName,
    args: log.args
  }).map((topics2) => hexToBytes(topics2));
  const eventItem = abi.find((item) => item.type === "event" && item.name === log.eventName);
  const inputs = eventItem.inputs ?? [];
  const argsArray = Array.isArray(log.args) ? log.args : Object.values(log.args ?? {}).length > 0 ? inputs?.map((x) => log.args[x.name]) ?? [] : [];
  const nonIndexedArgs = argsArray.filter((_, index) => !eventItem.inputs[index]?.indexed);
  const data = encodeAbiParameters(
    inputs.filter((input) => !input.indexed),
    nonIndexedArgs
  );
  return [hexToBytes(log.address), topics, hexToBytes(data)];
};

// src/defineCall.ts
var defineCall = (abi, handlers) => {
  return async ({ data, gasLimit }) => {
    const d = decodeFunctionData({
      abi,
      data
    });
    const handler = handlers[d.functionName];
    try {
      const { returnValue, executionGasUsed, logs, error, blobGasUsed, selfdestruct } = await handler({
        gasLimit,
        args: d.args
      });
      return {
        executionGasUsed,
        ...error ? { exeptionError: error } : {},
        ...selfdestruct ? { selfdestruct } : {},
        ...blobGasUsed ? { blobGasUsed } : {},
        ...logs ? (
          // This logs part of the ternary is not covered
          {
            logs: logs.map((logs2) => logToEthjsLog(abi, logs2))
          }
        ) : {},
        returnValue: hexToBytes(
          encodeFunctionResult({
            abi,
            functionName: d.functionName,
            result: returnValue
          })
        )
      };
    } catch (e) {
      return {
        executionGasUsed: BigInt(0),
        returnValue: new Uint8Array(),
        exceptionError: {
          ...new EvmError("revert"),
          ...{
            message: typeof e === "string" ? e : e instanceof Error ? e.message : "unknown error"
          }
        }
      };
    }
  };
};
var Precompile = class {
  constructor(contract, call) {
    this.contract = contract;
    this.call = call;
  }
  ethjsAddress = () => createAddressFromString(this.contract.address);
  precompile = () => ({
    address: this.ethjsAddress(),
    function: (params) => {
      return this.call({ data: toHex(params.data), gasLimit: params.gasLimit });
    }
  });
};

// src/definePrecompile.ts
var definePrecompile = ({
  contract,
  call
}) => {
  return new Precompile(contract, call);
};
var P256_VERIFY_GAS_COST = 3450n;
var P256_VERIFY_ADDRESS = createAddress("0x0000000000000000000000000000000000000100");
var p256VerifyPrecompile = () => {
  return {
    address: P256_VERIFY_ADDRESS,
    function: (input) => {
      const executionGasUsed = P256_VERIFY_GAS_COST;
      if (input.data.length !== 160) {
        return {
          returnValue: toBytes(0, { size: 32 }),
          executionGasUsed
        };
      }
      try {
        const r = input.data.slice(0, 32);
        const s = input.data.slice(32, 64);
        const x = input.data.slice(64, 96);
        const y = input.data.slice(96, 128);
        const msgHash = input.data.slice(128, 160);
        const signature = new Uint8Array(64);
        signature.set(r, 0);
        signature.set(s, 32);
        const publicKey = new Uint8Array(65);
        publicKey[0] = 4;
        publicKey.set(x, 1);
        publicKey.set(y, 33);
        const isValid = p256.verify(signature, msgHash, publicKey, { prehash: false });
        if (isValid) {
          return {
            returnValue: toBytes(1, { size: 32 }),
            executionGasUsed
          };
        }
        return {
          returnValue: toBytes(0, { size: 32 }),
          executionGasUsed
        };
      } catch (_error) {
        return {
          returnValue: toBytes(0, { size: 32 }),
          executionGasUsed
        };
      }
    }
  };
};

export { P256_VERIFY_ADDRESS, P256_VERIFY_GAS_COST, defineCall, definePrecompile, p256VerifyPrecompile };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map