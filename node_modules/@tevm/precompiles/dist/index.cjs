'use strict';

var evm = require('@tevm/evm');
var utils = require('@tevm/utils');
var nist_js = require('@noble/curves/nist.js');
var address = require('@tevm/address');

// src/defineCall.ts
var logToEthjsLog = (abi, log) => {
  const topics = utils.encodeEventTopics({
    abi,
    eventName: log.eventName,
    args: log.args
  }).map((topics2) => utils.hexToBytes(topics2));
  const eventItem = abi.find((item) => item.type === "event" && item.name === log.eventName);
  const inputs = eventItem.inputs ?? [];
  const argsArray = Array.isArray(log.args) ? log.args : Object.values(log.args ?? {}).length > 0 ? inputs?.map((x) => log.args[x.name]) ?? [] : [];
  const nonIndexedArgs = argsArray.filter((_, index) => !eventItem.inputs[index]?.indexed);
  const data = utils.encodeAbiParameters(
    inputs.filter((input) => !input.indexed),
    nonIndexedArgs
  );
  return [utils.hexToBytes(log.address), topics, utils.hexToBytes(data)];
};

// src/defineCall.ts
var defineCall = (abi, handlers) => {
  return async ({ data, gasLimit }) => {
    const d = utils.decodeFunctionData({
      abi,
      data
    });
    const handler = handlers[d.functionName];
    try {
      const { returnValue, executionGasUsed, logs, error, blobGasUsed, selfdestruct } = await handler({
        gasLimit,
        args: d.args
      });
      return {
        executionGasUsed,
        ...error ? { exeptionError: error } : {},
        ...selfdestruct ? { selfdestruct } : {},
        ...blobGasUsed ? { blobGasUsed } : {},
        ...logs ? (
          // This logs part of the ternary is not covered
          {
            logs: logs.map((logs2) => logToEthjsLog(abi, logs2))
          }
        ) : {},
        returnValue: utils.hexToBytes(
          utils.encodeFunctionResult({
            abi,
            functionName: d.functionName,
            result: returnValue
          })
        )
      };
    } catch (e) {
      return {
        executionGasUsed: BigInt(0),
        returnValue: new Uint8Array(),
        exceptionError: {
          ...new evm.EvmError("revert"),
          ...{
            message: typeof e === "string" ? e : e instanceof Error ? e.message : "unknown error"
          }
        }
      };
    }
  };
};
var Precompile = class {
  constructor(contract, call) {
    this.contract = contract;
    this.call = call;
  }
  ethjsAddress = () => utils.createAddressFromString(this.contract.address);
  precompile = () => ({
    address: this.ethjsAddress(),
    function: (params) => {
      return this.call({ data: utils.toHex(params.data), gasLimit: params.gasLimit });
    }
  });
};

// src/definePrecompile.ts
var definePrecompile = ({
  contract,
  call
}) => {
  return new Precompile(contract, call);
};
var P256_VERIFY_GAS_COST = 3450n;
var P256_VERIFY_ADDRESS = address.createAddress("0x0000000000000000000000000000000000000100");
var p256VerifyPrecompile = () => {
  return {
    address: P256_VERIFY_ADDRESS,
    function: (input) => {
      const executionGasUsed = P256_VERIFY_GAS_COST;
      if (input.data.length !== 160) {
        return {
          returnValue: utils.toBytes(0, { size: 32 }),
          executionGasUsed
        };
      }
      try {
        const r = input.data.slice(0, 32);
        const s = input.data.slice(32, 64);
        const x = input.data.slice(64, 96);
        const y = input.data.slice(96, 128);
        const msgHash = input.data.slice(128, 160);
        const signature = new Uint8Array(64);
        signature.set(r, 0);
        signature.set(s, 32);
        const publicKey = new Uint8Array(65);
        publicKey[0] = 4;
        publicKey.set(x, 1);
        publicKey.set(y, 33);
        const isValid = nist_js.p256.verify(signature, msgHash, publicKey, { prehash: false });
        if (isValid) {
          return {
            returnValue: utils.toBytes(1, { size: 32 }),
            executionGasUsed
          };
        }
        return {
          returnValue: utils.toBytes(0, { size: 32 }),
          executionGasUsed
        };
      } catch (_error) {
        return {
          returnValue: utils.toBytes(0, { size: 32 }),
          executionGasUsed
        };
      }
    }
  };
};

exports.P256_VERIFY_ADDRESS = P256_VERIFY_ADDRESS;
exports.P256_VERIFY_GAS_COST = P256_VERIFY_GAS_COST;
exports.defineCall = defineCall;
exports.definePrecompile = definePrecompile;
exports.p256VerifyPrecompile = p256VerifyPrecompile;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map