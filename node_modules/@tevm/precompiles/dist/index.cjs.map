{"version":3,"sources":["../src/logToEthjsLog.ts","../src/defineCall.ts","../src/Precompile.ts","../src/definePrecompile.ts","../src/p256verify.precompile.ts"],"names":["encodeEventTopics","topics","hexToBytes","encodeAbiParameters","decodeFunctionData","logs","encodeFunctionResult","EvmError","createAddressFromString","toHex","createAddress","toBytes","p256"],"mappings":"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","file":"index.cjs","sourcesContent":["import {\n\ttype Abi,\n\ttype AbiEvent,\n\ttype Address,\n\ttype EncodeEventTopicsParameters,\n\ttype EthjsLog,\n\tencodeAbiParameters,\n\tencodeEventTopics,\n\thexToBytes,\n} from '@tevm/utils'\nimport type { ContractEventName } from './CallResult.js'\n\n/**\n * Converts log arguments with abi to ethjs log format\n * @internal\n */\nexport const logToEthjsLog = <TAbi extends Abi>(\n\tabi: TAbi,\n\tlog: {\n\t\targs: EncodeEventTopicsParameters<TAbi, ContractEventName<TAbi>>['args']\n\t\teventName: EncodeEventTopicsParameters<TAbi, ContractEventName<TAbi>>['eventName']\n\t\taddress: Address\n\t},\n): EthjsLog => {\n\tconst topics = encodeEventTopics({\n\t\tabi,\n\t\teventName: log.eventName,\n\t\targs: log.args,\n\t} as any).map((topics) => hexToBytes(topics as `0x${string}`))\n\tconst eventItem = abi.find((item) => item.type === 'event' && item.name === log.eventName) as AbiEvent\n\tconst inputs = eventItem.inputs ?? []\n\tconst argsArray = Array.isArray(log.args)\n\t\t? log.args\n\t\t: Object.values(log.args ?? {}).length > 0\n\t\t\t? (inputs?.map((x: any) => (log.args as any)[x.name]) ?? [])\n\t\t\t: []\n\n\tconst nonIndexedArgs = argsArray.filter((_, index) => !eventItem.inputs[index]?.indexed)\n\n\tconst data = encodeAbiParameters(\n\t\tinputs.filter((input) => !input.indexed),\n\t\tnonIndexedArgs,\n\t)\n\treturn [hexToBytes(log.address), topics, hexToBytes(data)]\n}\n","import { EvmError, type ExecResult } from '@tevm/evm'\nimport {\n\ttype Abi,\n\ttype AbiParametersToPrimitiveTypes,\n\tdecodeFunctionData,\n\ttype ExtractAbiFunction,\n\ttype ExtractAbiFunctionNames,\n\tencodeFunctionResult,\n\thexToBytes,\n} from '@tevm/utils'\nimport type { CallResult } from './CallResult.js'\nimport { logToEthjsLog } from './logToEthjsLog.js'\n\ntype Handler<TAbi extends Abi, TFunctionName extends ExtractAbiFunctionNames<TAbi>> = (params: {\n\tgasLimit: bigint\n\targs: AbiParametersToPrimitiveTypes<ExtractAbiFunction<TAbi, TFunctionName>['inputs']>\n}) => Promise<CallResult<TAbi, TFunctionName>>\n\n/**\n * Defines a call handler for a contract precompile by mapping function names to handler implementations.\n *\n * The defineCall function takes an ABI and a map of function names to handler implementations.\n * Each handler receives the decoded function arguments and gas limit, and returns a result\n * that will be encoded according to the ABI.\n *\n * @example\n * ```js\n * import { defineCall } from '@tevm/precompiles'\n * import { parseAbi } from '@tevm/utils'\n *\n * const abi = parseAbi([\n *   'function readFile(string path) view returns (string)',\n *   'function writeFile(string path, string content) returns (bool)'\n * ])\n *\n * const fsCall = defineCall(abi, {\n *   readFile: async ({ args }) => {\n *     const [path] = args\n *     return {\n *       returnValue: await fs.readFile(path, 'utf8'),\n *       executionGasUsed: 0n\n *     }\n *   },\n *   writeFile: async ({ args }) => {\n *     const [path, content] = args\n *     await fs.writeFile(path, content)\n *     return {\n *       returnValue: true,\n *       executionGasUsed: 0n\n *     }\n *   }\n * })\n * ```\n */\nexport const defineCall = <TAbi extends Abi>(\n\tabi: TAbi,\n\thandlers: {\n\t\t[TFunctionName in ExtractAbiFunctionNames<TAbi>]: Handler<TAbi, TFunctionName>\n\t},\n) => {\n\treturn async ({ data, gasLimit }: { data: `0x${string}`; gasLimit: bigint }): Promise<ExecResult> => {\n\t\tconst d = decodeFunctionData({\n\t\t\tabi: abi,\n\t\t\tdata: data,\n\t\t})\n\t\tconst handler = handlers[d.functionName]\n\t\ttry {\n\t\t\tconst { returnValue, executionGasUsed, logs, error, blobGasUsed, selfdestruct } = await handler({\n\t\t\t\tgasLimit: gasLimit,\n\t\t\t\targs: d.args as any,\n\t\t\t})\n\t\t\treturn {\n\t\t\t\texecutionGasUsed,\n\t\t\t\t...(error ? { exeptionError: error } : {}),\n\t\t\t\t...(selfdestruct ? { selfdestruct } : {}),\n\t\t\t\t...(blobGasUsed ? { blobGasUsed } : {}),\n\t\t\t\t...(logs\n\t\t\t\t\t? // This logs part of the ternary is not covered\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogs: logs.map((logs) => logToEthjsLog(abi, logs)),\n\t\t\t\t\t\t}\n\t\t\t\t\t: {}),\n\t\t\t\treturnValue: hexToBytes(\n\t\t\t\t\tencodeFunctionResult({\n\t\t\t\t\t\tabi: abi,\n\t\t\t\t\t\tfunctionName: d.functionName as any,\n\t\t\t\t\t\tresult: returnValue as any,\n\t\t\t\t\t} as any),\n\t\t\t\t),\n\t\t\t}\n\t\t\t// This entire catch block is not covered\n\t\t} catch (e) {\n\t\t\treturn {\n\t\t\t\texecutionGasUsed: BigInt(0),\n\t\t\t\treturnValue: new Uint8Array(),\n\t\t\t\texceptionError: {\n\t\t\t\t\t...new EvmError('revert' as any),\n\t\t\t\t\t...{\n\t\t\t\t\t\tmessage: typeof e === 'string' ? e : e instanceof Error ? e.message : 'unknown error',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n}\n","import type { Contract } from '@tevm/contract'\nimport type { ExecResult } from '@tevm/evm'\nimport { type Address, createAddressFromString, type Hex, toHex } from '@tevm/utils'\n\n/**\n * A precompile is a contract that is deployed at a specific address but runs JavaScript code instead of EVM code.\n * It is constructed via a Tevm {@link Contract} and a JavaScript function that implements the precompile.\n * @example\n * ```typescript\n * import { defineCall, definePrecompile } from '@tevm/precompiles'\n * import { Fs } from './Fs.s.sol'\n *\n * // Define a precompile\n * const fsPrecompile = definePrecompile({\n *   contract: Fs.withAddress('0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2'),\n *   call: defineCall(Fs.abi, {\n *     readFile: async ({ args }) => {\n *       return {\n *         returnValue: await fs.readFile(...args, 'utf8'),\n *         executionGasUsed: 0n,\n *       }\n *     }\n *   })\n * })\n * ```\n */\nexport class Precompile<\n\tTContract extends Contract<string, ReadonlyArray<string>, Address, any, any> = Contract<\n\t\tstring,\n\t\tReadonlyArray<string>,\n\t\tAddress,\n\t\tany,\n\t\tany\n\t>,\n> {\n\tconstructor(\n\t\t/**\n\t\t * Contract interface\n\t\t */\n\t\tpublic readonly contract: TContract,\n\t\tpublic readonly call: (context: { data: Hex; gasLimit: bigint }) => Promise<ExecResult>,\n\t) {}\n\n\tprotected readonly ethjsAddress = () => createAddressFromString(this.contract.address)\n\n\tpublic readonly precompile = () => ({\n\t\taddress: this.ethjsAddress(),\n\t\tfunction: (params: { data: Uint8Array; gasLimit: bigint }) => {\n\t\t\treturn this.call({ data: toHex(params.data), gasLimit: params.gasLimit })\n\t\t},\n\t})\n}\n","import type { Contract } from '@tevm/contract'\nimport type { ExecResult } from '@tevm/evm'\nimport type { Address, Hex } from '@tevm/utils'\nimport { Precompile } from './Precompile.js'\n\n/**\n * Defines a precompile contract that executes JavaScript code instead of EVM bytecode.\n *\n * A precompile is a special kind of contract that is deployed at a specific address\n * but executes JavaScript code rather than EVM bytecode. This allows for implementing\n * functionality that would be difficult or inefficient to implement in Solidity.\n *\n * @example\n * ```js\n * import { defineCall, definePrecompile } from '@tevm/precompiles'\n * import { Contract } from '@tevm/contract'\n * import { parseAbi } from '@tevm/utils'\n *\n * // Define a contract interface\n * const fsAbi = parseAbi([\n *   'function readFile(string path) view returns (string)',\n *   'function writeFile(string path, string content) returns (bool)'\n * ])\n *\n * const FsContract = {\n *   abi: fsAbi,\n *   address: '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2'\n * } as const\n *\n * // Create precompile with handlers\n * const fsPrecompile = definePrecompile({\n *   contract: FsContract,\n *   call: defineCall(fsAbi, {\n *     readFile: async ({ args }) => {\n *       return {\n *         returnValue: await fs.readFile(args[0], 'utf8'),\n *         executionGasUsed: 0n\n *       }\n *     },\n *     writeFile: async ({ args }) => {\n *       await fs.writeFile(args[0], args[1])\n *       return {\n *         returnValue: true,\n *         executionGasUsed: 0n\n *       }\n *     }\n *   })\n * })\n * ```\n */\nexport const definePrecompile = <\n\tTContract extends Contract<any, any, Address, any, any, any> = Contract<\n\t\tstring,\n\t\tReadonlyArray<string>,\n\t\tAddress,\n\t\tany,\n\t\tany,\n\t\tany\n\t>,\n>({\n\tcontract,\n\tcall,\n}: {\n\tcontract: TContract\n\tcall: (context: { data: Hex; gasLimit: bigint }) => Promise<ExecResult>\n}): Precompile<TContract> => {\n\treturn new Precompile(contract, call)\n}\n","import { p256 } from '@noble/curves/nist.js'\nimport { createAddress } from '@tevm/address'\nimport { toBytes } from '@tevm/utils'\n\n/**\n * RIP-7212 p256verify precompile implementation\n * @see https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md\n */\n\n/**\n * The gas cost for the p256verify precompile (RIP-7212)\n * This is a fixed cost regardless of success or failure\n */\nexport const P256_VERIFY_GAS_COST = 3450n\n\n/**\n * The address of the p256verify precompile (RIP-7212)\n */\nexport const P256_VERIFY_ADDRESS = createAddress('0x0000000000000000000000000000000000000100')\n\n/**\n * Creates the p256verify precompile as specified in RIP-7212\n * Verifies ECDSA signatures on the secp256r1 (P-256) curve\n *\n * @returns The p256verify precompile object\n */\nexport const p256VerifyPrecompile = () => {\n\treturn {\n\t\taddress: P256_VERIFY_ADDRESS,\n\t\tfunction: (input: { data: Uint8Array }) => {\n\t\t\t// Always consume the fixed gas amount\n\t\t\tconst executionGasUsed = P256_VERIFY_GAS_COST\n\n\t\t\t// Input validation: must be exactly 160 bytes\n\t\t\tif (input.data.length !== 160) {\n\t\t\t\treturn {\n\t\t\t\t\treturnValue: toBytes(0, { size: 32 }),\n\t\t\t\t\texecutionGasUsed,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Parse the 160-byte input according to RIP-7212:\n\t\t\t\t// - r: bytes 0-32\n\t\t\t\t// - s: bytes 32-64\n\t\t\t\t// - x: bytes 64-96\n\t\t\t\t// - y: bytes 96-128\n\t\t\t\t// - msgHash: bytes 128-160\n\t\t\t\tconst r = input.data.slice(0, 32)\n\t\t\t\tconst s = input.data.slice(32, 64)\n\t\t\t\tconst x = input.data.slice(64, 96)\n\t\t\t\tconst y = input.data.slice(96, 128)\n\t\t\t\tconst msgHash = input.data.slice(128, 160)\n\n\t\t\t\t// Construct the signature as a 64-byte compact (r, s) format\n\t\t\t\tconst signature = new Uint8Array(64)\n\t\t\t\tsignature.set(r, 0)\n\t\t\t\tsignature.set(s, 32)\n\n\t\t\t\t// Construct the public key as a 65-byte uncompressed key (0x04 || x || y)\n\t\t\t\tconst publicKey = new Uint8Array(65)\n\t\t\t\tpublicKey[0] = 0x04\n\t\t\t\tpublicKey.set(x, 1)\n\t\t\t\tpublicKey.set(y, 33)\n\n\t\t\t\t// Verify the signature using the noble/curves p256 implementation\n\t\t\t\t// Note: We use prehash: false because the input is already a hash (msgHash)\n\t\t\t\tconst isValid = p256.verify(signature, msgHash, publicKey, { prehash: false })\n\n\t\t\t\tif (isValid) {\n\t\t\t\t\t// Return 32-byte padded 1 for valid signature\n\t\t\t\t\treturn {\n\t\t\t\t\t\treturnValue: toBytes(1, { size: 32 }),\n\t\t\t\t\t\texecutionGasUsed,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Return 32-byte padded 0 for invalid signature\n\t\t\t\treturn {\n\t\t\t\t\treturnValue: toBytes(0, { size: 32 }),\n\t\t\t\t\texecutionGasUsed,\n\t\t\t\t}\n\t\t\t} catch (_error) {\n\t\t\t\t// Any exception during verification results in failure\n\t\t\t\treturn {\n\t\t\t\t\treturnValue: toBytes(0, { size: 32 }),\n\t\t\t\t\texecutionGasUsed,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n}\n"]}