import * as _tevm_utils from '@tevm/utils';
import { Abi, AbiParametersToPrimitiveTypes, ExtractAbiFunction, EncodeEventTopicsParameters, ExtractAbiEventNames, Address, ExtractAbiFunctionNames, Hex } from '@tevm/utils';
import { ExecResult } from '@tevm/evm';
export { CustomPrecompile } from '@tevm/evm';
import { Contract } from '@tevm/contract';
import * as viem from 'viem';
import * as _tevm_address from '@tevm/address';

/**
 * Represents a typed error with a tag for identification
 * @template TName The string literal type that identifies this error
 * @example
 * ```typescript
 * import { TypedError } from '@tevm/precompiles'
 *
 * type MyCustomError = TypedError<'MyCustomError'>
 *
 * const error: MyCustomError = {
 *   _tag: 'MyCustomError',
 *   name: 'MyCustomError',
 *   message: 'Something went wrong'
 * }
 * ```
 */
type TypedError<TName extends string> = {
    _tag: TName;
    name: TName;
    message: string;
};

/**
 * Infers the event type from an abi
 */
type ContractEventName<TAbi extends Abi | readonly unknown[] = Abi> = ExtractAbiEventNames<TAbi extends Abi ? TAbi : Abi> extends infer TEventName extends string ? [TEventName] extends [never] ? string : TEventName : string;
/**
 * A result of a precompile javascript call
 */
type CallResult<TAbi extends Abi, TFunctionName extends string> = {
    /**
     * The amount of gas used during execution.
     */
    executionGasUsed: bigint;
    /**
     * The return value of the call. Required even on exceptions
     */
    returnValue: AbiParametersToPrimitiveTypes<ExtractAbiFunction<TAbi, TFunctionName>['outputs']>[0];
    /**
     * Any Error thrown during execution
     */
    error?: TypedError<string>;
    /**
     * Logs emitted during contract execution.
     * Logs must match the interface of the ABI
     */
    logs?: ReadonlyArray<{
        args: EncodeEventTopicsParameters<TAbi, ContractEventName<TAbi>>['args'];
        eventName: EncodeEventTopicsParameters<TAbi, ContractEventName<TAbi>>['eventName'];
        address: Address;
    }>;
    /**
     * A set of accounts to selfdestruct
     */
    selfdestruct?: Set<Address>;
    /**
     * Amount of blob gas consumed by the transaction
     */
    blobGasUsed?: bigint;
};

/**
 * Infers the the first argument of a class
 */
type ConstructorArgument<T> = T extends new (...args: infer P) => any ? P[0] : never;

type Handler<TAbi extends Abi, TFunctionName extends ExtractAbiFunctionNames<TAbi>> = (params: {
    gasLimit: bigint;
    args: AbiParametersToPrimitiveTypes<ExtractAbiFunction<TAbi, TFunctionName>['inputs']>;
}) => Promise<CallResult<TAbi, TFunctionName>>;
/**
 * Defines a call handler for a contract precompile by mapping function names to handler implementations.
 *
 * The defineCall function takes an ABI and a map of function names to handler implementations.
 * Each handler receives the decoded function arguments and gas limit, and returns a result
 * that will be encoded according to the ABI.
 *
 * @example
 * ```js
 * import { defineCall } from '@tevm/precompiles'
 * import { parseAbi } from '@tevm/utils'
 *
 * const abi = parseAbi([
 *   'function readFile(string path) view returns (string)',
 *   'function writeFile(string path, string content) returns (bool)'
 * ])
 *
 * const fsCall = defineCall(abi, {
 *   readFile: async ({ args }) => {
 *     const [path] = args
 *     return {
 *       returnValue: await fs.readFile(path, 'utf8'),
 *       executionGasUsed: 0n
 *     }
 *   },
 *   writeFile: async ({ args }) => {
 *     const [path, content] = args
 *     await fs.writeFile(path, content)
 *     return {
 *       returnValue: true,
 *       executionGasUsed: 0n
 *     }
 *   }
 * })
 * ```
 */
declare const defineCall: <TAbi extends Abi>(abi: TAbi, handlers: { [TFunctionName in ExtractAbiFunctionNames<TAbi>]: Handler<TAbi, TFunctionName>; }) => ({ data, gasLimit }: {
    data: `0x${string}`;
    gasLimit: bigint;
}) => Promise<ExecResult>;

/**
 * A precompile is a contract that is deployed at a specific address but runs JavaScript code instead of EVM code.
 * It is constructed via a Tevm {@link Contract} and a JavaScript function that implements the precompile.
 * @example
 * ```typescript
 * import { defineCall, definePrecompile } from '@tevm/precompiles'
 * import { Fs } from './Fs.s.sol'
 *
 * // Define a precompile
 * const fsPrecompile = definePrecompile({
 *   contract: Fs.withAddress('0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2'),
 *   call: defineCall(Fs.abi, {
 *     readFile: async ({ args }) => {
 *       return {
 *         returnValue: await fs.readFile(...args, 'utf8'),
 *         executionGasUsed: 0n,
 *       }
 *     }
 *   })
 * })
 * ```
 */
declare class Precompile<TContract extends Contract<string, ReadonlyArray<string>, Address, any, any> = Contract<string, ReadonlyArray<string>, Address, any, any>> {
    /**
     * Contract interface
     */
    readonly contract: TContract;
    readonly call: (context: {
        data: Hex;
        gasLimit: bigint;
    }) => Promise<ExecResult>;
    constructor(
    /**
     * Contract interface
     */
    contract: TContract, call: (context: {
        data: Hex;
        gasLimit: bigint;
    }) => Promise<ExecResult>);
    protected readonly ethjsAddress: () => _tevm_utils.EthjsAddress;
    readonly precompile: () => {
        address: _tevm_utils.EthjsAddress;
        function: (params: {
            data: Uint8Array;
            gasLimit: bigint;
        }) => Promise<ExecResult>;
    };
}

/**
 * Defines a precompile contract that executes JavaScript code instead of EVM bytecode.
 *
 * A precompile is a special kind of contract that is deployed at a specific address
 * but executes JavaScript code rather than EVM bytecode. This allows for implementing
 * functionality that would be difficult or inefficient to implement in Solidity.
 *
 * @example
 * ```js
 * import { defineCall, definePrecompile } from '@tevm/precompiles'
 * import { Contract } from '@tevm/contract'
 * import { parseAbi } from '@tevm/utils'
 *
 * // Define a contract interface
 * const fsAbi = parseAbi([
 *   'function readFile(string path) view returns (string)',
 *   'function writeFile(string path, string content) returns (bool)'
 * ])
 *
 * const FsContract = {
 *   abi: fsAbi,
 *   address: '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2'
 * } as const
 *
 * // Create precompile with handlers
 * const fsPrecompile = definePrecompile({
 *   contract: FsContract,
 *   call: defineCall(fsAbi, {
 *     readFile: async ({ args }) => {
 *       return {
 *         returnValue: await fs.readFile(args[0], 'utf8'),
 *         executionGasUsed: 0n
 *       }
 *     },
 *     writeFile: async ({ args }) => {
 *       await fs.writeFile(args[0], args[1])
 *       return {
 *         returnValue: true,
 *         executionGasUsed: 0n
 *       }
 *     }
 *   })
 * })
 * ```
 */
declare const definePrecompile: <TContract extends Contract<any, any, Address, any, any, any> = Contract<string, ReadonlyArray<string>, Address, any, any, any>>({ contract, call, }: {
    contract: TContract;
    call: (context: {
        data: Hex;
        gasLimit: bigint;
    }) => Promise<ExecResult>;
}) => Precompile<TContract>;

/**
 * RIP-7212 p256verify precompile implementation
 * @see https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md
 */
/**
 * The gas cost for the p256verify precompile (RIP-7212)
 * This is a fixed cost regardless of success or failure
 */
declare const P256_VERIFY_GAS_COST = 3450n;
/**
 * The address of the p256verify precompile (RIP-7212)
 */
declare const P256_VERIFY_ADDRESS: _tevm_address.Address;
/**
 * Creates the p256verify precompile as specified in RIP-7212
 * Verifies ECDSA signatures on the secp256r1 (P-256) curve
 *
 * @returns The p256verify precompile object
 */
declare const p256VerifyPrecompile: () => {
    address: _tevm_address.Address;
    function: (input: {
        data: Uint8Array;
    }) => {
        returnValue: viem.ByteArray;
        executionGasUsed: bigint;
    };
};

export { type CallResult, type ConstructorArgument, P256_VERIFY_ADDRESS, P256_VERIFY_GAS_COST, type TypedError, defineCall, definePrecompile, p256VerifyPrecompile };
