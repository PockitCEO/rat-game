import { Block, BlockHeader } from '@tevm/block';
import * as _tevm_common from '@tevm/common';
import { Common } from '@tevm/common';
import { LogOptions, Logger } from '@tevm/logger';
import { Hex, BlockTag as BlockTag$1, AsyncEventEmitter } from '@tevm/utils';
import * as viem from 'viem';
import { EIP1193RequestFn, BlockTag } from 'viem';
import { Consensus, OnBlock, BlockchainEvent } from '@ethereumjs/blockchain';

/**
 * Options passed into `createChain` to initialize a Chain object
 */
type ChainOptions = {
    /**
     * Logging level of blockchain package. Defaults to `warn`
     */
    loggingLevel?: LogOptions['level'];
    /**
     * A Common instance
     */
    common: Common;
    /**
     * Override the genesis block. If fork is provided it will be fetched from fork. Otherwise a default genesis is provided.
     */
    genesisBlock?: Block;
    genesisStateRoot?: Uint8Array;
    /**
     * Optional fork config for forking a live chain
     */
    fork?: {
        /**
         * EIP-1193 request function to fetch forked blocks with
         */
        transport: {
            request: EIP1193RequestFn;
        };
        /**
         * Optional block tag to fork
         * Defaults to 'latest'
         */
        blockTag?: BlockTag | bigint | `0x${string}`;
    };
};

/**
 * Internal implementation of blockchain used to implement the public interface
 */
type BaseChain = {
    /**
     * Options passed into factory function
     */
    options: ChainOptions;
    common: Common;
    /**
     * Mapping of block hashes to blocks
     */
    blocks: Map<Hex, Block | undefined>;
    /**
     * Mapping of named block tags such as 'latest' to blocks
     */
    blocksByTag: Map<BlockTag$1 | 'forked', Block | undefined>;
    /**
     * Mapping of block numbers to blocks
     */
    blocksByNumber: Map<bigint, Block | undefined>;
    /**
     * Returns a promise that resolves when the chain is ready
     */
    ready: () => Promise<true>;
    /**
     * Logger
     */
    logger: Logger;
};

declare function deepCopy(baseChain: BaseChain): () => Promise<BaseChain>;

/**
VM:
putBlock
validateHeader (not needed if you use VMs runBlock with skipHeaderValidation = true)
shallowCopy
*/
/**
 * Blockchain
 */
type Chain = {} & BaseChain & {
    /**
     * Returns a shallow copy of the blockchain that may share state with the original
     */
    shallowCopy: () => Chain;
    deepCopy: () => Promise<Chain>;
    consensus: Consensus;
    /**
     * Adds a block to the blockchain.
     *
     * @param block - The block to be added to the blockchain.
     */
    putBlock(block: Block): Promise<void>;
    /**
     * Deletes a block from the blockchain. All child blocks in the chain are
     * deleted and any encountered heads are set to the parent block.
     *
     * @param blockHash - The hash of the block to be deleted
     */
    delBlock(blockHash: Uint8Array): Promise<void>;
    /**
     * Returns a block by its hash or number.
     */
    getBlock(blockId: Uint8Array | number | bigint): Promise<Block>;
    /**
     * Gets block given one of the following inputs:
     * - Hex block hash
     * - Hex block number (if length is 32 bytes, it is treated as a hash)
     * - Uint8Array block hash
     * - Number block number
     * - BigInt block number
     * - BlockTag block tag
     * - Named block tag (e.g. 'latest', 'earliest', 'pending')
     * @throws {UnknownBlockError} - If the block is not found
     * @throw {InvalidBlockTagError} - If the block tag is invalid}
     */
    getBlockByTag(blockTag: Hex | Uint8Array | number | bigint | BlockTag$1): Promise<Block>;
    /**
     * Iterates through blocks starting at the specified iterator head and calls
     * the onBlock function on each block.
     *
     * @param name - Name of the state root head
     * @param onBlock - Function called on each block with params (block: Block,
     * @param maxBlocks - optional maximum number of blocks to iterate through
     * reorg: boolean)
     */
    iterator(name: string, onBlock: OnBlock, maxBlocks?: number, releaseLockOnCallback?: boolean): Promise<number>;
    /**
     * Validates a block header, throwing if invalid. It is being validated against the reported `parentHash`.
     * @param header - header to be validated
     * @param height - If this is an uncle header, this is the height of the block that is including it
     */
    validateHeader(header: BlockHeader, height?: bigint): Promise<void>;
    /**
     * Returns the specified iterator head.
     *
     * @param name - Optional name of the iterator head (default: 'vm')
     */
    getIteratorHead(name?: string): Promise<Block>;
    /**
     * Set header hash of a certain `tag`.
     * When calling the iterator, the iterator will start running the first child block after the header hash currently stored.
     * @param tag - The tag to save the headHash to
     * @param headHash - The head hash to save
     */
    setIteratorHead(tag: string, headHash: Uint8Array): Promise<void>;
    /**
     * Gets total difficulty for a block specified by hash and number
     */
    getTotalDifficulty?(hash: Uint8Array, number?: bigint): Promise<bigint>;
    /**
     * Returns the latest full block in the canonical chain.
     */
    getCanonicalHeadBlock(): Promise<Block>;
    /**
     * Optional events emitter
     */
    events?: AsyncEventEmitter<BlockchainEvent>;
};

declare function delBlock(baseChain: BaseChain): Chain["delBlock"];

declare function getBlock(baseChain: BaseChain): Chain["getBlock"];

declare function getCanonicalHeadBlock(baseChain: BaseChain): Chain["getCanonicalHeadBlock"];

declare function getIteratorHead(baseChain: BaseChain): Chain["getIteratorHead"];

declare function putBlock(baseChain: BaseChain): Chain["putBlock"];

declare function setIteratorHead(baseChain: BaseChain): Chain["setIteratorHead"];

declare function shallowCopy(baseChain: BaseChain): () => BaseChain;

declare function validateHeader(baseChain: BaseChain): Chain["validateHeader"];

declare function createBaseChain(options: ChainOptions): BaseChain;

declare function createChain(options: ChainOptions): Promise<Chain>;

declare function getBlockFromRpc(baseChain: BaseChain, { transport, blockTag }: {
    transport: {
        request: viem.EIP1193RequestFn;
    };
    blockTag?: bigint | viem.BlockTag | `0x${string}` | undefined;
}, common: _tevm_common.Common): Promise<[Block, viem.RpcBlock<viem.BlockTag, true, viem.RpcTransaction<boolean>>]>;

/**
 * Determines if an unknown type is a valid block tag
 * @param {unknown} blockTag
 * @returns {blockTag is TevmBlockTag} true if valid block tag
 */
declare function isTevmBlockTag(blockTag: unknown): blockTag is TevmBlockTag;
type TevmBlockTag = "latest" | "earliest" | "pending" | "safe" | "finalized" | "forked";

export { type Chain, type ChainOptions, createBaseChain, createChain, deepCopy, delBlock, getBlock, getBlockFromRpc, getCanonicalHeadBlock, getIteratorHead, isTevmBlockTag, putBlock, setIteratorHead, shallowCopy, validateHeader };
