'use strict';

var block = require('@tevm/block');
var logger = require('@tevm/logger');
var trie = require('@tevm/trie');
var viem = require('viem');
var errors = require('@tevm/errors');
var jsonrpc = require('@tevm/jsonrpc');
var utils = require('@tevm/utils');
var common = require('@tevm/common');
var blockchain = require('@ethereumjs/blockchain');

// src/createBaseChain.js
var putBlock = (baseChain) => (block) => {
  if (block.common.ethjsCommon.chainId() !== baseChain.common.ethjsCommon.chainId()) {
    throw new Error("Block does not match the chainId of common");
  }
  baseChain.blocks.set(viem.bytesToHex(block.hash()), block);
  baseChain.blocksByNumber.set(block.header.number, block);
  const latestBlock = baseChain.blocksByTag.get("latest");
  baseChain.logger.debug(block.hash(), "Saved new block");
  if (latestBlock === void 0 || latestBlock.header.number <= block.header.number) {
    baseChain.logger.debug(block.header.toJSON().number, "New highest block height. Setting block at latest");
    baseChain.blocksByTag.set("latest", block);
  }
  return Promise.resolve();
};

// src/utils/CUSTOM_Tx_TYPES.js
var customTxTypes = [
  "0x4",
  // EIP-7702 EOA Code tx (not yet supported)
  "0x7e",
  // Optimism deposit tx
  "0x6a",
  // ArbitrumDepositTxType
  "0x6b",
  // ArbitrumUnsignedTxType
  "0x6c",
  // ArbitrumContractTxType
  "0x6d",
  // ArbitrumRetryTxType
  "0x6e",
  // ArbitrumSubmitRetryableTxType
  "0x6f"
  // ArbitrumInternalTxType
];

// src/utils/isTevmBlockTag.js
var tevmBlockTags = ["latest", "earliest", "pending", "safe", "finalized", "forked"];
function isTevmBlockTag(blockTag) {
  return typeof blockTag === "string" && tevmBlockTags.includes(
    /** @type {TevmBlockTag}*/
    blockTag
  );
}

// src/utils/warnOnce.js
var warnOnce = (baseChain) => {
  let i = 0;
  return (tx) => {
    if (i > 0) {
      return;
    }
    i++;
    baseChain.logger.warn(
      `Warning: EIP-7702, Optimism and Arbitrum deposit transactions (types 0x4, 0x7e and 0x6a-0x6f) are currently not supported and will be filtered out of blocks until support is added
filtering out tx ${/** @type {import('viem').RpcBlock}*/
      tx.hash}.
Note: The block hash will be different because of the excluded txs`
    );
  };
};

// src/utils/getBlockFromRpc.js
var getBlockFromRpc = async (baseChain, { transport, blockTag = "latest" }, common) => {
  const doWarning = warnOnce(baseChain);
  const fetcher = jsonrpc.createJsonRpcFetcher(transport);
  const asEthjsBlock = (rpcBlock) => {
    return [
      block.blockFromRpc(
        {
          .../** @type {any}*/
          rpcBlock,
          // filter out transactions we don't support as a hack
          transactions: rpcBlock.transactions?.filter((tx) => {
            if (customTxTypes.includes(tx.type)) {
              doWarning(
                /** @type {any}*/
                tx
              );
              return false;
            }
            if (tx.type === "0x3" && tx.blobVersionedHashes && tx.blobVersionedHashes.length > 6) {
              console.warn(
                `Filtering out blob transaction ${tx.hash} with ${tx.blobVersionedHashes.length} blobs (maximum is 6). See https://github.com/evmts/tevm-monorepo/issues/1710`
              );
              return false;
            }
            return true;
          })
        },
        {
          common,
          setHardfork: false,
          freeze: false,
          skipConsensusFormatValidation: true
        }
      ),
      rpcBlock
    ];
  };
  return viem.withRetry(
    async () => {
      if (typeof blockTag === "bigint") {
        const { result, error } = (
          /** @type {{result: import('viem').RpcBlock<'latest', true>, error: {code: number | string, message: string}}}*/
          await fetcher.request({
            jsonrpc: "2.0",
            id: 1,
            method: "eth_getBlockByNumber",
            params: [utils.numberToHex(blockTag), true]
          })
        );
        if (error) {
          throw error;
        }
        if (!result) {
          throw new errors.UnknownBlockError("No block found");
        }
        return asEthjsBlock(result);
      }
      if (typeof blockTag === "string" && blockTag.startsWith("0x")) {
        const { result, error } = await fetcher.request({
          jsonrpc: "2.0",
          id: 1,
          method: "eth_getBlockByHash",
          params: [blockTag, true]
        });
        if (error) {
          throw error;
        }
        if (!result) {
          throw new errors.UnknownBlockError("No block found");
        }
        return asEthjsBlock(
          /** @type {any}*/
          result
        );
      }
      if (isTevmBlockTag(blockTag)) {
        const { result, error } = await fetcher.request({
          jsonrpc: "2.0",
          id: 1,
          method: "eth_getBlockByNumber",
          params: [blockTag, true]
        });
        if (error) {
          throw error;
        }
        if (!result) {
          throw new errors.UnknownBlockError("No block found");
        }
        return asEthjsBlock(
          /** @type {any}*/
          result
        );
      }
      throw new errors.InvalidBlockError(`Invalid blocktag ${blockTag}`);
    },
    {
      retryCount: 3,
      delay: ({ count }) => {
        return count * 200;
      }
    }
  );
};

// src/createBaseChain.js
var KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
var KECCAK256_RLP = viem.hexToBytes(KECCAK256_RLP_S);
var createGenesisBlock = (stateRoot, common) => {
  const newCommon = common.copy();
  newCommon.ethjsCommon.setHardforkBy({
    blockNumber: 0,
    timestamp: newCommon.ethjsCommon.genesis().timestamp ?? 0
  });
  const header = {
    ...newCommon.ethjsCommon.genesis(),
    number: 0,
    stateRoot,
    gasLimit: 30000000n,
    ...newCommon.ethjsCommon.isActivatedEIP(4895) ? { withdrawalsRoot: KECCAK256_RLP } : {}
  };
  return block.createBlock({ header, ...newCommon.ethjsCommon.isActivatedEIP(4895) ? { withdrawals: [] } : {} }, { common });
};
var createBaseChain = (options) => {
  const logger$1 = logger.createLogger({
    name: "@tevm/blockchain",
    level: options.loggingLevel ?? "warn"
  });
  const chain = {
    logger: logger$1,
    options,
    common: options.common,
    blocks: /* @__PURE__ */ new Map(),
    blocksByTag: /* @__PURE__ */ new Map(),
    blocksByNumber: /* @__PURE__ */ new Map(),
    ready: () => genesisBlockPromise.then(() => true)
  };
  const genesisBlockPromise = (async () => {
    if (options.fork?.transport) {
      const [block, jsonRpcBlock] = await getBlockFromRpc(chain, options.fork, options.common);
      await putBlock(chain)(block);
      chain.blocksByTag.set("forked", block);
      if (jsonRpcBlock.hash) {
        chain.blocks.set(jsonRpcBlock.hash, block);
      }
    } else {
      await putBlock(chain)(
        options.genesisBlock ?? createGenesisBlock(options.genesisStateRoot ?? trie.EMPTY_STATE_ROOT, options.common)
      );
    }
  })();
  return chain;
};

// src/actions/deepCopy.js
var deepCopy = (baseChain) => async () => {
  baseChain.logger.debug("deep copying blockchain...");
  await baseChain.ready();
  const chain = createBaseChain({
    common: baseChain.common.copy()
  });
  chain.blocksByTag = new Map(baseChain.blocksByTag.entries());
  chain.blocks = new Map(baseChain.blocks.entries());
  chain.blocksByNumber = new Map(baseChain.blocksByNumber.entries());
  return chain;
};
var getCanonicalHeadBlock = (baseChain) => async () => {
  await baseChain.ready();
  const block = baseChain.blocksByTag.get("latest");
  if (!block) {
    return Promise.reject(new errors.InternalError("No cannonical head exists on blockchain"));
  }
  return Promise.resolve(block);
};

// src/actions/getBlock.js
var getBlock = (baseChain) => async (blockId) => {
  const block = (() => {
    if (typeof blockId === "bigint" || typeof blockId === "number") {
      baseChain.logger.debug({ blockId: BigInt(blockId) }, "getting block by number");
      return baseChain.blocksByNumber.get(BigInt(blockId));
    }
    if (blockId instanceof Uint8Array) {
      baseChain.logger.debug({ blockId: utils.bytesToHex(blockId) }, "getting block by hash or hex encoded number");
      return baseChain.blocks.get(utils.bytesToHex(blockId)) ?? baseChain.blocksByNumber.get(utils.bytesToBigInt(blockId));
    }
    const typesafeBlockId = blockId;
    throw new errors.InvalidBlockError(`Unknown blockid ${typesafeBlockId}`);
  })();
  if (block !== void 0) {
    baseChain.logger.debug(block.header.toJSON(), "Block found in cache");
    return block;
  }
  if (!baseChain.options.fork?.transport) {
    throw new errors.UnknownBlockError(
      blockId instanceof Uint8Array ? `Block with hash ${utils.bytesToHex(blockId)} does not exist` : `Block number ${blockId} does not exist`
    );
  }
  baseChain.logger.debug("Fetching block from remote rpc...");
  const [fetchedBlock, jsonRpcFetchedBlock] = await getBlockFromRpc(
    baseChain,
    {
      transport: baseChain.options.fork?.transport,
      blockTag: blockId instanceof Uint8Array ? utils.bytesToHex(blockId) : BigInt(blockId)
    },
    baseChain.common
  );
  baseChain.logger.debug(fetchedBlock.header.toJSON(), "Saving forked block to blockchain");
  const forkedBlock = (
    /** @type {import('@tevm/block').Block}*/
    baseChain.blocksByTag.get("forked")
  );
  const latestBlock = await getCanonicalHeadBlock(baseChain)();
  if (fetchedBlock.header.number > forkedBlock.header.number) {
    throw new errors.InvalidBlockError(`The fetched block ${fetchedBlock.header.number} has a higher block height than the forked block ${forkedBlock.header.number} but less than the latest block ${latestBlock.header.number}
This could indicate a bug in tevm as it implies a block is missing if the internal chain tried fetching it from rpc
Did you manually delete the block? If not consider opening an issue`);
  }
  await putBlock(baseChain)(fetchedBlock);
  if (jsonRpcFetchedBlock?.hash) {
    baseChain.blocks.set(jsonRpcFetchedBlock.hash, fetchedBlock);
  }
  return fetchedBlock;
};

// src/actions/delBlock.js
var delBlock = (baseChain) => async (blockHash) => {
  const block = await getBlock(baseChain)(blockHash);
  const hexHash = viem.bytesToHex(blockHash);
  const latest = await getCanonicalHeadBlock(baseChain)();
  const forkedBlock = baseChain.blocksByTag.get("forked");
  if (forkedBlock && hexHash === viem.bytesToHex(forkedBlock.hash())) {
    throw new errors.InvalidBlockError("Cannot delete the forked block!");
  }
  if (hexHash === viem.bytesToHex(latest.hash())) {
    const parent = await getBlock(baseChain)(latest.header.parentHash).catch(() => void 0);
    baseChain.blocksByTag.set("latest", parent);
  }
  baseChain.blocksByNumber.delete(block.header.number);
  baseChain.blocks.delete(hexHash);
  baseChain.logger.debug({ blockHash }, "deleted block");
};
var getIteratorHead = (baseChain) => (name = "vm") => {
  const head = baseChain.blocksByTag.get(
    /** @type {import('viem').BlockTag}*/
    name
  );
  if (!head) {
    return Promise.reject(
      new errors.InvalidBlockError(
        `No block with tag ${name} exists. Current tags include ${[...baseChain.blocksByTag.keys()].join(",")}`
      )
    );
  }
  return Promise.resolve(head);
};
var setIteratorHead = (baseChain) => (tag, headHash) => {
  baseChain.blocksByTag.set(
    /** @type {import('viem').BlockTag}*/
    tag,
    baseChain.blocks.get(viem.bytesToHex(headHash))
  );
  return Promise.resolve();
};

// src/actions/shallowCopy.js
var shallowCopy = (baseChain) => () => {
  return createBaseChain(baseChain.options);
};
var validateHeader = (baseChain) => async (header, height) => {
  if (header.isGenesis()) {
    return;
  }
  const parentHeader = (await getBlock(baseChain)(header.parentHash)).header;
  const { number } = header;
  if (number !== parentHeader.number + BigInt(1)) {
    throw new Error(`invalid number ${header.errorStr()}`);
  }
  if (header.timestamp <= parentHeader.timestamp) {
    throw new Error(`invalid timestamp ${header.errorStr()}`);
  }
  if (baseChain.common.ethjsCommon.consensusType() === "pow") throw new Error("Tevm currently does not support pow");
  if (baseChain.common.ethjsCommon.consensusAlgorithm() === common.ConsensusAlgorithm.Clique) {
    const period = (
      /** @type {any}*/
      baseChain.common.ethjsCommon.consensusConfig().period
    );
    if (parentHeader.timestamp + BigInt(period) > header.timestamp) {
      throw new Error(`invalid timestamp diff (lower than period) ${header.errorStr()}`);
    }
  }
  header.validateGasLimit(parentHeader);
  if (height !== void 0) {
    const dif = height - parentHeader.number;
    if (!(dif < BigInt(8) && dif > BigInt(1))) {
      throw new Error(`uncle block has a parent that is too old or too young ${header.errorStr()}`);
    }
  }
  if (baseChain.common.ethjsCommon.isActivatedEIP(1559)) {
    let expectedBaseFee;
    const londonHfBlock = baseChain.common.ethjsCommon.hardforkBlock("london");
    const isInitialEIP1559Block = number === londonHfBlock;
    if (isInitialEIP1559Block) {
      expectedBaseFee = baseChain.common.ethjsCommon.param("initialBaseFee");
    } else {
      expectedBaseFee = parentHeader.calcNextBaseFee();
    }
    if (header.baseFeePerGas !== expectedBaseFee) {
      throw new Error(`Invalid block: base fee not correct ${header.errorStr()}`);
    }
  }
  if (baseChain.common.ethjsCommon.isActivatedEIP(4844)) {
    const expectedExcessBlobGas = parentHeader.calcNextExcessBlobGas();
    if (header.excessBlobGas !== expectedExcessBlobGas) {
      throw new Error(`expected blob gas: ${expectedExcessBlobGas}, got: ${header.excessBlobGas}`);
    }
  }
};
var getBlockByTag = (baseChain) => async (blockId) => {
  const _getBlock = getBlock(baseChain);
  if (utils.isHex(blockId)) {
    return blockId.length === 66 ? _getBlock(utils.hexToBytes(blockId)) : _getBlock(utils.hexToNumber(blockId));
  }
  if (typeof blockId === "number" || typeof blockId === "bigint" || blockId instanceof Uint8Array) {
    return _getBlock(blockId);
  }
  const block = baseChain.blocksByTag.get(blockId);
  if (!block && baseChain.options.fork?.transport) {
    const [block2, jsonRpcBlock] = await getBlockFromRpc(
      baseChain,
      {
        transport: baseChain.options.fork.transport,
        blockTag: blockId
      },
      baseChain.common
    );
    await putBlock(baseChain)(block2);
    baseChain.blocksByTag.set(blockId, block2);
    if (jsonRpcBlock.hash) {
      baseChain.blocks.set(jsonRpcBlock.hash, block2);
    }
    return block2;
  }
  if (!block) {
    throw new errors.UnknownBlockError(blockId);
  }
  return block;
};

// src/createChain.js
var createChain = async (options) => {
  const decorate = (baseChain) => {
    return (
      /** @type {import('./Chain.js').Chain} */
      Object.assign(baseChain, {
        getBlockByTag: getBlockByTag(baseChain),
        deepCopy: async () => decorate(await deepCopy(baseChain)()),
        shallowCopy: () => decorate(shallowCopy(baseChain)()),
        getBlock: getBlock(baseChain),
        putBlock: putBlock(baseChain),
        validateHeader: validateHeader(baseChain),
        getCanonicalHeadBlock: getCanonicalHeadBlock(baseChain),
        delBlock: delBlock(baseChain),
        getIteratorHead: getIteratorHead(baseChain),
        setIteratorHead: setIteratorHead(baseChain),
        /**
         * Unused but part of interface
         * @type {import('@ethereumjs/blockchain').BlockchainInterface['consensus']}
         */
        consensus: new blockchain.CasperConsensus(),
        /**
         * @type {import('@ethereumjs/blockchain').BlockchainInterface['iterator']}
         */
        iterator: () => {
          throw new Error("iterator is not implemented");
        }
      })
    );
  };
  return decorate(createBaseChain(options));
};

exports.createBaseChain = createBaseChain;
exports.createChain = createChain;
exports.deepCopy = deepCopy;
exports.delBlock = delBlock;
exports.getBlock = getBlock;
exports.getBlockFromRpc = getBlockFromRpc;
exports.getCanonicalHeadBlock = getCanonicalHeadBlock;
exports.getIteratorHead = getIteratorHead;
exports.isTevmBlockTag = isTevmBlockTag;
exports.putBlock = putBlock;
exports.setIteratorHead = setIteratorHead;
exports.shallowCopy = shallowCopy;
exports.validateHeader = validateHeader;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map