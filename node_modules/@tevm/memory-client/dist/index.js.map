{"version":3,"sources":["../src/createTevmTransport.js","../src/tevmViemActions.js","../src/createMemoryClient.js","../src/tevmCall.js","../src/tevmContract.js","../src/tevmDeploy.js","../src/tevmDumpState.js","../src/tevmGetAccount.js","../src/tevmLoadState.js","../src/tevmMine.js","../src/tevmReady.js","../src/tevmSetAccount.js"],"names":["createClient","publicActions","walletActions","testActions"],"mappings":"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","file":"index.js","sourcesContent":["import { createCommon } from '@tevm/common'\nimport { requestEip1193, tevmSend } from '@tevm/decorators'\nimport { createTevmNode } from '@tevm/node'\nimport { createTransport } from 'viem'\n\n/**\n * Creates a custom TEVM Transport for viem clients, integrating an in-memory Ethereum Virtual Machine.\n *\n * A Transport in viem is the intermediary layer responsible for executing outgoing JSON-RPC requests.\n * The TEVM Transport implementation replaces network requests with direct calls to an in-memory EVM,\n * providing several key advantages:\n *\n * - **Local-first operation**: All EVM execution happens directly in the JavaScript runtime\n * - **Zero network latency**: No round-trips to remote nodes for operations\n * - **Deterministic execution**: Full control over the execution environment for testing\n * - **Advanced tracing**: Step-by-step EVM execution with introspection capabilities\n * - **Forking capabilities**: Can lazily load state from remote networks as needed\n * - **Customizable state**: Direct manipulation of accounts, balances, storage, and more\n *\n * The transport can be used with any viem client (wallet, public, or test) and fully supports the\n * EIP-1193 provider interface, making it compatible with the broader Ethereum ecosystem.\n *\n * @param {import('@tevm/node').TevmNodeOptions} options - Configuration options for the underlying TEVM node.\n * @returns {import('./TevmTransport.js').TevmTransport} A configured TEVM transport factory function.\n *\n * @example\n * ```typescript\n * import { createClient, http } from 'viem'\n * import { createTevmTransport } from 'tevm'\n * import { optimism } from 'tevm/common'\n *\n * // Create a client with TEVM transport that forks from Optimism mainnet\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: {\n *       transport: http('https://mainnet.optimism.io')({}),\n *       blockTag: 'latest' // Optional: specify block number or hash\n *     },\n *     mining: {\n *       auto: true,        // Optional: enable auto-mining after transactions\n *       interval: 0        // Optional: mine blocks at regular intervals (ms)\n *     }\n *   }),\n *   chain: optimism,\n * })\n *\n * async function example() {\n *   // Ready check ensures fork is initialized\n *   await client.transport.tevm.ready()\n *\n *   const blockNumber = await client.getBlockNumber()\n *   console.log(`Connected to block ${blockNumber}`)\n *\n *   // Access the underlying TEVM node for advanced operations\n *   const node = client.transport.tevm\n *   const vm = await node.getVm()\n *   console.log(`EVM hardfork: ${vm.common.hardfork()}`)\n * }\n *\n * example()\n * ```\n *\n * @see {@link createClient} - Viem function for creating clients\n * @see [Viem Client Docs](https://viem.sh/docs/clients/introduction)\n * @see [Client Guide](https://tevm.sh/learn/clients/)\n * @see [tevm JSON-RPC Guide](https://tevm.sh/learn/json-rpc/)\n * @see [EIP-1193 spec](https://eips.ethereum.org/EIPS/eip-1193)\n * @see [Ethereum JSON-RPC docs](https://ethereum.org/en/developers/docs/apis/json-rpc/)\n * @see [CreateMemoryClient Docs](https://tevm.sh/reference/tevm/memory-client/functions/creatememoryclient/) - For a batteries-included client if not worried about tree shaking\n *\n * @typedef {Object} TevmTransportConfig\n * @property {number} [timeout=20000] - Timeout duration for requests in milliseconds. Default is 20,000 ms. Supplied by viem.\n * @property {number} [retryCount=3] - The maximum number of times to retry a failed request. Default is 3. Supplied by viem.\n * @property {import('viem').Chain} [chain] - Blockchain configuration. Defaults to the chain specified in `options` or the default TEVM chain.\n *\n * ## Key Transport Options\n *\n * - `timeout` (optional, number): Timeout duration for requests in milliseconds. Default is 20,000 ms.\n * - `retryCount` (optional, number): The maximum number of times to retry a failed request. Default is 3.\n * - `chain` (optional, Chain): Blockchain configuration. Defaults to the chain in `options` or TEVM default.\n *\n * ## Key Node Options\n *\n * - `fork` (optional): Configuration for forking from an existing network\n *   - `transport`: An EIP-1193 compatible transport (e.g., from viem's http function)\n *   - `blockTag` (optional): Block number/hash to fork from (defaults to 'latest')\n * - `mining` (optional): Mining configuration\n *   - `auto` (boolean): Whether to automatically mine after transactions\n *   - `interval` (number): Milliseconds between automatic block mining (0 = disabled)\n * - `common` (optional): Chain configuration (recommended for optimal performance)\n * - `persister` (optional): For state persistence between sessions\n *\n * ## Gotchas and Best Practices\n *\n * - When specifying a chain, use TEVM common instead of viem chains. You can create a TEVM common from a viem chain using `createCommon`.\n * - The transport creates an internal cache of TEVM nodes keyed by chain ID, so multiple clients with the same chain ID share state.\n * - For full control over a client's state, either use unique chain IDs or the higher-level `createMemoryClient`.\n * - Access the underlying TEVM node via `client.transport.tevm` for advanced operations.\n */\nexport const createTevmTransport = (options = {}) => {\n\t/**\n\t * A map to store and manage TEVM clients keyed by chain ID.\n\t * @type {Map<number, import('@tevm/node').TevmNode & import('@tevm/decorators').Eip1193RequestProvider & import('@tevm/decorators').TevmSendApi>}\n\t */\n\tconst tevmMap = new Map()\n\n\t/**\n\t * Creates and returns a TEVM transport.\n\t * @type {import('./TevmTransport.js').TevmTransport}\n\t */\n\treturn ({ timeout = 20_000, retryCount = 3, chain }) => {\n\t\tconst dynamicChain =\n\t\t\tchain && 'ethjsCommon' in chain\n\t\t\t\t? /** @type {import('@tevm/common').Common} */ (chain)\n\t\t\t\t: chain !== undefined\n\t\t\t\t\t? // if user passed in chain instead of common create a common from it with cancun and default eips\n\t\t\t\t\t\tcreateCommon({ ...chain, hardfork: 'prague', loggingLevel: 'warn' })\n\t\t\t\t\t: undefined\n\t\tconst common = options.common ?? dynamicChain\n\t\tconst id = common?.id ?? -1\n\t\tconst tevm =\n\t\t\ttevmMap.get(id) ??\n\t\t\tcreateTevmNode({ ...options, ...(common !== undefined ? { common } : {}) })\n\t\t\t\t.extend(requestEip1193())\n\t\t\t\t.extend(tevmSend())\n\t\ttevmMap.set(id, tevm)\n\n\t\treturn /** @type {any} */ (\n\t\t\tcreateTransport(\n\t\t\t\t{\n\t\t\t\t\trequest: /** @type any */ (tevm.request),\n\t\t\t\t\ttype: 'tevm',\n\t\t\t\t\tname: /** options?.name ?? */ 'Tevm transport',\n\t\t\t\t\tkey: /* options?.key ?? */ 'tevm',\n\t\t\t\t\ttimeout,\n\t\t\t\t\tretryCount,\n\t\t\t\t\tretryDelay: /* options?.retryDelay ?? */ 150,\n\t\t\t\t},\n\t\t\t\t{ tevm },\n\t\t\t)\n\t\t)\n\t}\n}\n","import { tevmActions } from '@tevm/decorators'\n\n/**\n * A viem extension that adds TEVM actions to a viem client.\n *\n * This function creates a viem extension that adds the full set of TEVM-specific actions to any viem client\n * that has been configured with the TEVM transport. These actions provide direct access to the Ethereum\n * Virtual Machine's capabilities, including:\n *\n * - Low-level EVM execution (`tevmCall`)\n * - Contract interaction with ABI encoding/decoding (`tevmContract`)\n * - Contract deployment (`tevmDeploy`)\n * - Block mining (`tevmMine`)\n * - Account state management (`tevmGetAccount`, `tevmSetAccount`)\n * - State persistence (`tevmDumpState`, `tevmLoadState`)\n * - Token manipulation (`tevmDeal` for ETH and ERC20 tokens)\n * - Direct VM access (`tevm` for advanced usage)\n *\n * The viem client must already have TEVM support via a `createTevmTransport` transport.\n *\n * Note: If you are building a frontend application, you should use the tree-shakable API instead to optimize bundle size.\n *\n * @returns {(client: import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>) => import('./TevmViemActionsApi.js').TevmViemActionsApi} A viem extension function that adds TEVM actions\n * @throws {Error} If the client doesn't have a TEVM transport configured\n *\n * @example\n * ```typescript\n * import { createClient, http } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport, tevmViemActions } from 'tevm'\n *\n * // Create a basic viem client with TEVM transport\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: {\n *       transport: http('https://mainnet.optimism.io')({})\n *     }\n *   }),\n *   chain: optimism,\n * })\n *\n * // Extend the client with TEVM actions\n * const tevmClient = client.extend(tevmViemActions())\n *\n * async function example() {\n *   // Wait for the client to be ready\n *   await tevmClient.tevmReady()\n *\n *   // Set up an account with ETH\n *   await tevmClient.tevmSetAccount({\n *     address: '0x1234567890123456789012345678901234567890',\n *     balance: 1000000000000000000n // 1 ETH\n *   })\n *\n *   // Get account state including storage\n *   const account = await tevmClient.tevmGetAccount({\n *     address: '0x1234567890123456789012345678901234567890',\n *     returnStorage: true,\n *   })\n *   console.log('Account:', account)\n *\n *   // Deploy a contract\n *   const deployResult = await tevmClient.tevmDeploy({\n *     bytecode: '0x608060405234801561001057600080fd5b50610150806100206000396000f3fe...',\n *     abi: [...],\n *     createTransaction: true // Create an actual transaction, not just a call\n *   })\n *\n *   // Mine the transaction to include it in state\n *   await tevmClient.tevmMine()\n *\n *   console.log('Contract deployed at:', deployResult.createdAddress)\n * }\n *\n * example()\n * ```\n *\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/) - Complete documentation of all TEVM actions\n * @see [Viem Client Guide](https://viem.sh/docs/clients/) - Viem client documentation\n * @see {@link TevmViemActionsApi} - The API interface this extension implements\n */\nexport const tevmViemActions = () => {\n\t/**\n\t * Internal extension function that adds TEVM actions to a viem client.\n\t *\n\t * This function extracts the TEVM API methods from the client's transport and\n\t * exposes them with the prefix 'tevm' to make them available on the client object.\n\t *\n\t * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n\t * @returns {import('./TevmViemActionsApi.js').TevmViemActionsApi} The TEVM actions API interface with all methods.\n\t * @throws {TypeError} If the client doesn't have a TEVM transport configured.\n\t * @private\n\t */\n\tconst extension = (client) => {\n\t\tconst { call, contract, deploy, mine, loadState, dumpState, setAccount, getAccount, ready, deal } =\n\t\t\tclient.transport.tevm.extend(tevmActions())\n\t\treturn {\n\t\t\ttevmReady: ready,\n\t\t\ttevmCall: call,\n\t\t\ttevmContract: contract,\n\t\t\ttevmDeploy: deploy,\n\t\t\ttevmMine: mine,\n\t\t\ttevmLoadState: loadState,\n\t\t\ttevmDumpState: dumpState,\n\t\t\ttevmSetAccount: setAccount,\n\t\t\ttevmGetAccount: getAccount,\n\t\t\ttevmDeal: deal,\n\t\t}\n\t}\n\treturn extension\n}\n","import { tevmDefault } from '@tevm/common'\nimport { createClient, publicActions, testActions, walletActions } from 'viem'\nimport { createTevmTransport } from './createTevmTransport.js'\nimport { tevmViemActions } from './tevmViemActions.js'\n\n/**\n * Creates a {@link MemoryClient} - a fully-featured Ethereum development and testing environment.\n *\n * The MemoryClient is an all-in-one solution that combines:\n * - A complete in-memory Ethereum Virtual Machine implementation\n * - Full support for viem's wallet, test, and public actions\n * - TEVM-specific actions for advanced state manipulation and tracing\n * - Automatic handling of JSON-RPC requests through viem's client interface\n *\n * This provides an integrated environment for local Ethereum development with capabilities like:\n * - Executing and debugging smart contracts without deploying to a testnet\n * - Forking from existing networks with state caching for realistic testing\n * - Direct manipulation of blockchain state for complex test scenarios\n * - Complete control over mining and transaction processing\n * - Compatibility with standard Ethereum tooling and libraries\n *\n * @type {import('./CreateMemoryClientFn.js').CreateMemoryClientFn}\n *\n * @example\n * ```typescript\n * import { createMemoryClient, http } from \"tevm\";\n * import { optimism } from \"tevm/common\";\n *\n * // Create a memory client that forks from Optimism mainnet\n * const client = createMemoryClient({\n *   fork: {\n *     transport: http(\"https://mainnet.optimism.io\")({}),\n *   },\n *   common: optimism,\n *   mining: { auto: true }, // Automatically mine blocks after transactions\n * });\n *\n * // Wait for fork initialization to complete\n * await client.tevmReady();\n *\n * // Use standard viem actions\n * const blockNumber = await client.getBlockNumber();\n * console.log(`Connected to Optimism block ${blockNumber}`);\n *\n * // Use TEVM-specific actions\n * await client.tevmSetAccount({\n *   address: \"0x123...\",\n *   balance: 10000000000000000000n // 10 ETH\n * });\n * ```\n *\n * @see [Client Guide](https://tevm.sh/learn/clients/)\n * @see [Actions Guide](https://tevm.sh/learn/actions/)\n * @see [Reference Docs](https://tevm.sh/reference/tevm/memory-client/functions/creatememoryclient/)\n * @see [Viem client docs](https://viem.sh/docs/clients/introduction)\n *\n * ## Key Configuration Options\n *\n * ```typescript\n * createMemoryClient({\n *   // Chain configuration (use tevm/common chains, not viem/chains)\n *   common: optimism,\n *\n *   // Forking from an existing network\n *   fork: {\n *     transport: http(\"https://mainnet.optimism.io\")({}),\n *     blockTag: 'latest', // or specific block number/hash\n *   },\n *\n *   // Mining configuration\n *   mining: {\n *     auto: true,      // Auto-mine after each transaction\n *     interval: 5000,  // Mine blocks every 5 seconds (in ms)\n *   },\n *\n *   // State persistence\n *   persister: createSyncPersister({\n *     storage: localStorage, // or any synchronous storage\n *   }),\n *\n *   // Chain configuration\n *   hardfork: 'prague', // Default and recommended\n *\n *   // EVM execution logging\n *   logging: {\n *     logLevel: 'debug',\n *   },\n * })\n * ```\n *\n * ## Actions API\n *\n * MemoryClient combines multiple action types in a single interface:\n *\n * ### 1. TEVM-specific actions\n * ```typescript\n * // Account and state manipulation\n * await client.tevmSetAccount({ address: \"0x123...\", balance: 100n });\n * await client.tevmGetAccount({ address: \"0x123...\" });\n *\n * // Contract interactions\n * await client.tevmContract({\n *   abi: [...],\n *   functionName: \"transfer\",\n *   args: [\"0x456...\", 1000n]\n * });\n *\n * // Contract deployment\n * const result = await client.tevmDeploy({\n *   abi: [...],\n *   bytecode: \"0x...\",\n *   args: [\"Constructor\", \"Args\"]\n * });\n *\n * // Mining control\n * await client.tevmMine({ blockCount: 5, interval: 10 });\n *\n * // State persistence\n * const state = await client.tevmDumpState();\n * await client.tevmLoadState(state);\n * ```\n *\n * ### 2. Viem public actions\n * ```typescript\n * const balance = await client.getBalance({ address: \"0x123...\" });\n * const blockNumber = await client.getBlockNumber();\n * const code = await client.getCode({ address: \"0x123...\" });\n * const logs = await client.getLogs({ address: \"0x123...\" });\n * ```\n *\n * ### 3. Viem test actions\n * ```typescript\n * await client.setBalance({ address: \"0x123...\", value: 100n });\n * await client.impersonateAccount({ address: \"0x123...\" });\n * await client.mine({ blocks: 1 });\n * await client.setStorageAt({ address, index, value });\n * ```\n *\n * ### 4. Viem wallet actions\n * ```typescript\n * const hash = await client.sendTransaction({\n *   from: \"0x123...\",\n *   to: \"0x456...\",\n *   value: 1000n\n * });\n * ```\n *\n * ## Forking Networks\n *\n * The MemoryClient can fork from any EVM-compatible network, creating a local copy that\n * lazily loads state from the remote network as needed:\n *\n * ```typescript\n * import { createMemoryClient, http } from \"tevm\";\n * import { optimism } from \"tevm/common\";\n *\n * const forkedClient = createMemoryClient({\n *   // Fork specification\n *   fork: {\n *     transport: http(\"https://mainnet.optimism.io\")({}),\n *     blockTag: '0xa6a63cd70fbbe396321ca6fe79e1b6735760c03538208b50d7e3a5dac5226435',\n *   },\n *   // Always specify chain configuration for optimal performance\n *   common: optimism,\n * });\n * ```\n *\n * The `common` object extends the viem chain interface with EVM-specific information.\n * Always use `tevm/common` chains rather than `viem/chains` when working with TEVM.\n *\n * ## Mining Modes\n *\n * TEVM supports three mining modes:\n *\n * ```typescript\n * // 1. Manual mining (default)\n * const client = createMemoryClient({ mining: { auto: false } });\n * await client.sendTransaction(...);  // Transaction is pending\n * await client.tevmMine();            // Now transaction is processed\n *\n * // 2. Auto-mining (mine after every transaction)\n * const autoClient = createMemoryClient({ mining: { auto: true } });\n * await autoClient.sendTransaction(...);  // Automatically mined\n *\n * // 3. Interval mining (mine periodically)\n * const intervalClient = createMemoryClient({\n *   mining: { interval: 5000 }  // Mine every 5 seconds\n * });\n * ```\n *\n * ## Server Mode\n *\n * TEVM can be exposed as an HTTP JSON-RPC server with `@tevm/server`:\n *\n * ```typescript\n * import { createServer } from \"tevm/server\";\n * import { createMemoryClient } from \"tevm\";\n *\n * const memoryClient = createMemoryClient();\n * const server = createServer({\n *   request: memoryClient.request,\n * });\n *\n * server.listen(8545, () => console.log(\"TEVM running on port 8545\"));\n * ```\n *\n * This allows any Ethereum tool or library to connect to your TEVM instance:\n *\n * ```typescript\n * import { createPublicClient, http } from \"viem\";\n * import { mainnet } from \"viem/chains\";\n *\n * const publicClient = createPublicClient({\n *   chain: mainnet,\n *   transport: http(\"http://localhost:8545\"),\n * });\n *\n * console.log(await publicClient.getChainId());\n * ```\n *\n * ## State Persistence\n *\n * TEVM state can be persisted between sessions with the `persister` option:\n *\n * ```typescript\n * import { createMemoryClient } from \"tevm\";\n * import { createSyncPersister } from \"tevm/sync-storage-persister\";\n *\n * // Browser example with localStorage\n * const browserClient = createMemoryClient({\n *   persister: createSyncPersister({\n *     storage: localStorage,\n *     key: 'my-tevm-state'\n *   }),\n * });\n *\n * // Node.js example with file system\n * import { FileStorage } from \"tevm/sync-storage-persister/node\";\n * const nodeClient = createMemoryClient({\n *   persister: createSyncPersister({\n *     storage: new FileStorage('./tevm-state.json'),\n *   }),\n * });\n * ```\n *\n * ## Direct Solidity Imports\n *\n * When used with the TEVM bundler plugins, you can import Solidity files directly:\n *\n * ```typescript\n * import { createMemoryClient } from \"tevm\";\n * import { MyERC721 } from './MyERC721.sol';\n *\n * const client = createMemoryClient();\n *\n * // Deploy the contract\n * const deployed = await client.tevmDeploy(\n *   MyERC721.deploy(\"My NFT\", \"NFT\")\n * );\n * await client.tevmMine();\n *\n * // Create contract instance with the deployed address\n * const nft = MyERC721.withAddress(deployed.createdAddress);\n *\n * // Call contract methods\n * await client.tevmContract({\n *   ...nft.write.mint('0x123...', 1),\n *   from: '0x123...',\n * });\n *\n * await client.tevmMine();\n *\n * const balance = await client.tevmContract(nft.read.balanceOf('0x123...'));\n * console.log(balance); // 1n\n * ```\n *\n * This requires setting up one of the TEVM bundler plugins (vite, webpack, esbuild, etc.).\n *\n * ## Network Support\n *\n * TEVM officially supports:\n * - Ethereum mainnet and testnets\n * - OP Stack chains (Optimism, Base, etc.)\n *\n * Other EVM chains are likely to work but not officially tested. Chain configuration\n * is available through `tevm/common`.\n *\n * ## Advanced EVM Features\n *\n * TEVM includes advanced EVM features, with the following enabled by default:\n * - EIP-1559 Fee Market\n * - EIP-4895 (Beacon chain withdrawals)\n * - EIP-4844 (Blob transactions)\n * - EIP-4788 (Beacon root in EVM)\n *\n * ## Optimizing Bundle Size\n *\n * For UI applications concerned with bundle size, use tree-shakeable actions with `createTevmNode()`\n * and individual actions from `tevm/actions`. See the [actions API guide](https://tevm.sh/learn/actions/)\n * for details.\n */\nexport const createMemoryClient = (options) => {\n\tconst common = (() => {\n\t\tif (options?.common !== undefined) {\n\t\t\treturn options.common\n\t\t}\n\t\tif (options?.fork?.transport) {\n\t\t\t// we don't want to return default chain if forking because we don't know chain id yet\n\t\t\treturn undefined\n\t\t}\n\t\t// but if not forking we know common will be default\n\t\treturn tevmDefault\n\t})()\n\tconst memoryClient = createClient({\n\t\t...options,\n\t\tcacheTime: 0,\n\t\ttransport: createTevmTransport({\n\t\t\t...options,\n\t\t\t...(common !== undefined ? { common } : {}),\n\t\t}),\n\t\ttype: 'tevm',\n\t\t...(common !== undefined ? { chain: common } : {}),\n\t})\n\t\t.extend(tevmViemActions())\n\t\t.extend(publicActions)\n\t\t.extend(walletActions)\n\t\t.extend(testActions({ mode: 'anvil' }))\n\treturn /** @type {any} */ (memoryClient)\n}\n","import { callHandler } from '@tevm/actions'\n\n/**\n * A tree-shakeable version of the `tevmCall` action for viem.\n * Executes a low-level call against the Ethereum Virtual Machine (EVM). This function provides enhanced control over the\n * execution environment compared to the standard `eth_call` JSON-RPC method.\n *\n * By default, this is a read-only operation that doesn't modify the blockchain state after execution completes.\n * However, state modifications can be enabled with the following options:\n * - `addToMempool`: Add the transaction to the mempool (must be manually mined later)\n * - `addToBlockchain`: Add the transaction to the mempool AND automatically mine it\n * - `createTransaction`: [DEPRECATED] Use addToMempool instead\n *\n * Important: Tevm defaults to a manual mining mode, which means transactions are not included in the blockchain\n * until you explicitly mine them. Use `addToBlockchain: true` if you want transactions to be immediately mined.\n *\n * The function supports advanced EVM features such as:\n * - Account impersonation (executing as any address without requiring private keys)\n * - Detailed execution tracing with step-by-step opcode inspection\n * - Gas limit and price customization\n * - Balance/nonce checks can be skipped for testing scenarios\n * - Full revert reason messages and traces\n *\n * @example\n * ```typescript\n * import { createClient, http } from 'viem'\n * import { tevmCall } from 'tevm/actions'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n *\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: { transport: http('https://mainnet.optimism.io')({}) }\n *   }),\n *   chain: optimism,\n * })\n *\n * async function example() {\n *   // Execute a read-only call to a contract\n *   const readResult = await tevmCall(client, {\n *     to: '0x123...',             // Target contract address\n *     data: '0x123...',           // Encoded function call (e.g. from encodeFunctionData)\n *     from: '0x123...',           // Sender address (can be any address when impersonating)\n *     gas: 1000000,               // Gas limit for the call\n *     gasPrice: 1n,               // Gas price in wei\n *     skipBalance: true,          // Skip balance checks (useful for testing)\n *     onStep: (step, next) => {   // Optional: trace EVM execution steps\n *       console.log(`Executing ${step.opcode.name} at PC=${step.pc}`);\n *       next();\n *     }\n *   })\n *\n *   // Submit a transaction to the mempool (requires manual mining)\n *   const txResult = await tevmCall(client, {\n *     to: '0x456...',\n *     data: '0x456...',\n *     value: 1000000000000000000n, // 1 ETH\n *     addToMempool: true,        // Add to mempool but don't mine\n *   })\n *\n *   // Mine the transaction\n *   await client.tevmMine()\n *\n *   // Or submit and mine in one step\n *   const autoMinedResult = await tevmCall(client, {\n *     to: '0x789...',\n *     data: '0x789...',\n *     addToBlockchain: true,      // Add to mempool AND automatically mine\n *   })\n *\n *   console.log(readResult.rawData)       // Return data from the call\n *   console.log(txResult.txHash)          // Transaction hash\n *   console.log(readResult.executionGasUsed) // Actual gas used\n * }\n *\n * example()\n * ```\n *\n * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n * @param {import('@tevm/actions').CallParams} params - Parameters for the call, including the target address, call data, sender address, gas limit, gas price, and other options.\n * @returns {Promise<import('@tevm/actions').CallResult>} The result of the call, including execution results, gas used, and any traces.\n *\n * @see [CallParams](https://tevm.sh/reference/tevm/actions/type-aliases/callparams/) for options reference.\n * @see [BaseCallParams](https://tevm.sh/reference/tevm/actions/type-aliases/basecallparams-1/) for the base call parameters.\n * @see [CallResult](https://tevm.sh/reference/tevm/actions/type-aliases/callresult/) for return values reference.\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/)\n * @see [tevmContract](https://tevm.sh/reference/tevm/memory-client/functions/tevmcontract/) for a higher-level interface for contract calls\n * @throws Will throw if the call reverts. The error will contain revert reason if available.\n */\nexport const tevmCall = async (client, params) => {\n\treturn callHandler(client.transport.tevm)(params)\n}\n","import { contractHandler } from '@tevm/actions'\n\n/**\n * A tree-shakeable version of the `tevmContract` action for viem.\n * Provides a high-level interface for contract interactions with automatic encoding/decoding and full type safety.\n *\n * While `tevmCall` offers a low-level interface for raw EVM execution, `tevmContract` provides a more convenient\n * developer experience for standard contract interactions by:\n *\n * - Automatically encoding function parameters based on the ABI\n * - Automatically decoding return values to the appropriate JavaScript types\n * - Properly handling and decoding revert messages from failed calls\n * - Maintaining full type safety with TypeScript when using properly typed ABIs\n * - Simplifying complex contract interactions with a cleaner interface\n *\n * Internally, `tevmContract` wraps the lower-level `tevmCall` action, handling all the ABI encoding/decoding\n * logic while providing access to the same advanced features like execution tracing and EVM customization.\n *\n * @type {import('./TevmContractType.js').TevmContract}\n *\n * @example\n * ```typescript\n * import { tevmContract } from 'tevm/actions'\n * import { createClient, http, parseAbi } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n *\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: { transport: http('https://mainnet.optimism.io')({}) }\n *   }),\n *   chain: optimism,\n * })\n *\n * async function example() {\n *   // Define the contract ABI\n *   const abi = parseAbi([\n *     'function balanceOf(address owner) view returns (uint256)',\n *     'function transfer(address to, uint256 amount) returns (bool)'\n *   ])\n *\n *   // Read from contract (view function)\n *   const balance = await tevmContract(client, {\n *     abi,\n *     address: '0x4200000000000000000000000000000000000042', // OP token\n *     functionName: 'balanceOf',\n *     args: ['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],\n *   })\n *   console.log(`Balance: ${balance}`) // Returns the decoded uint256 as a bigint\n *\n *   // Write to contract (non-view function with impersonation)\n *   const result = await tevmContract(client, {\n *     abi,\n *     address: '0x4200000000000000000000000000000000000042', // OP token\n *     functionName: 'transfer',\n *     args: ['0x1234567890123456789012345678901234567890', 100n],\n *     from: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', // Impersonate this address\n *     createTransaction: true, // Create actual transaction that needs mining\n *   })\n *\n *   // Transaction needs to be mined to take effect\n *   await client.mine()\n *\n *   console.log(`Transfer result: ${result}`) // true\n *\n *   // Optional: With execution tracing\n *   const tracedResult = await tevmContract(client, {\n *     abi,\n *     address: '0x4200000000000000000000000000000000000042',\n *     functionName: 'balanceOf',\n *     args: ['0x1234567890123456789012345678901234567890'],\n *     onStep: (step, next) => {\n *       console.log(`Opcode: ${step.opcode.name}`)\n *       next()\n *     }\n *   })\n * }\n *\n * example()\n * ```\n *\n * @example\n * ```typescript\n * // Using with TEVM contract imports from the bundler\n * import { tevmContract } from 'tevm/actions'\n * import { createClient } from 'viem'\n * import { createTevmTransport } from 'tevm'\n * import { MyToken } from './MyToken.sol' // Direct Solidity import\n *\n * const client = createClient({\n *   transport: createTevmTransport(),\n *   chain: {\n *     id: 1,\n *     name: 'Local TEVM'\n *   }\n * })\n *\n * async function example() {\n *   // Deploy the contract first\n *   const deployResult = await tevmDeploy(client, MyToken.deploy(\"My Token\", \"MTK\"))\n *   await client.mine()\n *\n *   // Now use tevmContract with the imported contract\n *   const result = await tevmContract(client, {\n *     ...MyToken.read.balanceOf(), // Spread the contract's read method\n *     args: ['0x1234567890123456789012345678901234567890'],\n *     address: deployResult.createdAddress,\n *   })\n *\n *   console.log(`Balance: ${result}`)\n * }\n * ```\n *\n * @see [ContractParams](https://tevm.sh/reference/tevm/actions/type-aliases/contractparams/) for options reference.\n * @see [ContractResult](https://tevm.sh/reference/tevm/actions/type-aliases/contractresult/) for return values reference.\n * @see [BaseCallParams](https://tevm.sh/reference/tevm/actions/type-aliases/basecallparams-1/) for the base call parameters.\n * @see [tevmCall](https://tevm.sh/reference/tevm/memory-client/functions/tevmcall/) for the lower-level call interface.\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/)\n * @see [TEVM Contracts Guide](https://tevm.sh/learn/contracts/)\n * @throws Will throw if the contract call reverts. The error will contain the decoded revert reason when available.\n */\nexport const tevmContract = async (client, params) => {\n\t// TODO this shouldn't need to be any any\n\treturn contractHandler(client.transport.tevm)(/** @type {any}*/ (params))\n}\n","import { deployHandler } from '@tevm/actions'\n\n/**\n * A tree-shakeable version of the `tevmDeploy` action for viem.\n * Deploys a smart contract to the in-memory blockchain with comprehensive deployment options and tracing capabilities.\n *\n * This function handles the complete contract deployment process:\n * 1. Encoding constructor arguments according to the ABI\n * 2. Creating a deployment transaction with the contract bytecode\n * 3. Executing the contract creation code in the EVM\n * 4. Returning the deployment results including the new contract's address\n *\n * **Important Mining Consideration:**\n * The contract deployment is processed immediately, but the contract is not officially added to blockchain state\n * until the transaction is mined. In manual mining mode (the default), you must explicitly call `client.mine()`\n * after deployment before interacting with the contract.\n *\n * **Deployment Strategies:**\n * - **Standard Transaction Deployment**: Creates a transaction that must be mined (used by this function)\n * - **Alternative - Direct State Injection**: For testing scenarios, you can use `tevmSetAccount` to directly\n *   inject contract bytecode into state without a formal deployment transaction\n *\n * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n * @param {import('@tevm/actions').DeployParams & import('@tevm/actions').CallEvents} params - Parameters for the contract deployment, including ABI, bytecode, and constructor arguments.\n * @returns {Promise<import('@tevm/actions').DeployResult>} The result of the contract deployment, including the created contract address, transaction hash, and execution details.\n *\n * @example\n * ```typescript\n * import { tevmDeploy } from 'tevm/actions'\n * import { createClient, http, parseAbi } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n *\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: { transport: http('https://mainnet.optimism.io')({}) },\n *     mining: { auto: true } // Optional: enable auto-mining for convenience\n *   }),\n *   chain: optimism,\n * })\n *\n * async function deployStandardERC20() {\n *   // Define contract ABI and bytecode\n *   const abi = parseAbi([\n *     'constructor(string name, string symbol, uint8 decimals)',\n *     'function balanceOf(address) view returns (uint256)',\n *     'function transfer(address to, uint256 amount) returns (bool)'\n *   ])\n *   const bytecode = '0x60806040523480156100...' // ERC20 bytecode\n *\n *   // Deploy with constructor arguments and sender address\n *   const result = await tevmDeploy(client, {\n *     abi,\n *     bytecode,\n *     args: ['My Test Token', 'MTT', 18],\n *     from: '0x1234567890123456789012345678901234567890',\n *\n *     // Optional: trace the deployment execution step by step\n *     onStep: (step, next) => {\n *       console.log(`Executing ${step.opcode.name} at PC=${step.pc}`)\n *       next() // Must call next() to continue execution\n *     }\n *   })\n *\n *   // In manual mining mode, transaction must be mined\n *   if (!client.transport.tevm.mining?.auto) {\n *     await client.mine()\n *   }\n *\n *   console.log(`Contract deployed at: ${result.createdAddress}`)\n *   console.log(`Gas used: ${result.executionGasUsed}`)\n *\n *   // Get transaction receipt after mining\n *   const receipt = await client.getTransactionReceipt({\n *     hash: result.transactionHash\n *   })\n *   console.log(`Block number: ${receipt.blockNumber}`)\n *\n *   return result.createdAddress\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Using with direct Solidity imports via TEVM bundler\n * import { tevmDeploy } from 'tevm/actions'\n * import { createClient, http } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n * import { MyToken } from './MyToken.sol' // Direct Solidity import\n *\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: { transport: http('https://mainnet.optimism.io')({}) }\n *   }),\n *   chain: optimism,\n * })\n *\n * async function example() {\n *   // The imported contract has a pre-configured deploy function\n *   const result = await tevmDeploy(client,\n *     MyToken.deploy('My Token', 'MTK', 18)\n *   )\n *\n *   // Mine the deployment transaction\n *   await client.mine()\n *\n *   // Interact with the deployed contract\n *   const deployedContract = {\n *     ...MyToken,\n *     address: result.createdAddress\n *   }\n *\n *   await client.tevmContract({\n *     ...deployedContract.write.mint(\n *       '0x1234567890123456789012345678901234567890',\n *       1000000n\n *     ),\n *     from: '0x1234567890123456789012345678901234567890'\n *   })\n *\n *   await client.mine()\n * }\n * ```\n *\n * @see [DeployParams](https://tevm.sh/reference/tevm/actions/type-aliases/deployparams/) for options reference.\n * @see [DeployResult](https://tevm.sh/reference/tevm/actions/type-aliases/deployresult/) for return values reference.\n * @see [BaseCallParams](https://tevm.sh/reference/tevm/actions/type-aliases/basecallparams-1/) for the base call parameters.\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/)\n * @see [tevmSetAccount](https://tevm.sh/reference/tevm/actions/functions/setaccounthandler/) for putting contract bytecode into the state without deploying.\n * @see [TEVM Bundler Guide](https://tevm.sh/learn/solidity-imports/) for using the TEVM bundler to deploy contracts.\n * @see [tevmContract](https://tevm.sh/reference/tevm/memory-client/functions/tevmcontract/) for interacting with deployed contracts.\n *\n * @throws Will throw if the contract deployment fails due to reverts in constructor execution, invalid bytecode, or insufficient gas.\n */\nexport const tevmDeploy = async (client, params) => {\n\treturn deployHandler(client.transport.tevm)(params)\n}\n","import { dumpStateHandler } from '@tevm/actions'\n\n/**\n * A tree-shakeable version of the `tevmDumpState` action for viem.\n * Exports the entire blockchain state from TEVM into a serializable JavaScript object.\n *\n * This function captures a complete snapshot of the current blockchain state, including:\n * - All account balances, nonces, and storage\n * - Smart contract bytecode\n * - Transaction receipts\n * - Block headers and history\n * - Current blockchain parameters (latest block, gas price, etc.)\n *\n * The returned state object can be used for:\n * - Persisting state between application sessions\n * - Backing up blockchain state before running test scenarios\n * - Transferring state between different TEVM instances\n * - Creating reproducible environments for debugging\n * - Defining pre-configured test fixtures\n *\n * This function works in conjunction with `tevmLoadState` to provide a complete state\n * serialization and restoration system. The output is serializable using standard\n * JSON.stringify() though you may need to handle BigInt conversion depending on your\n * platform (see the example below).\n *\n * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n * @returns {Promise<import('@tevm/actions').DumpStateResult>} A serializable object containing the complete blockchain state.\n *\n * @example\n * ```typescript\n * import { tevmDumpState, tevmLoadState } from 'tevm/actions'\n * import { createClient, http, parseEther } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n * import fs from 'fs/promises'\n *\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: { transport: http('https://mainnet.optimism.io')({}) }\n *   }),\n *   chain: optimism,\n * })\n *\n * async function saveAndRestoreState() {\n *   // Set up initial state\n *   await client.setBalance({\n *     address: '0x1234567890123456789012345678901234567890',\n *     value: parseEther('100')\n *   })\n *   await client.mine() // Mine a block to update state\n *\n *   // Dump the entire blockchain state\n *   const state = await tevmDumpState(client)\n *\n *   // Serialize state to JSON (handling BigInt conversion)\n *   const serializedState = JSON.stringify(state, (_, value) =>\n *     typeof value === 'bigint' ? value.toString() : value\n *   )\n *\n *   // Save to file\n *   await fs.writeFile('blockchain-snapshot.json', serializedState)\n *   console.log('State saved to blockchain-snapshot.json')\n *\n *   // Later, in another session or process:\n *\n *   // Read the state from file\n *   const savedState = JSON.parse(\n *     await fs.readFile('blockchain-snapshot.json', 'utf8'),\n *     (_, value) => {\n *       // Restore BigInt values\n *       if (typeof value === 'string' && /^\\d+n$/.test(value)) {\n *         return BigInt(value.slice(0, -1))\n *       }\n *       return value\n *     }\n *   )\n *\n *   // Create a new client with the saved state\n *   const newClient = createClient({\n *     transport: createTevmTransport(),\n *     chain: optimism,\n *   })\n *\n *   // Load the saved state\n *   await tevmLoadState(newClient, savedState)\n *\n *   // Verify the state was restored\n *   const balance = await newClient.getBalance({\n *     address: '0x1234567890123456789012345678901234567890'\n *   })\n *   console.log('Restored balance:', balance) // Should be 100 ETH\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Using with the SyncStoragePersister for automatic persistence\n * import { createMemoryClient, createSyncPersister } from 'tevm'\n *\n * // Create a persister that saves to localStorage (in browser)\n * // or to a file (in Node.js)\n * const persister = createSyncPersister({\n *   storage: localStorage, // or use a file-based storage adapter\n *   key: 'tevm-state'      // storage key\n * })\n *\n * // Create a client with automatic persistence\n * const client = createMemoryClient({\n *   persister,\n *   // State will be automatically loaded from storage on startup\n *   // and saved to storage periodically and on shutdown\n * })\n * ```\n *\n * @see [DumpStateResult](https://tevm.sh/reference/tevm/actions/type-aliases/dumpstateresult/) for return value structure.\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/)\n * @see [tevmLoadState](https://tevm.sh/reference/tevm/actions/functions/tevmloadstate/) for restoring the state.\n * @see [SyncStoragePersister](https://tevm.sh/reference/tevm/sync-storage-persister/functions/createsyncpersister/) for automatic state persistence.\n */\nexport const tevmDumpState = async (client) => {\n\treturn dumpStateHandler(client.transport.tevm)()\n}\n","import { getAccountHandler } from '@tevm/actions'\n\n/**\n * A tree-shakeable version of the `tevmGetAccount` action for viem.\n * Retrieves detailed account information from the TEVM state, including balance, nonce, code, and optionally storage.\n *\n * This function provides a comprehensive view of an Ethereum account's state within the TEVM environment.\n * It returns account properties including:\n * - Address (the requested account address)\n * - Balance (in wei)\n * - Nonce (transaction count)\n * - Code (bytecode for contract accounts)\n * - Storage (optionally, contract storage slots and values)\n *\n * The `returnStorage` parameter controls whether the contract's storage is included in the response:\n * - When `false` (default): Only basic account information is returned, which is more efficient\n * - When `true`: Contract storage slots and values are also returned\n *\n * **Important fork mode considerations:**\n * In fork mode, the function only returns storage slots that have already been accessed and cached in the local state.\n * If a storage slot hasn't been previously accessed in your TEVM session, it won't appear in the results even with\n * `returnStorage: true`. To ensure all relevant storage is included, you may need to interact with the contract first.\n *\n * **Performance note:** Requesting storage for contracts with many storage slots can be computationally expensive\n * and produce large response objects. Use `returnStorage: true` judiciously for contracts with known limited storage.\n *\n * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n * @param {import('@tevm/actions').GetAccountParams} params - Parameters for retrieving the account information.\n * @returns {Promise<import('@tevm/actions').GetAccountResult>} The account information, including address, balance, nonce, code, and optionally storage.\n *\n * @example\n * ```typescript\n * import { tevmGetAccount } from 'tevm/actions'\n * import { createClient, http } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n *\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: { transport: http('https://mainnet.optimism.io')({}) }\n *   }),\n *   chain: optimism,\n * })\n *\n * async function example() {\n *   // Get EOA (externally owned account) information\n *   const userAccount = await tevmGetAccount(client, {\n *     address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045',\n *   })\n *   console.log(`Balance: ${userAccount.balance}`)\n *   console.log(`Nonce: ${userAccount.nonce}`)\n *\n *   // Get contract account with storage\n *   const contractAccount = await tevmGetAccount(client, {\n *     address: '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984', // UNI token\n *     returnStorage: true,\n *   })\n *   console.log(`Contract bytecode: ${contractAccount.code}`)\n *   console.log(`Storage slots: ${Object.keys(contractAccount.storage || {}).length}`)\n *\n *   // Storage is a mapping of hex slot keys to hex values\n *   // Both are represented as hex strings\n *   if (contractAccount.storage) {\n *     for (const [slot, value] of Object.entries(contractAccount.storage)) {\n *       console.log(`Slot ${slot}: ${value}`)\n *     }\n *   }\n * }\n *\n * example()\n * ```\n *\n * @see [GetAccountParams](https://tevm.sh/reference/tevm/actions/type-aliases/getaccountparams/) for options reference.\n * @see [GetAccountResult](https://tevm.sh/reference/tevm/actions/type-aliases/getaccountresult/) for return values reference.\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/)\n * @see [tevmSetAccount](https://tevm.sh/reference/tevm/actions/functions/setaccounthandler/) for modifying account state\n */\nexport const tevmGetAccount = async (client, params) => {\n\treturn getAccountHandler(client.transport.tevm)(params)\n}\n","import { loadStateHandler } from '@tevm/actions'\n\n/**\n * A tree-shakeable version of the `tevmLoadState` action for viem.\n * Imports a previously saved blockchain state into TEVM, completely replacing the current state.\n *\n * This function imports a complete blockchain state snapshot that was previously created using\n * `tevmDumpState`, restoring:\n *\n * - All account balances, nonces, and storage\n * - Smart contract bytecode\n * - Transaction receipts and history\n * - Block headers and chain history\n * - Current blockchain parameters\n *\n * When called, this function will:\n * 1. Reset the current blockchain state completely\n * 2. Import all accounts, contracts, and their state from the provided state object\n * 3. Rebuild the blockchain structure with all blocks and transactions\n * 4. Reset the current block pointer and other blockchain parameters\n *\n * This provides a powerful mechanism for:\n * - Creating pre-defined test environments\n * - Implementing \"save points\" in applications\n * - Sharing reproducible blockchain states between systems\n * - Restoring state across application sessions\n *\n * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n * @param {import('@tevm/actions').LoadStateParams} params - The serialized state object previously generated by tevmDumpState.\n * @returns {Promise<import('@tevm/actions').LoadStateResult>} An object indicating the success or failure of the state loading operation.\n *\n * @example\n * ```typescript\n * import { tevmLoadState } from 'tevm/actions'\n * import { createClient, http } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n * import fs from 'fs/promises'\n *\n * const client = createClient({\n *   transport: createTevmTransport(),\n *   chain: optimism,\n * })\n *\n * async function loadSavedState() {\n *   try {\n *     // Read the serialized state from file\n *     const serializedState = await fs.readFile('blockchain-snapshot.json', 'utf8')\n *\n *     // Parse the state, handling BigInt values\n *     const state = JSON.parse(serializedState, (_, value) => {\n *       // Convert string representations of BigInt back to actual BigInt\n *       if (typeof value === 'string' && /^\\d+n$/.test(value)) {\n *         return BigInt(value.slice(0, -1))\n *       }\n *       return value\n *     })\n *\n *     // Load the state into TEVM\n *     await tevmLoadState(client, state)\n *\n *     // Verify state was loaded by checking chain data\n *     const blockNumber = await client.getBlockNumber()\n *     console.log(`Restored blockchain at block: ${blockNumber}`)\n *\n *     // Now the client has the exact same state as when tevmDumpState was called\n *     // All accounts, contracts, balances, storage, and history are restored\n *   } catch (error) {\n *     console.error('Failed to load state:', error)\n *   }\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Creating a test fixture with predefined state\n * import { createMemoryClient } from 'tevm'\n * import predefinedState from './test-fixtures/advanced-defi-setup.json'\n *\n * async function createTestEnvironment() {\n *   // Start with a clean client\n *   const client = createMemoryClient()\n *\n *   // Load the predefined test state\n *   await client.tevmLoadState(predefinedState)\n *\n *   // The client now has a complete test environment with:\n *   // - Predefined accounts with specific balances\n *   // - Deployed contracts at known addresses\n *   // - Contracts with specific storage values\n *   // - Transaction history if needed for testing\n *\n *   return client\n * }\n *\n * // In tests:\n * const client = await createTestEnvironment()\n * // Run tests against the predefined environment...\n * ```\n *\n * @see [LoadStateParams](https://tevm.sh/reference/tevm/actions/type-aliases/loadstateparams/) for parameter structure details.\n * @see [LoadStateResult](https://tevm.sh/reference/tevm/actions/type-aliases/loadstateresult/) for return value structure.\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/)\n * @see [tevmDumpState](https://tevm.sh/reference/tevm/actions/functions/tevmdumpstate/) for creating serializable state snapshots.\n * @see [SyncStoragePersister](https://tevm.sh/reference/tevm/sync-storage-persister/functions/createsyncpersister/) for automatic state persistence.\n *\n * @throws {Error} If the provided state object is invalid or incompatible with the current TEVM version.\n */\nexport const tevmLoadState = async (client, params) => {\n\treturn loadStateHandler(client.transport.tevm)(params)\n}\n","import { mineHandler } from '@tevm/actions'\n\n/**\n * A tree-shakeable version of the `tevmMine` action for viem.\n * Mines new blocks in the TEVM blockchain, finalizing pending transactions and updating blockchain state.\n *\n * In TEVM, transactions (like contract deployments, transfers, or contract calls with `createTransaction: true`)\n * are processed immediately but don't affect the blockchain state until they're included in a mined block.\n * This function advances the blockchain by mining blocks containing any pending transactions.\n *\n * **Key Mining Concepts:**\n * - Mining finalizes transactions and updates the canonical blockchain state\n * - All pending transactions are included in blocks when mining\n * - Block timestamps advance according to the specified interval\n * - Mining creates new blocks regardless of whether there are pending transactions\n * - The returned block hashes can be used to query block information or transaction receipts\n *\n * **Mining Modes in TEVM:**\n * 1. **Manual Mining**: Default mode where you explicitly call `tevmMine` to mine blocks\n * 2. **Auto Mining**: When enabled, automatically mines after every transaction\n * 3. **Interval Mining**: When enabled, mines blocks at a specified time interval\n *\n * The manual mining mode gives you precise control over when state changes take effect, making it\n * ideal for step-by-step testing and debugging scenarios.\n *\n * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n * @param {import('@tevm/actions').MineParams} [params] - Optional parameters for mining blocks.\n * @returns {Promise<import('@tevm/actions').MineResult>} The result of mining blocks, including an array of block hashes.\n *\n * @example\n * ```typescript\n * import { tevmMine } from 'tevm/actions'\n * import { createClient, http, parseEther } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n *\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: { transport: http('https://mainnet.optimism.io')({}) },\n *     mining: { auto: false } // Explicit manual mining mode\n *   }),\n *   chain: optimism,\n * })\n *\n * async function example() {\n *   // Set up two accounts\n *   const sender = '0x1234567890123456789012345678901234567890'\n *   const recipient = '0x0987654321098765432109876543210987654321'\n *\n *   // Give sender some ETH\n *   await client.setBalance({\n *     address: sender,\n *     value: parseEther('10')\n *   })\n *\n *   // Send transaction (processed but not yet in state)\n *   const txHash = await client.sendTransaction({\n *     from: sender,\n *     to: recipient,\n *     value: parseEther('1')\n *   })\n *\n *   // Balances don't reflect the transfer yet\n *   console.log('Pre-mine recipient balance:',\n *     await client.getBalance({ address: recipient })) // 0n\n *\n *   // Mine a single block to include the transaction\n *   const result = await tevmMine(client)\n *   console.log('Mined block hash:', result.blockHashes[0])\n *\n *   // Now balances reflect the transfer\n *   console.log('Post-mine recipient balance:',\n *     await client.getBalance({ address: recipient })) // 1000000000000000000n (1 ETH)\n *\n *   // Get transaction receipt after mining\n *   const receipt = await client.getTransactionReceipt({ hash: txHash })\n *   console.log('Transaction mined in block:', receipt.blockNumber)\n *\n *   // Mine multiple blocks with custom timestamp intervals\n *   const moreBlocks = await tevmMine(client, {\n *     blockCount: 5,        // Mine 5 blocks\n *     interval: 10          // 10 second intervals between blocks\n *   })\n *\n *   // Block timestamps will be 10 seconds apart\n *   for (const hash of moreBlocks.blockHashes) {\n *     const block = await client.getBlock({ blockHash: hash })\n *     console.log(`Block ${block.number}: timestamp ${block.timestamp}`)\n *   }\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Configure different mining modes when creating the client\n * import { createMemoryClient, http } from 'tevm'\n *\n * // Auto-mining mode (mines after every transaction)\n * const autoMineClient = createMemoryClient({\n *   mining: { auto: true },\n *   fork: { transport: http('https://mainnet.optimism.io')({}) }\n * })\n *\n * // Interval mining mode (mines every 5 seconds)\n * const intervalMineClient = createMemoryClient({\n *   mining: { interval: 5000 }, // milliseconds\n *   fork: { transport: http('https://mainnet.optimism.io')({}) }\n * })\n *\n * // Manual mining mode (explicit mining required)\n * const manualMineClient = createMemoryClient({\n *   mining: { auto: false, interval: 0 }, // explicitly disable auto modes\n *   fork: { transport: http('https://mainnet.optimism.io')({}) }\n * })\n * ```\n *\n * @see [MineParams](https://tevm.sh/reference/tevm/actions/type-aliases/mineparams/) for options reference.\n * @see [MineResult](https://tevm.sh/reference/tevm/actions/type-aliases/mineresult/) for return values reference.\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/)\n * @see [createMemoryClient](https://tevm.sh/reference/tevm/memory-client/functions/creatememoryclient/) for configuring mining modes.\n */\nexport const tevmMine = async (client, params) => {\n\treturn mineHandler(client.transport.tevm)(params)\n}\n","/**\n * A tree-shakeable version of the `tevmReady` action for viem.\n * Waits for TEVM initialization to complete, which is especially important when forking.\n *\n * This function ensures that the TEVM instance is fully initialized and ready for operations.\n * It resolves to `true` when initialization is complete, and throws an error if initialization fails.\n *\n * The initialization process handles:\n *\n * - Setting up the EVM execution environment\n * - Initializing blockchain state and storage structures\n * - **For forked instances**: Establishing connection to the remote network and loading initial state\n * - Setting up transaction pool and receipt management systems\n * - Loading any persisted state (when using a persister)\n * - Configuring mining modes and other operational parameters\n *\n * **When to use this function:**\n *\n * While all TEVM actions implicitly wait for initialization to complete, explicitly calling\n * `tevmReady()` is recommended in these scenarios:\n *\n * - **Forking environments**: To ensure network connection is established before proceeding\n * - **UI applications**: To show loading indicators during initialization\n * - **Testing**: To separate initialization time from operation time in benchmarks\n * - **Error handling**: To catch initialization failures early with proper error handling\n * - **Complex scripts**: To ensure initialization is complete before proceeding with multiple operations\n *\n * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n * @returns {Promise<true>} Resolves to `true` when ready, rejects if initialization fails.\n * @throws {Error} If initialization fails, with details about the specific failure.\n *\n * @example\n * ```typescript\n * import { createMemoryClient, http } from 'tevm'\n * import { optimism } from 'tevm/common'\n *\n * async function main() {\n *   // Create a client that forks from Optimism mainnet\n *   const client = createMemoryClient({\n *     fork: {\n *       transport: http('https://mainnet.optimism.io')({})\n *     },\n *     common: optimism,\n *   })\n *\n *   try {\n *     // Show loading indicator in UI\n *     showLoadingIndicator('Connecting to Optimism...')\n *\n *     // Wait for fork to initialize\n *     await client.tevmReady()\n *\n *     // Hide loading indicator\n *     hideLoadingIndicator()\n *\n *     // Now it's safe to interact with the forked network\n *     const blockNumber = await client.getBlockNumber()\n *     console.log(`Connected to Optimism block ${blockNumber}`)\n *\n *     // Continue with application logic...\n *   } catch (error) {\n *     // Handle initialization errors gracefully\n *     showErrorMessage(`Failed to connect: ${error.message}`)\n *     console.error('TEVM initialization error:', error)\n *   }\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Using with promise.race() for timeout handling\n * import { createMemoryClient, http } from 'tevm'\n *\n * async function initWithTimeout() {\n *   const client = createMemoryClient({\n *     fork: {\n *       transport: http('https://mainnet.ethereum.org')({})\n *     }\n *   })\n *\n *   // Create a timeout promise\n *   const timeout = new Promise((_, reject) => {\n *     setTimeout(() => reject(new Error('Fork initialization timed out')), 30000)\n *   })\n *\n *   try {\n *     // Race initialization against timeout\n *     await Promise.race([\n *       client.tevmReady(),\n *       timeout\n *     ])\n *\n *     console.log('TEVM initialized successfully')\n *     return client\n *   } catch (error) {\n *     console.error('Initialization failed:', error)\n *     throw error\n *   }\n * }\n * ```\n *\n * @example\n * ```typescript\n * // For performance benchmarking\n * import { createMemoryClient } from 'tevm'\n * import { optimism } from 'tevm/common'\n *\n * async function benchmark() {\n *   const client = createMemoryClient({\n *     fork: {\n *       transport: http('https://mainnet.optimism.io')({})\n *     },\n *     common: optimism\n *   })\n *\n *   // Measure initialization time separately\n *   console.time('Initialization')\n *   await client.tevmReady()\n *   console.timeEnd('Initialization')\n *\n *   // Now measure operation time separately\n *   console.time('Operations')\n *   for (let i = 0; i < 100; i++) {\n *     await client.getBalance({\n *       address: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'\n *     })\n *   }\n *   console.timeEnd('Operations')\n * }\n * ```\n *\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/) for information about all available actions.\n * @see [Forking Guide](https://tevm.sh/learn/forking/) for details about fork initialization process.\n * @see [createMemoryClient](https://tevm.sh/reference/tevm/memory-client/functions/creatememoryclient/) for client creation options.\n */\nexport const tevmReady = async (client) => {\n\treturn client.transport.tevm.ready()\n}\n","import { setAccountHandler } from '@tevm/actions'\n\n/**\n * A tree-shakeable version of the `tevmSetAccount` action for viem.\n * Sets or updates an account in TEVM's state.\n *\n * This function allows you to directly manipulate any aspect of an account's state without needing\n * to send transactions. It can be used to:\n *\n * - Set an EOA's balance and nonce\n * - Deploy a contract directly (without executing constructor code) by setting its bytecode\n * - Set a contract's storage slots to specific values\n * - Create a complete test environment with multiple accounts and contracts\n *\n * This is especially useful for:\n * - Setting up complex test environments with pre-defined state\n * - Testing edge cases that would be difficult to set up with transactions\n * - Directly inserting contract bytecode without going through deployment\n * - Creating test accounts with specific balances\n *\n * @param {import('viem').Client<import('./TevmTransport.js').TevmTransport<string>>} client - The viem client configured with TEVM transport.\n * @param {import('@tevm/actions').SetAccountParams} params - Parameters for setting the account.\n * @returns {Promise<import('@tevm/actions').SetAccountResult>} The result of setting the account.\n *\n * @example\n * ```typescript\n * import { tevmSetAccount } from 'tevm/actions'\n * import { createClient, http, parseEther } from 'viem'\n * import { optimism } from 'tevm/common'\n * import { createTevmTransport } from 'tevm'\n *\n * const client = createClient({\n *   transport: createTevmTransport({\n *     fork: { transport: http('https://mainnet.optimism.io')({}) }\n *   }),\n *   chain: optimism,\n * })\n *\n * async function example() {\n *   // Create an EOA with 100 ETH\n *   await tevmSetAccount(client, {\n *     address: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',\n *     balance: parseEther('100'),\n *     nonce: 0n,\n *   })\n *\n *   // Verify the balance was set\n *   const balance = await client.getBalance({\n *     address: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'\n *   })\n *   console.log('Account balance:', balance) // 100000000000000000000n\n * }\n *\n * example()\n * ```\n *\n * @example\n * ```typescript\n * // Deploy a contract directly (without executing constructor code)\n * import { tevmSetAccount } from 'tevm/actions'\n * import { createMemoryClient } from 'tevm'\n * import { numberToHex } from 'viem'\n * import { SimpleStorage } from './SimpleStorage.sol'\n *\n * const client = createMemoryClient()\n *\n * async function example() {\n *   // Set up a contract at a specific address with initial storage\n *   const contractAddress = '0x0000000000000000000000000000000000000123'\n *\n *   await tevmSetAccount(client, {\n *     address: contractAddress,\n *     // Deploy the contract bytecode directly\n *     deployedBytecode: SimpleStorage.deployedBytecode,\n *     // Initialize storage slots (optional)\n *     state: {\n *       // Set the value at storage slot 0 to 42\n *       [`0x${'0'.repeat(64)}`]: numberToHex(42n),\n *     },\n *   })\n *\n *   // Create a contract instance at this address\n *   const contract = SimpleStorage.withAddress(contractAddress)\n *\n *   // Read from the contract to verify the storage was set\n *   const value = await contract.read.get()\n *   console.log('Contract value:', value) // Should be 42n\n * }\n *\n * example()\n * ```\n *\n * @throws Will throw if the address is invalid.\n * @throws Will throw if the deployedBytecode is invalid hex.\n * @throws Will throw if any storage slot key or value is invalid hex.\n *\n * @see [SetAccountParams](https://tevm.sh/reference/tevm/actions/type-aliases/setaccountparams/) for options reference.\n * @see [SetAccountResult](https://tevm.sh/reference/tevm/actions/type-aliases/setaccountresult/) for return values reference.\n * @see [TEVM Actions Guide](https://tevm.sh/learn/actions/)\n * @see [tevmDeploy](https://tevm.sh/reference/tevm/actions/functions/tevmdeploy/) for deploying contracts via transactions.\n */\nexport const tevmSetAccount = async (client, params) => {\n\treturn setAccountHandler(client.transport.tevm)(params)\n}\n"]}