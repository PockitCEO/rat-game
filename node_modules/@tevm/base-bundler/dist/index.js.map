{"version":3,"sources":["../src/getContractPath.js","../src/readCache.js","../src/writeCache.js","../src/resolveModuleAsync.js","../src/readCacheSync.js","../src/writeCacheSync.js","../src/resolveModuleSync.js","../src/bundler.js"],"names":["require","generateRuntime"],"mappings":"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","file":"index.js","sourcesContent":["import { createRequire } from 'node:module'\n\n/**\n * Array of possible contract package names to search for in the project\n * @type {readonly ['tevm/contract', '@tevm/contract']}\n */\nconst contractPackages = ['tevm/contract', '@tevm/contract']\n\n/**\n * Detects which version of the contract package is installed in the project.\n * This function tries to resolve either 'tevm/contract' or '@tevm/contract'\n * from the given base path, and returns the first one it finds.\n *\n * @param {string} basePath - The base directory path to search from\n * @returns {'tevm/contract' | '@tevm/contract'} - The resolved contract package name\n * @throws {Error} - Doesn't throw, but logs a warning if neither package is found\n *\n * @example\n * ```javascript\n * import { getContractPath } from '@tevm/base-bundler'\n *\n * // Get the correct contract package for the current project\n * const contractPackage = getContractPath(process.cwd())\n * console.log(contractPackage) // 'tevm/contract' or '@tevm/contract'\n * ```\n */\nexport const getContractPath = (basePath) => {\n\tconst require = createRequire(basePath.endsWith('/') ? basePath : `${basePath}/`)\n\tfor (const contractPackage of contractPackages) {\n\t\ttry {\n\t\t\trequire.resolve(contractPackage)\n\t\t\treturn contractPackage\n\t\t} catch (_e) {}\n\t}\n\tconsole.warn(\n\t\t`Could not find tevm/contract or @tevm/contract in ${basePath}!. Please install it with \\`npm i @tevm/contract\\` \\`pnpm i @tevm/contract\\` or \\`yarn add tevm/contract\\`\nFalling back to attempting tevm/contract`,\n\t)\n\treturn 'tevm/contract'\n}\n","/**\n * Reads Solidity compilation artifacts from the cache asynchronously.\n * This function checks if cached artifacts exist and if they satisfy the requested\n * AST and bytecode inclusion requirements.\n *\n * @param {import('@tevm/compiler').Logger} logger - Logger for error reporting\n * @param {import('@tevm/bundler-cache').Cache} cache - Cache instance to read from\n * @param {string} modulePath - Path to the Solidity module\n * @param {boolean} includeAst - Whether to include AST in the result\n * @param {boolean} includeBytecode - Whether to include bytecode in the result\n * @returns {ReturnType<import('@tevm/bundler-cache').Cache['readArtifacts']>} - The cached artifacts if found and valid, otherwise undefined\n * @throws {Error} - Doesn't throw, but logs errors and returns undefined on failure\n *\n * @example\n * ```javascript\n * import { readCache } from '@tevm/base-bundler'\n * import { createCache } from '@tevm/bundler-cache'\n *\n * const cache = createCache()\n * const logger = console\n *\n * // Read artifacts for Counter.sol\n * const artifacts = await readCache(\n *   logger,\n *   cache,\n *   './contracts/Counter.sol',\n *   true, // include AST\n *   true  // include bytecode\n * )\n *\n * if (artifacts) {\n *   console.log('Cache hit! Using cached artifacts')\n * } else {\n *   console.log('Cache miss. Need to recompile')\n * }\n * ```\n */\nexport const readCache = async (logger, cache, modulePath, includeAst, includeBytecode) => {\n\ttry {\n\t\tconst cachedArtifacts = await cache.readArtifacts(modulePath)\n\n\t\tconst isCachedAsts = () => cachedArtifacts?.asts && Object.keys(cachedArtifacts.asts).length > 0\n\t\tconst isCachedBytecode = () =>\n\t\t\tObject.values(cachedArtifacts?.artifacts ?? {}).some((artifact) => artifact.evm.deployedBytecode)\n\n\t\tif (!cachedArtifacts) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (includeAst && !isCachedAsts()) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (includeBytecode && !isCachedBytecode()) {\n\t\t\treturn undefined\n\t\t}\n\t\treturn cachedArtifacts\n\t} catch (e) {\n\t\tlogger.error(\n\t\t\t`there was an error in tevm plugin reading cache for ${modulePath}. Continuing without cache. This may hurt performance`,\n\t\t)\n\t\tlogger.error(/** @type any */ (e))\n\t\treturn undefined\n\t}\n}\n","/**\n * Writes compilation artifacts and generated code to the cache asynchronously.\n * This function can selectively write artifacts based on the provided flag,\n * and it also writes the generated TypeScript or JavaScript code to the\n * appropriate cache location based on the module type.\n *\n * @param {import('./types.js').Logger} logger - Logger for warning and error reporting\n * @param {import('@tevm/bundler-cache').Cache} cache - Cache instance to write to\n * @param {import('@tevm/compiler').ResolvedArtifacts} artifacts - The compilation artifacts to cache\n * @param {string} code - The generated code content\n * @param {string} modulePath - Path to the Solidity module\n * @param {string} moduleType - Type of module to generate ('dts', 'mjs', 'cjs', 'ts')\n * @param {boolean} writeArtifacts - Whether to write compilation artifacts to cache\n *   This is typically set to false if there was a compilation error, but we still\n *   want to cache error messages in the generated files.\n * @returns {Promise<void>} - A promise that resolves when writing is complete\n * @throws {Error} - Doesn't directly throw, but logs warnings for unsupported module types\n *\n * @example\n * ```javascript\n * import { writeCache } from '@tevm/base-bundler'\n * import { createCache } from '@tevm/bundler-cache'\n *\n * const cache = createCache()\n * const logger = console\n *\n * // After compilation, write results to cache\n * await writeCache(\n *   logger,\n *   cache,\n *   compilationResult, // artifacts from solc compilation\n *   generatedTypeScript, // the generated code\n *   './contracts/Counter.sol',\n *   'dts', // writing .d.ts file\n *   true // write artifacts too\n * )\n * ```\n */\nexport const writeCache = async (\n\tlogger,\n\tcache,\n\tartifacts,\n\tcode,\n\tmodulePath,\n\tmoduleType,\n\t// This is kinda quick and dirty but works for now\n\t// we will skip writing artifacts if there is an error\n\t// but still write dts and mjs files since they always\n\t// fall back to generating an empty file with error messages\n\twriteArtifacts,\n) => {\n\t/**\n\t * @type {Array<Promise<any>>}\n\t */\n\tconst promises = []\n\tif (writeArtifacts) {\n\t\tpromises.push(cache.writeArtifacts(modulePath, artifacts))\n\t}\n\tif (moduleType === 'dts') {\n\t\tpromises.push(cache.writeDts(modulePath, code))\n\t} else if (moduleType === 'mjs') {\n\t\tpromises.push(cache.writeMjs(modulePath, code))\n\t} else {\n\t\tlogger.warn(`No caching for module type ${moduleType}} implemented yet`)\n\t}\n\tawait Promise.all(promises)\n}\n","import { resolveArtifacts } from '@tevm/compiler'\nimport { generateRuntime } from '@tevm/runtime'\nimport { runPromise } from 'effect/Effect'\nimport { readCache } from './readCache.js'\nimport { writeCache } from './writeCache.js'\n\n/**\n * Asynchronously resolves a Solidity module to the specified module format.\n *\n * This function is the core of the bundler's module resolution process. It:\n * 1. Attempts to read from cache first\n * 2. If not cached, compiles the Solidity source and generates artifacts\n * 3. Generates code for the requested module type (dts, mjs, etc.)\n * 4. Writes results to cache (without blocking the resolution)\n * 5. Returns the bundler result\n *\n * @param {import('@tevm/compiler').Logger} logger - Logger for error reporting\n * @param {import('@tevm/config').ResolvedCompilerConfig} config - Compiler configuration\n * @param {import('@tevm/compiler').FileAccessObject} fao - File system access object\n * @param {import('@tevm/solc').Solc} solc - Solidity compiler instance\n * @param {string} modulePath - Path to the Solidity module\n * @param {string} basedir - Base directory for resolving relative paths\n * @param {boolean} includeAst - Whether to include AST in the result\n * @param {boolean} includeBytecode - Whether to include bytecode in the result\n * @param {import('@tevm/runtime').ModuleType} moduleType - Type of module to generate ('dts', 'mjs', 'cjs', 'ts')\n * @param {import('@tevm/bundler-cache').Cache} cache - Cache instance for artifacts\n * @param {'tevm/contract' | '@tevm/contract'} contractPackage - Contract package name to import in generated code\n * @returns {Promise<import('./types.js').BundlerResult>} A promise that resolves to a bundler result object\n * @throws {Error} - Throws if compilation or code generation fails\n *\n * @example\n * ```javascript\n * import { resolveModuleAsync } from '@tevm/base-bundler'\n * import { createCache } from '@tevm/bundler-cache'\n * import { createSolc } from '@tevm/solc'\n * import { loadConfig } from '@tevm/config'\n * import { mkdir, readFile, writeFile } from 'fs/promises'\n * import { existsSync, statSync } from 'fs'\n *\n * // Setup dependencies\n * const config = await loadConfig()\n * const solc = await createSolc()\n * const cache = createCache()\n * const logger = console\n *\n * // File access object\n * const fao = {\n *   readFile: (path, encoding) => readFile(path, { encoding }),\n *   writeFile,\n *   exists: async (path) => existsSync(path),\n *   existsSync,\n *   statSync,\n *   mkdir\n *   // Include other required methods\n * }\n *\n * // Resolve a Solidity file to a TypeScript declaration file\n * const result = await resolveModuleAsync(\n *   logger,\n *   config,\n *   fao,\n *   solc,\n *   './contracts/Counter.sol',\n *   process.cwd(),\n *   true,  // include AST\n *   true,  // include bytecode\n *   'dts', // generate .d.ts file\n *   cache,\n *   '@tevm/contract'\n * )\n *\n * console.log(result.code) // Generated TypeScript declarations\n * ```\n */\nexport const resolveModuleAsync = async (\n\tlogger,\n\tconfig,\n\tfao,\n\tsolc,\n\tmodulePath,\n\tbasedir,\n\tincludeAst,\n\tincludeBytecode,\n\tmoduleType,\n\tcache,\n\tcontractPackage,\n) => {\n\tconst cachedResult = await readCache(logger, cache, modulePath, includeAst, includeBytecode)\n\ttry {\n\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\tcachedResult ??\n\t\t\t(await resolveArtifacts(modulePath, basedir, logger, config, includeAst, includeBytecode, fao, solc))\n\t\tlet code = ''\n\t\tconst artifactsExist = artifacts && Object.keys(artifacts).length > 0\n\t\tif (artifactsExist) {\n\t\t\tcode = await runPromise(generateRuntime(artifacts, moduleType, includeBytecode, contractPackage))\n\t\t} else {\n\t\t\tconst message = `there were no artifacts for ${modulePath}. This is likely a bug in tevm`\n\t\t\tcode = `// ${message}`\n\t\t\tlogger.warn(message)\n\t\t}\n\n\t\t// The `writeCache` function is intentionally not awaited to allow non-blocking cache writes.\n\t\t// This enables the rest of the module resolution to proceed without waiting for the cache operation to complete.\n\t\twriteCache(\n\t\t\tlogger,\n\t\t\tcache,\n\t\t\t{ solcInput, solcOutput, asts, artifacts, modules },\n\t\t\tcode,\n\t\t\tmodulePath,\n\t\t\tmoduleType,\n\t\t\t// This is kinda quick and dirty but works for now\n\t\t\t// We are skipping writing artifacts if there is an error\n\t\t\t// But still write dts and mjs files since they always\n\t\t\t// fall back to generating an empty file with error messages\n\t\t\tartifactsExist,\n\t\t).catch((e) => {\n\t\t\tlogger.error(e)\n\t\t\tlogger.error('there was an error writing to the cache. This may cause peformance issues')\n\t\t})\n\n\t\treturn {\n\t\t\tsolcInput,\n\t\t\tsolcOutput,\n\t\t\tasts,\n\t\t\tmodules,\n\t\t\tcode,\n\t\t}\n\t} catch (e) {\n\t\tlogger.error(`there was an error in tevm plugin resolving .${moduleType}`)\n\t\tlogger.error(/** @type any */ (e))\n\t\tthrow e\n\t}\n}\n","/**\n * Reads Solidity compilation artifacts from the cache synchronously.\n * This function checks if cached artifacts exist and if they satisfy the requested\n * AST and bytecode inclusion requirements. Use this instead of the async version\n * when working in synchronous contexts (like TypeScript compiler plugins).\n *\n * @param {import('@tevm/compiler').Logger} logger - Logger for error reporting\n * @param {import('@tevm/bundler-cache').Cache} cache - Cache instance to read from\n * @param {string} modulePath - Path to the Solidity module\n * @param {boolean} includeAst - Whether to include AST in the result\n * @param {boolean} includeBytecode - Whether to include bytecode in the result\n * @returns {ReturnType<import('@tevm/bundler-cache').Cache['readArtifactsSync']>} - The cached artifacts if found and valid, otherwise undefined\n * @throws {Error} - Doesn't throw, but logs errors and returns undefined on failure\n *\n * @example\n * ```javascript\n * import { readCacheSync } from '@tevm/base-bundler'\n * import { createCache } from '@tevm/bundler-cache'\n *\n * const cache = createCache()\n * const logger = console\n *\n * // Read artifacts for Counter.sol synchronously\n * const artifacts = readCacheSync(\n *   logger,\n *   cache,\n *   './contracts/Counter.sol',\n *   true, // include AST\n *   true  // include bytecode\n * )\n *\n * if (artifacts) {\n *   console.log('Cache hit! Using cached artifacts')\n * } else {\n *   console.log('Cache miss. Need to recompile')\n * }\n * ```\n */\nexport const readCacheSync = (logger, cache, modulePath, includeAst, includeBytecode) => {\n\ttry {\n\t\tconst cachedArtifacts = cache.readArtifactsSync(modulePath)\n\n\t\tconst isCachedAsts = () => cachedArtifacts?.asts && Object.keys(cachedArtifacts.asts).length > 0\n\t\tconst isCachedBytecode = () =>\n\t\t\tObject.values(cachedArtifacts?.artifacts ?? {}).some((artifact) => artifact.evm.deployedBytecode)\n\n\t\tif (!cachedArtifacts) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (includeAst && !isCachedAsts()) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (includeBytecode && !isCachedBytecode()) {\n\t\t\treturn undefined\n\t\t}\n\t\treturn cachedArtifacts\n\t} catch (e) {\n\t\tlogger.error(\n\t\t\t`there was an error in tevm plugin reading cache for ${modulePath}. Continuing without cache. This may hurt performance`,\n\t\t)\n\t\tlogger.error(/** @type any */ (e))\n\t\treturn undefined\n\t}\n}\n","/**\n * Writes compilation artifacts and generated code to the cache synchronously.\n * This is the synchronous version of writeCache, used primarily for TypeScript compiler\n * plugins that require synchronous operations. It writes artifacts and generated code\n * to the cache based on the module type.\n *\n * @param {import('./types.js').Logger} logger - Logger for warning and error reporting\n * @param {import('@tevm/bundler-cache').Cache} cache - Cache instance to write to\n * @param {import('@tevm/compiler').ResolvedArtifacts} artifacts - The compilation artifacts to cache\n * @param {string} code - The generated code content\n * @param {string} modulePath - Path to the Solidity module\n * @param {string} moduleType - Type of module to generate ('dts', 'mjs', 'cjs', 'ts')\n * @param {boolean} writeArtifacts - Whether to write compilation artifacts to cache\n *   This is typically set to false if there was a compilation error, but we still\n *   want to cache error messages in the generated files.\n * @returns {void} - No return value\n * @throws {Error} - May throw if cache operations fail, also logs warnings for unsupported module types\n *\n * @example\n * ```javascript\n * import { writeCacheSync } from '@tevm/base-bundler'\n * import { createCache } from '@tevm/bundler-cache'\n *\n * const cache = createCache()\n * const logger = console\n *\n * // After compilation, write results to cache synchronously\n * writeCacheSync(\n *   logger,\n *   cache,\n *   compilationResult, // artifacts from solc compilation\n *   generatedTypeScript, // the generated code\n *   './contracts/Counter.sol',\n *   'dts', // writing .d.ts file\n *   true // write artifacts too\n * )\n * ```\n */\nexport const writeCacheSync = (\n\tlogger,\n\tcache,\n\tartifacts,\n\tcode,\n\tmodulePath,\n\tmoduleType,\n\t// This is kinda quick and dirty but works for now\n\t// we will skip writing artifacts if there is an error\n\t// but still write dts and mjs files since they always\n\t// fall back to generating an empty file with error messages\n\twriteArtifacts,\n) => {\n\tif (writeArtifacts) {\n\t\tcache.writeArtifactsSync(modulePath, artifacts)\n\t}\n\tif (moduleType === 'dts') {\n\t\tcache.writeDts(modulePath, code)\n\t} else if (moduleType === 'mjs') {\n\t\tcache.writeMjs(modulePath, code)\n\t} else {\n\t\tlogger.warn(`No caching for module type ${moduleType}} implemented yet`)\n\t}\n}\n","import { resolveArtifactsSync } from '@tevm/compiler'\nimport { generateRuntime } from '@tevm/runtime'\nimport { runSync } from 'effect/Effect'\nimport { readCacheSync } from './readCacheSync.js'\nimport { writeCacheSync } from './writeCacheSync.js'\n\n/**\n * Synchronously resolves a Solidity module to the specified module format.\n *\n * This is the synchronous counterpart to resolveModuleAsync, which:\n * 1. Attempts to read from cache first\n * 2. If not cached, compiles the Solidity source and generates artifacts\n * 3. Generates code for the requested module type (dts, mjs, etc.)\n * 4. Writes results to cache\n * 5. Returns the bundler result\n *\n * This synchronous version is primarily used for TypeScript compiler plugins\n * which require synchronous operations.\n *\n * @param {import('@tevm/compiler').Logger} logger - Logger for error reporting\n * @param {import('@tevm/config').ResolvedCompilerConfig} config - Compiler configuration\n * @param {import('@tevm/compiler').FileAccessObject} fao - File system access object\n * @param {import('@tevm/solc').Solc} solc - Solidity compiler instance\n * @param {string} modulePath - Path to the Solidity module\n * @param {string} basedir - Base directory for resolving relative paths\n * @param {boolean} includeAst - Whether to include AST in the result\n * @param {boolean} includeBytecode - Whether to include bytecode in the result\n * @param {import('@tevm/runtime').ModuleType} moduleType - Type of module to generate ('dts', 'mjs', 'cjs', 'ts')\n * @param {import('@tevm/bundler-cache').Cache} cache - Cache instance for artifacts\n * @param {'tevm/contract' | '@tevm/contract'} contractPackage - Contract package name to import in generated code\n * @returns {import('./types.js').BundlerResult} A bundler result object\n * @throws {Error} - Throws if compilation or code generation fails\n *\n * @example\n * ```javascript\n * import { resolveModuleSync } from '@tevm/base-bundler'\n * import { createCache } from '@tevm/bundler-cache'\n * import { createSolc } from '@tevm/solc'\n * import { loadConfig } from '@tevm/config'\n * import { readFileSync, writeFileSync, existsSync, statSync, mkdirSync } from 'fs'\n *\n * // Setup dependencies\n * const config = loadConfigSync() // Hypothetical sync config loader\n * const solc = createSolcSync() // Hypothetical sync solc creator\n * const cache = createCache()\n * const logger = console\n *\n * // File access object\n * const fao = {\n *   readFileSync,\n *   writeFileSync,\n *   existsSync,\n *   statSync,\n *   mkdirSync,\n *   // Include other required methods\n * }\n *\n * // Resolve a Solidity file to a TypeScript declaration file\n * const result = resolveModuleSync(\n *   logger,\n *   config,\n *   fao,\n *   solc,\n *   './contracts/Counter.sol',\n *   process.cwd(),\n *   true,  // include AST\n *   true,  // include bytecode\n *   'dts', // generate .d.ts file\n *   cache,\n *   '@tevm/contract'\n * )\n *\n * console.log(result.code) // Generated TypeScript declarations\n * ```\n */\nexport const resolveModuleSync = (\n\tlogger,\n\tconfig,\n\tfao,\n\tsolc,\n\tmodulePath,\n\tbasedir,\n\tincludeAst,\n\tincludeBytecode,\n\tmoduleType,\n\tcache,\n\tcontractPackage,\n) => {\n\tconst cachedResult = readCacheSync(logger, cache, modulePath, includeAst, includeBytecode)\n\ttry {\n\t\tconst { solcInput, solcOutput, asts, artifacts, modules } =\n\t\t\tcachedResult ?? resolveArtifactsSync(modulePath, basedir, logger, config, includeAst, includeBytecode, fao, solc)\n\t\tlet code = ''\n\t\tconst artifactsExist = artifacts && Object.keys(artifacts).length > 0\n\t\tif (artifactsExist) {\n\t\t\tcode = runSync(generateRuntime(artifacts, moduleType, includeBytecode, contractPackage))\n\t\t} else {\n\t\t\tconst message = `there were no artifacts for ${modulePath}. This is likely a bug in tevm`\n\t\t\tcode = `// ${message}`\n\t\t\tlogger.warn(message)\n\t\t}\n\n\t\twriteCacheSync(\n\t\t\tlogger,\n\t\t\tcache,\n\t\t\t{ solcInput, solcOutput, asts, artifacts, modules },\n\t\t\tcode,\n\t\t\tmodulePath,\n\t\t\tmoduleType,\n\t\t\t// This is kinda quick and dirty but works for now\n\t\t\t// We are skipping writing artifacts if there is an error\n\t\t\t// But still write dts and mjs files since they always\n\t\t\t// fall back to generating an empty file with error messages\n\t\t\tartifactsExist,\n\t\t)\n\n\t\treturn {\n\t\t\tsolcInput: solcInput ?? undefined,\n\t\t\tsolcOutput: solcOutput ?? undefined,\n\t\t\tasts,\n\t\t\tmodules,\n\t\t\tcode,\n\t\t}\n\t} catch (e) {\n\t\tlogger.error(`there was an error in tevm plugin resolving .${moduleType}`)\n\t\tlogger.error(/** @type any */ (e))\n\t\tthrow e\n\t}\n}\n","import { getContractPath } from './getContractPath.js'\nimport { resolveModuleAsync } from './resolveModuleAsync.js'\nimport { resolveModuleSync } from './resolveModuleSync.js'\n\n/**\n * Creates a bundler instance for processing Solidity files into JavaScript and TypeScript.\n *\n * The bundler is the core component of Tevm's build system, providing the capability to:\n * - Compile Solidity files to ABI, bytecode, and AST\n * - Generate TypeScript type definitions from the ABI\n * - Generate JavaScript or TypeScript code for importing contracts\n * - Cache compilation results for better performance\n * - Support multiple module formats (ESM, CJS, TypeScript)\n *\n * This base bundler is used by all Tevm build plugins including TypeScript,\n * Webpack, Vite, Bun, ESBuild, and others.\n *\n * @param {import('@tevm/config').ResolvedCompilerConfig} config - The Tevm compiler configuration\n * @param {import('./types.js').Logger} logger - Logger for error and info reporting\n * @param {import('./types.js').FileAccessObject} fao - File system access object for reading/writing files\n * @param {import('@tevm/solc').Solc} solc - Solidity compiler instance\n * @param {import('@tevm/bundler-cache').Cache} cache - Cache instance for build artifacts\n * @param {'tevm/contract' | '@tevm/contract' | undefined} [contractPackage] - Optional contract package name\n * @returns {ReturnType<import('./types.js').Bundler>} A bundler instance with methods for resolving Solidity modules\n *\n * @example\n * ```javascript\n * import { bundler } from '@tevm/base-bundler'\n * import { createCache } from '@tevm/bundler-cache'\n * import { readFile, writeFile } from 'fs/promises'\n * import { readFileSync, writeFileSync, existsSync, statSync, mkdirSync } from 'fs'\n * import { mkdir, stat } from 'fs/promises'\n * import { createSolc } from '@tevm/solc'\n * import { loadConfig } from '@tevm/config'\n *\n * // Create a file access object with all required methods\n * const fao = {\n *   // Async methods\n *   readFile: (path, encoding) => readFile(path, { encoding }),\n *   writeFile,\n *   exists: async (path) => existsSync(path),\n *   stat,\n *   mkdir,\n *\n *   // Sync methods\n *   readFileSync: (path, encoding) => readFileSync(path, { encoding }),\n *   writeFileSync,\n *   existsSync,\n *   statSync,\n *   mkdirSync\n * }\n *\n * async function setupBundler() {\n *   // Initialize dependencies\n *   const config = await loadConfig()\n *   const solcCompiler = await createSolc()\n *   const cacheInstance = createCache()\n *\n *   // Create the bundler\n *   const tevmBundler = bundler(\n *     config,\n *     console,\n *     fao,\n *     solcCompiler,\n *     cacheInstance\n *   )\n *\n *   // Process a Solidity file to TypeScript\n *   const result = await tevmBundler.resolveTsModule(\n *     './contracts/ERC20.sol',\n *     process.cwd(),\n *     true,  // include AST\n *     true   // include bytecode\n *   )\n *\n *   console.log(result.code)\n *\n *   // The result contains:\n *   // - code: The generated TypeScript code\n *   // - modules: Information about processed modules\n *   // - solcInput: The input provided to solc\n *   // - solcOutput: The compiler output\n *   // - asts: Abstract Syntax Trees (if requested)\n * }\n *\n * setupBundler().catch(console.error)\n * ```\n */\nexport const bundler = (config, logger, fao, solc, cache, contractPackage) => {\n\tconst _contractPackage = typeof contractPackage === 'string' ? contractPackage : getContractPath(process.cwd())\n\treturn {\n\t\t/** @type {string} */\n\t\tname: 'TevmBaseBundler',\n\t\tconfig,\n\t\tresolveDts: (\n\t\t\t/** @type {string} */ modulePath,\n\t\t\t/** @type {string} */ basedir,\n\t\t\t/** @type {boolean} */ includeAst,\n\t\t\t/** @type {boolean} */ includeBytecode,\n\t\t) =>\n\t\t\tresolveModuleAsync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'dts',\n\t\t\t\tcache,\n\t\t\t\t_contractPackage,\n\t\t\t),\n\t\tresolveDtsSync: (\n\t\t\t/** @type {string} */ modulePath,\n\t\t\t/** @type {string} */ basedir,\n\t\t\t/** @type {boolean} */ includeAst,\n\t\t\t/** @type {boolean} */ includeBytecode,\n\t\t) =>\n\t\t\tresolveModuleSync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'dts',\n\t\t\t\tcache,\n\t\t\t\t_contractPackage,\n\t\t\t),\n\t\tresolveTsModuleSync: (\n\t\t\t/** @type {string} */ modulePath,\n\t\t\t/** @type {string} */ basedir,\n\t\t\t/** @type {boolean} */ includeAst,\n\t\t\t/** @type {boolean} */ includeBytecode,\n\t\t) =>\n\t\t\tresolveModuleSync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'ts',\n\t\t\t\tcache,\n\t\t\t\t_contractPackage,\n\t\t\t),\n\t\tresolveTsModule: (\n\t\t\t/** @type {string} */ modulePath,\n\t\t\t/** @type {string} */ basedir,\n\t\t\t/** @type {boolean} */ includeAst,\n\t\t\t/** @type {boolean} */ includeBytecode,\n\t\t) =>\n\t\t\tresolveModuleAsync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'ts',\n\t\t\t\tcache,\n\t\t\t\t_contractPackage,\n\t\t\t),\n\t\tresolveCjsModuleSync: (\n\t\t\t/** @type {string} */ modulePath,\n\t\t\t/** @type {string} */ basedir,\n\t\t\t/** @type {boolean} */ includeAst,\n\t\t\t/** @type {boolean} */ includeBytecode,\n\t\t) =>\n\t\t\tresolveModuleSync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'cjs',\n\t\t\t\tcache,\n\t\t\t\t_contractPackage,\n\t\t\t),\n\t\tresolveCjsModule: (\n\t\t\t/** @type {string} */ modulePath,\n\t\t\t/** @type {string} */ basedir,\n\t\t\t/** @type {boolean} */ includeAst,\n\t\t\t/** @type {boolean} */ includeBytecode,\n\t\t) =>\n\t\t\tresolveModuleAsync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'cjs',\n\t\t\t\tcache,\n\t\t\t\t_contractPackage,\n\t\t\t),\n\t\tresolveEsmModuleSync: (\n\t\t\t/** @type {string} */ modulePath,\n\t\t\t/** @type {string} */ basedir,\n\t\t\t/** @type {boolean} */ includeAst,\n\t\t\t/** @type {boolean} */ includeBytecode,\n\t\t) =>\n\t\t\tresolveModuleSync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'mjs',\n\t\t\t\tcache,\n\t\t\t\t_contractPackage,\n\t\t\t),\n\t\tresolveEsmModule: (\n\t\t\t/** @type {string} */ modulePath,\n\t\t\t/** @type {string} */ basedir,\n\t\t\t/** @type {boolean} */ includeAst,\n\t\t\t/** @type {boolean} */ includeBytecode,\n\t\t) =>\n\t\t\tresolveModuleAsync(\n\t\t\t\tlogger,\n\t\t\t\tconfig,\n\t\t\t\tfao,\n\t\t\t\tsolc,\n\t\t\t\tmodulePath,\n\t\t\t\tbasedir,\n\t\t\t\tincludeAst,\n\t\t\t\tincludeBytecode,\n\t\t\t\t'mjs',\n\t\t\t\tcache,\n\t\t\t\t_contractPackage,\n\t\t\t),\n\t}\n}\n"]}