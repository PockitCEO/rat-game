{"version":3,"sources":["../src/Bloom.ts","../src/createMemoryDb.js","../src/prefundedAccounts.ts","../src/signature.js","../src/invariant.ts"],"names":["InvalidBytesSizeError","hexToBytes","keccak256","DefensiveNullCheckError","bytesToHex","UnreachableCodeError","privateKeyToAccount","ecrecover","toBytes","toHex","getAddress"],"mappings":"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","file":"index.cjs","sourcesContent":["// This is adapted from @ethereumjs/vm package not the @ethereumjs/util package\nimport { DefensiveNullCheckError, InvalidBytesSizeError } from '@tevm/errors'\nimport { hexToBytes, keccak256 } from './viem.js'\n\nconst zeros = (bytes: number): Uint8Array => {\n\treturn new Uint8Array(bytes)\n}\n\nconst BYTE_SIZE = 256\n\n/**\n * A simple Bloom filter implementation originally from ethereumjs\n */\nexport class Bloom {\n\tbitvector: Uint8Array\n\n\t/**\n\t * Represents a Bloom filter.\n\t * @throws {InvalidBytesSizeError} If the byte size of the bitvector is not 256.\n\t */\n\tconstructor(bitvector?: Uint8Array) {\n\t\tif (!bitvector) {\n\t\t\tthis.bitvector = zeros(BYTE_SIZE)\n\t\t} else {\n\t\t\tif (bitvector.length !== BYTE_SIZE) throw new InvalidBytesSizeError(BYTE_SIZE, bitvector.length)\n\t\t\tthis.bitvector = bitvector\n\t\t}\n\t}\n\n\t/**\n\t * Adds an element to a bit vector of a 64 byte bloom filter.\n\t * @param e - The element to add\n\t * @throws {never}\n\t */\n\tadd(e: Uint8Array) {\n\t\tconst eBytes = hexToBytes(keccak256(e))\n\t\tconst mask = 2047 // binary 11111111111\n\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tconst first2bytes = new DataView(eBytes.buffer).getUint16(i * 2)\n\t\t\tconst loc = mask & first2bytes\n\t\t\tconst byteLoc = loc >> 3\n\t\t\tconst bitLoc = 1 << (loc % 8)\n\t\t\tlet item = this.bitvector[BYTE_SIZE - byteLoc - 1]\n\t\t\tif (item === undefined) {\n\t\t\t\tthrow new DefensiveNullCheckError('item is not defined. There is a bug in the implementation')\n\t\t\t}\n\t\t\titem |= bitLoc\n\t\t\tthis.bitvector[BYTE_SIZE - byteLoc - 1] = item\n\t\t}\n\t}\n\n\t/**\n\t * Checks if an element is in the bloom.\n\t * @param e - The element to check\n\t * @throws {never}\n\t */\n\tcheck(e: Uint8Array): boolean {\n\t\tconst eBytes = hexToBytes(keccak256(e))\n\t\tconst mask = 2047 // binary 11111111111\n\t\tlet match = true\n\n\t\tfor (let i = 0; i < 3 && match; i++) {\n\t\t\tconst first2bytes = new DataView(eBytes.buffer).getUint16(i * 2)\n\t\t\tconst loc = mask & first2bytes\n\t\t\tconst byteLoc = loc >> 3\n\t\t\tconst bitLoc = 1 << (loc % 8)\n\t\t\tconst item = this.bitvector[BYTE_SIZE - byteLoc - 1]\n\t\t\tif (item === undefined) {\n\t\t\t\tthrow new DefensiveNullCheckError('item is not defined. There is a bug in the implementation')\n\t\t\t}\n\t\t\tmatch = (item & bitLoc) !== 0\n\t\t}\n\n\t\treturn Boolean(match)\n\t}\n\n\t/**\n\t * Checks if multiple topics are in a bloom.\n\t * @returns `true` if every topic is in the bloom\n\t * @throws {never}\n\t */\n\tmultiCheck(topics: Uint8Array[]): boolean {\n\t\treturn topics.every((t: Uint8Array) => this.check(t))\n\t}\n\n\t/**\n\t * Bitwise or blooms together.\n\t * @throws {never}\n\t */\n\tor(bloom: Bloom) {\n\t\tfor (let i = 0; i <= BYTE_SIZE; i++) {\n\t\t\tconst a = this.bitvector[i]\n\t\t\tconst b = bloom.bitvector[i]\n\t\t\tif (a === undefined) {\n\t\t\t\tthrow new DefensiveNullCheckError('a is not defined. Please open an issue in the tevm github repo')\n\t\t\t}\n\t\t\tif (b === undefined) {\n\t\t\t\tthrow new DefensiveNullCheckError('b is not defined. Please open an issue in the tevm github repo')\n\t\t\t}\n\t\t\tthis.bitvector[i] = a | b\n\t\t}\n\t}\n}\n","import { UnreachableCodeError } from '@tevm/errors'\nimport { bytesToHex } from './viem.js'\n\n/**\n * Converts key to type that maps can use as keys\n * @param {unknown} bytes\n */\nconst encodeKey = (bytes) => {\n\tif (bytes instanceof Uint8Array) {\n\t\treturn bytesToHex(bytes)\n\t}\n\treturn bytes\n}\n\n/**\n * @internal\n * A simple ethereumjs DB instance that uses an in memory Map as it's backend\n * Pass in an initial DB optionally to prepoulate the DB.\n * @type {import('./CreateMemoryDbFn.js').CreateMemoryDbFn}\n * @throws {never}\n */\nexport const createMemoryDb = (initialDb) => {\n\tconst db = initialDb ?? new Map()\n\n\treturn {\n\t\tget: (key) => {\n\t\t\treturn Promise.resolve(db.get(encodeKey(key)))\n\t\t},\n\t\tput: (key, value) => {\n\t\t\tdb.set(encodeKey(key), value)\n\t\t\treturn Promise.resolve()\n\t\t},\n\t\tdel: (key) => {\n\t\t\tdb.delete(encodeKey(key))\n\t\t\treturn Promise.resolve()\n\t\t},\n\t\tshallowCopy: () => {\n\t\t\treturn createMemoryDb(new Map(db))\n\t\t},\n\t\t// For compatability\n\t\topen: () => Promise.resolve(),\n\t\tbatch: (stack) => {\n\t\t\tfor (const item of stack) {\n\t\t\t\tif (item.type === 'del') {\n\t\t\t\t\tdb.delete(encodeKey(item.key))\n\t\t\t\t} else if (item.type === 'put') {\n\t\t\t\t\tdb.set(encodeKey(item.key), item.value)\n\t\t\t\t} else {\n\t\t\t\t\treturn Promise.reject(new UnreachableCodeError(item))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Promise.resolve()\n\t\t},\n\t}\n}\n","import { type PrivateKeyAccount, privateKeyToAccount } from 'viem/accounts'\n\nexport const PREFUNDED_PRIVATE_KEYS = [\n\t'0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80', // 0\n\t'0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d', // 1\n\t'0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a', // 2\n\t'0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6', // 3\n\t'0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a', // 4\n\t'0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba', // 5\n\t'0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e', // 6\n\t'0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356', // 7\n\t'0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97', // 8\n\t'0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6', // 9\n] as const\n\nexport const PREFUNDED_PUBLIC_KEYS = [\n\t'0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266', // 0\n\t'0x70997970C51812dc3A010C7d01b50e0d17dc79C8', // 1\n\t'0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC', // 2\n\t'0x90F79bf6EB2c4f870365E785982E1f101E93b906', // 3\n\t'0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65', // 4\n\t'0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc', // 5\n\t'0x976EA74026E726554dB657fA54763abd0C3a0aa9', // 6\n\t'0x14dC79964da2C08b23698B3D3cc7Ca32193d9955', // 7\n\t'0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f', // 8\n\t'0xa0Ee7A142d267C1f36714E4a8F75612F20a79720', // 9\n] as const\n\nexport const PREFUNDED_ACCOUNTS: [\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n\tPrivateKeyAccount,\n] = [\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[0]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[1]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[2]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[3]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[4]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[5]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[6]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[7]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[8]),\n\tprivateKeyToAccount(PREFUNDED_PRIVATE_KEYS[9]),\n] as const\n\nexport const PREFUNDED_SEED = Object.freeze({\n\tmnemonic: 'test test test test test test test test test test test junk',\n\tderivationPath: \"m/44'/60'/0'/0/\",\n})\n","import { ecrecover } from './ethereumjs.js'\nimport { getAddress, keccak256, toBytes, toHex } from './viem.js'\n\n/**\n * @typedef {Object} Signature\n * @property {bigint} r - The r value of the signature\n * @property {bigint} s - The s value of the signature\n * @property {number} [v] - The recovery id (27 or 28)\n * @property {0 | 1} [yParity] - The y parity (0 or 1)\n */\n\n/**\n * Recovers the public key from a signature\n * @param {Object} params - The parameters\n * @param {import('./abitype.js').Hex} params.hash - The message hash\n * @param {Signature} params.signature - The signature\n * @returns {import('./abitype.js').Hex} The uncompressed public key (65 bytes)\n * @throws {Error} If the signature is invalid\n * @example\n * ```js\n * import { recoverPublicKey } from '@tevm/utils'\n *\n * const publicKey = recoverPublicKey({\n *   hash: '0x82ff40c0a986c6a5cfad4ddf4c3aa6996f1a7837f9c398e17e5de5cbd5a12b28',\n *   signature: {\n *     r: 0x99e71a99cb2270b8cac5254f9e99b6210c6c10224a1579cf389ef88b20a1abe9n,\n *     s: 0x129ff05af364204442bdb53ab6f18a99ab48acc9326fa689f228040429e3ca66n,\n *     v: 27\n *   }\n * })\n * ```\n */\nexport function recoverPublicKey({ hash, signature }) {\n\tconst v =\n\t\tsignature.yParity !== undefined\n\t\t\t? signature.yParity\n\t\t\t: signature.v !== undefined\n\t\t\t\t? signature.v - 27\n\t\t\t\t: (() => {\n\t\t\t\t\t\tthrow new Error('Either v or yParity must be provided in signature')\n\t\t\t\t\t})()\n\n\t// Convert bigint values to proper byte arrays for ecrecover\n\tconst rBytes = new Uint8Array(32)\n\tconst sBytes = new Uint8Array(32)\n\n\t// Convert bigint to bytes (big endian)\n\tconst rBigInt = typeof signature.r === 'string' ? BigInt(signature.r) : signature.r\n\tconst sBigInt = typeof signature.s === 'string' ? BigInt(signature.s) : signature.s\n\n\tfor (let i = 0; i < 32; i++) {\n\t\trBytes[31 - i] = Number((rBigInt >> BigInt(8 * i)) & 0xffn)\n\t\tsBytes[31 - i] = Number((sBigInt >> BigInt(8 * i)) & 0xffn)\n\t}\n\n\tconst publicKey = ecrecover(toBytes(hash), BigInt(v), rBytes, sBytes)\n\n\t/* v8 ignore next 3 */\n\tif (!publicKey) {\n\t\tthrow new Error('Failed to recover public key')\n\t}\n\n\t// ecrecover returns a 64-byte public key, we need to add the 0x04 prefix for uncompressed format\n\treturn `0x04${toHex(publicKey).slice(2)}`\n}\n\n/**\n * Recovers the address from a signature\n * @param {Object} params - The parameters\n * @param {import('./abitype.js').Hex} params.hash - The message hash\n * @param {Signature} params.signature - The signature\n * @returns {import('./abitype.js').Address} The recovered address\n * @throws {Error} If the signature is invalid\n * @example\n * ```js\n * import { recoverAddress } from '@tevm/utils'\n *\n * const address = recoverAddress({\n *   hash: '0x82ff40c0a986c6a5cfad4ddf4c3aa6996f1a7837f9c398e17e5de5cbd5a12b28',\n *   signature: {\n *     r: 0x99e71a99cb2270b8cac5254f9e99b6210c6c10224a1579cf389ef88b20a1abe9n,\n *     s: 0x129ff05af364204442bdb53ab6f18a99ab48acc9326fa689f228040429e3ca66n,\n *     v: 27\n *   }\n * })\n * ```\n */\nexport function recoverAddress({ hash, signature }) {\n\tconst publicKey = recoverPublicKey({ hash, signature })\n\t// Remove 0x04 prefix from uncompressed public key\n\tconst publicKeyBytes = toBytes(publicKey).slice(1)\n\tconst addressHash = keccak256(publicKeyBytes)\n\t// Take last 20 bytes of hash\n\treturn getAddress(`0x${addressHash.slice(-40)}`)\n}\n\n/**\n * Hashes a message according to EIP-191\n * @param {string} message - The message to hash\n * @returns {import('./abitype.js').Hex} The message hash\n * @example\n * ```js\n * import { hashMessage } from '@tevm/utils'\n *\n * const hash = hashMessage('Hello world')\n * // 0x8144a6fa26be252b86456491fbcd43c1de7e022241845ffea1c3df066f7cfede\n * ```\n */\nexport function hashMessage(message) {\n\tconst prefix = `\\x19Ethereum Signed Message:\\n${message.length}`\n\treturn keccak256(toBytes(prefix + message))\n}\n\n/**\n * Recovers the address from a signed message\n * @param {Object} params - The parameters\n * @param {string} params.message - The original message\n * @param {Signature} params.signature - The signature\n * @returns {import('./abitype.js').Address} The recovered address\n * @throws {Error} If the signature is invalid\n * @example\n * ```js\n * import { recoverMessageAddress } from '@tevm/utils'\n *\n * const address = recoverMessageAddress({\n *   message: 'Hello world',\n *   signature: {\n *     r: 0x...,\n *     s: 0x...,\n *     v: 27\n *   }\n * })\n * ```\n */\nexport function recoverMessageAddress({ message, signature }) {\n\tconst hash = hashMessage(message)\n\treturn recoverAddress({ hash, signature })\n}\n\n/**\n * Verifies a message signature\n * @param {Object} params - The parameters\n * @param {import('./abitype.js').Address} params.address - The expected signer address\n * @param {string} params.message - The original message\n * @param {Signature} params.signature - The signature\n * @returns {boolean} Whether the signature is valid\n * @example\n * ```js\n * import { verifyMessage } from '@tevm/utils'\n *\n * const isValid = verifyMessage({\n *   address: '0xa6fb229e9b0a4e4ef52ea6991adcfc59207c7711',\n *   message: 'Hello world',\n *   signature: {\n *     r: 0x...,\n *     s: 0x...,\n *     v: 27\n *   }\n * })\n * ```\n */\nexport function verifyMessage({ address, message, signature }) {\n\ttry {\n\t\tconst recoveredAddress = recoverMessageAddress({ message, signature })\n\t\treturn recoveredAddress.toLowerCase() === address.toLowerCase()\n\t} catch {\n\t\treturn false\n\t}\n}\n\n/**\n * Signs a message with a private key\n * @param {Object} params - The parameters\n * @param {import('./abitype.js').Hex} params.privateKey - The private key\n * @param {string} params.message - The message to sign\n * @returns {Promise<Signature>} The signature\n * @example\n * ```js\n * import { signMessage } from '@tevm/utils'\n *\n * const signature = await signMessage({\n *   privateKey: '0x3c9229289a6125f7fdf1885a77bb12c37a8d3b4962d936f7e3084dece32a3ca1',\n *   message: 'Hello world'\n * })\n * ```\n */\nexport async function signMessage({ privateKey, message }) {\n\t// Import viem's signMessage function directly\n\tconst { signMessage: viemSignMessage } = await import('viem/accounts')\n\tconst signature = await viemSignMessage({ privateKey, message })\n\n\t// Convert viem signature format to our format\n\t// The last byte in viem signature is already the v value (27/28)\n\tconst v = Number.parseInt(signature.slice(130, 132), 16)\n\tconst yParity = /** @type {0 | 1} */ (v - 27) // Convert v to yParity (0/1)\n\n\treturn {\n\t\tr: BigInt(signature.slice(0, 66)), // First 32 bytes as hex\n\t\ts: BigInt(`0x${signature.slice(66, 130)}`), // Next 32 bytes as hex\n\t\tv, // Already 27/28\n\t\tyParity,\n\t}\n}\n","import { DefensiveNullCheckError } from '@tevm/errors'\n\nexport function invariant(condition: any, error: Error = new DefensiveNullCheckError()): asserts condition {\n\tif (!condition) {\n\t\tthrow error\n\t}\n}\n"]}