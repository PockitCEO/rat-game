'use strict';

var Effect = require('effect/Effect');
var Schema = require('@effect/schema/Schema');
var TreeFormatter = require('@effect/schema/TreeFormatter');
var effect$1 = require('effect');
var Either = require('effect/Either');
var child_process = require('child_process');
var path2 = require('path');
var effect = require('@tevm/effect');
var fs = require('fs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var path2__namespace = /*#__PURE__*/_interopNamespace(path2);

// src/config/withDefaults.js
var defaultConfig = {
  jsonAsConst: [],
  foundryProject: false,
  remappings: {},
  libs: [],
  debug: false,
  cacheDir: ".tevm"
};
var withDefaults = (config) => Effect.succeed({
  jsonAsConst: (() => {
    if (config.jsonAsConst === void 0) {
      return defaultConfig.jsonAsConst;
    }
    if (Array.isArray(config.jsonAsConst)) {
      return config.jsonAsConst;
    }
    if (typeof config.jsonAsConst === "string") {
      return [config.jsonAsConst];
    }
    console.error("Invalid jsonAsConst value must be a string or array of strings");
    return defaultConfig.jsonAsConst;
  })(),
  foundryProject: config.foundryProject ?? defaultConfig.foundryProject,
  remappings: {
    ...defaultConfig.remappings,
    ...config.remappings
  },
  libs: [...defaultConfig.libs, ...config.libs ?? []],
  debug: config.debug ?? defaultConfig.debug,
  cacheDir: config.cacheDir ?? defaultConfig.cacheDir
}).pipe(
  Effect.tap(
    (configWithDefaults) => Effect.logDebug(
      `withDefaults: resolved config: ${JSON.stringify({
        originalConfig: config,
        configWithDefaults
      })}`
    )
  )
);
var mergeConfigs = (configs) => {
  var _a, _b, _c;
  return Effect.succeed({
    remappings: Object.fromEntries(configs.flatMap((config) => Object.entries(config.remappings ?? {}))),
    foundryProject: (_a = configs.reverse().find((config) => config.foundryProject !== void 0)) == null ? void 0 : _a.foundryProject,
    libs: [...new Set(configs.flatMap((config) => config.libs ?? []))],
    debug: (_b = configs.reverse().find((config) => config.debug !== void 0)) == null ? void 0 : _b.debug,
    cacheDir: (_c = configs.reverse().find((config) => config.cacheDir !== void 0)) == null ? void 0 : _c.cacheDir
  });
};
var ConfigFnThrowError = class extends Error {
  /**
   * @type {'ConfigFnThrowError'}
   */
  _tag = "ConfigFnThrowError";
  /**
   * @param {object} options
   * @param {unknown} options.cause
   */
  constructor(options) {
    const message = typeof options.cause === "string" ? options.cause : options.cause instanceof Error ? options.cause.message : "";
    super(`Provided config factory threw an error: ${message}`, options);
  }
};
var InvalidConfigError = class extends TypeError {
  /**
   * @type {'InvalidConfigError'}
   */
  _tag = "InvalidConfigError";
};
var SCompilerConfig = Schema.Struct({
  name: Schema.optional(Schema.Union(Schema.Literal("@tevm/ts-plugin"), Schema.Undefined)),
  foundryProject: Schema.optional(Schema.Union(Schema.Boolean, Schema.String, Schema.Undefined)),
  libs: Schema.optional(Schema.Union(Schema.Array(Schema.String), Schema.Undefined)),
  remappings: Schema.optional(Schema.Union(Schema.Record({ key: Schema.String, value: Schema.String }), Schema.Undefined)),
  debug: Schema.optional(Schema.Union(Schema.Boolean, Schema.Undefined)),
  cacheDir: Schema.optional(Schema.Union(Schema.String, Schema.Undefined)),
  jsonAsConst: Schema.optional(Schema.Union(Schema.String, Schema.Array(Schema.String), Schema.Undefined))
  // Updated property
});
var validateUserConfig = (untrustedConfigFactory) => {
  return effect$1.pipe(
    Effect.try({
      try: untrustedConfigFactory,
      catch: (cause) => new ConfigFnThrowError({
        cause
      })
    }),
    Effect.flatMap((unvalidatedConfig) => {
      const res = Schema.decodeUnknownEither(SCompilerConfig)(unvalidatedConfig, {
        errors: "all",
        onExcessProperty: "error"
      });
      return Either.match(res, {
        onLeft: (left) => Effect.fail(new InvalidConfigError(TreeFormatter.formatErrorSync(left), { cause: left })),
        onRight: (right) => Effect.succeed(right)
      });
    }),
    Effect.tap(
      (validatedConfig) => Effect.logDebug(`validatedConfig: Validated config successfully: ${JSON.stringify(validatedConfig)}`)
    )
  );
};
var FoundryNotFoundError = class extends Error {
  /**
   * @type {'FoundryNotFoundError'}
   */
  _tag = "FoundryNotFoundError";
  /**
   * @param {string} forgeCommand
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(forgeCommand, options) {
    super(
      `Failed to resolve forge config using "${forgeCommand} config --json" command. Make sure forge is installed and accessible and forge config --json works.
note: forge is used to fetch remappings only if forgeConfig is set. If you would prefer to not use forge you can set remappings
or lib directly in your Tevm compiler config and then Tevm will run without forge`,
      options
    );
  }
};
var FoundryConfigError = class extends Error {
  /**
   * @type {'FoundryConfigError'}
   */
  _tag = "FoundryConfigError";
  /**
   * @param {string} forgeCommand
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(forgeCommand, options) {
    super(`Unable to resolve foundry config using ${forgeCommand} config --json`, options);
  }
};
var InvalidRemappingsError = class extends Error {
  /**
   * @type {'InvalidRemappingsError'}
   */
  _tag = "InvalidRemappingsError";
  /**
   * @param {string} remappings
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(remappings, options) {
    super(`Invalid remappings: ${remappings}`, options);
  }
};
var loadFoundryConfig = (foundryProject, configFilePath) => {
  if (!foundryProject) {
    return Effect.tap(Effect.succeed({}), () => Effect.logDebug("loadFoundryConfig: skipping because foundryProject is not set"));
  }
  const forgeCommand = typeof foundryProject === "string" ? foundryProject : "forge";
  let stdout;
  try {
    stdout = child_process.execSync(`${forgeCommand} config --json`, {
      cwd: configFilePath
    }).toString();
  } catch (cause) {
    console.error(cause);
    return Effect.fail(new FoundryNotFoundError(forgeCommand, { cause }));
  }
  let forgeConfig;
  try {
    forgeConfig = JSON.parse(stdout);
  } catch (cause) {
    console.error(cause);
    return Effect.fail(new FoundryConfigError(forgeCommand, { cause }));
  }
  const remappings = {};
  if (forgeConfig.remappings) {
    for (const remap of forgeConfig.remappings) {
      const parts = remap.split("=");
      if (parts.length !== 2) {
        return Effect.fail(new InvalidRemappingsError(remap));
      }
      const [key, value] = parts;
      remappings[key.trim()] = path2__namespace.join(configFilePath, value.trim());
    }
  }
  return Effect.tap(
    Effect.succeed({
      libs: forgeConfig == null ? void 0 : forgeConfig.libs,
      remappings
    }),
    (config) => {
      return Effect.logDebug(
        `loadFoundryConfig: foundryProject is set, loading foundry config as an Tevm CompilerConfig: ${JSON.stringify(
          config
        )}`
      );
    }
  );
};

// src/defineConfig.js
var DefineConfigError = class extends Error {
  /**
   * @type {import("./types.js").DefineConfigErrorType['_tag']}
   * @override
   */
  name;
  /**
   * @type {import("./types.js").DefineConfigErrorType['_tag']}
   **/
  _tag;
  /**
   * @param {string} configFilePath
   * @param {import("./types.js").DefineConfigErrorType} underlyingError
   **/
  constructor(configFilePath, underlyingError) {
    super(
      `${underlyingError._tag}: Unable to resolve Tevm CompilerConfig at ${configFilePath}
${underlyingError.message}`,
      { cause: underlyingError.cause }
    );
    this._tag = underlyingError._tag;
    this.name = underlyingError._tag;
  }
};
var defineConfig = (configFactory) => ({
  configFn: (configFilePath) => {
    const config = validateUserConfig(configFactory);
    const foundryConfig = Effect.flatMap(config, ({ foundryProject }) => loadFoundryConfig(foundryProject, configFilePath));
    const handleError = (error) => {
      return Effect.fail(new DefineConfigError(configFilePath, error));
    };
    return Effect.all([config, foundryConfig]).pipe(
      Effect.tap(
        ([userConfig, foundryConfig2]) => Effect.logDebug(
          `defineConfig: Config read CompilerConfigs ${JSON.stringify({
            userConfig,
            foundryConfig: foundryConfig2
          })}`
        )
      ),
      Effect.flatMap(mergeConfigs),
      Effect.tap((mergedConfigs) => Effect.logDebug(`defineConfig: MergedConfigs ${JSON.stringify({ mergedConfigs })}`)),
      Effect.flatMap(withDefaults),
      Effect.catchTags({
        InvalidRemappingsError: handleError,
        InvalidConfigError: handleError,
        FoundryNotFoundError: handleError,
        FoundryConfigError: handleError,
        ConfigFnThrowError: handleError
      }),
      Effect.tap(
        (config2) => Effect.logDebug(
          `defineConfig: Added defaults. Config read ${JSON.stringify({
            config: config2
          })}`
        )
      )
    );
  }
});
var FailedToReadConfigError = class extends Error {
  /**
   * @type {'FailedToReadConfigError'}
   */
  _tag = "FailedToReadConfigError";
  /**
   * @param {string} configFilePath
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(configFilePath, options) {
    super(`Failed to find tevm.config.json ${configFilePath}`, options);
  }
};
var InvalidJsonConfigError = class extends TypeError {
  /**
   * @type {'InvalidJsonConfigError'}
   * @override
   */
  name = "InvalidJsonConfigError";
  /**
   * @type {'InvalidJsonConfigError'}
   */
  _tag = "InvalidJsonConfigError";
  /**
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(options) {
    super("Invalid json detected", options);
  }
};
var loadJsonConfig = (configFilePath) => {
  const tevmConfigPath0 = path2__namespace.join(configFilePath, "tevm.config.json");
  const tevmConfigPath1 = path2__namespace.join(configFilePath, "tevm.json");
  const readConfig = (configPath) => Effect.try({
    try: () => fs.readFileSync(configPath, "utf8"),
    catch: (cause) => new FailedToReadConfigError(configFilePath, { cause })
  });
  return readConfig(tevmConfigPath0).pipe(
    Effect.catchTag("FailedToReadConfigError", () => {
      return readConfig(tevmConfigPath1);
    }),
    Effect.flatMap(effect.parseJson),
    Effect.catchTag("ParseJsonError", (cause) => Effect.fail(new InvalidJsonConfigError({ cause }))),
    Effect.flatMap((cfg) => validateUserConfig(() => (
      /** @type {import('../types.js').CompilerConfig}*/
      cfg
    ))),
    // it can't throw. Could clean this up via making validateUserConfig take a config instead of a factory
    Effect.catchTag("ConfigFnThrowError", (e) => Effect.die(e)),
    Effect.tap((tsConfig) => Effect.logDebug(`loading tsconfig from ${configFilePath}: ${JSON.stringify(tsConfig)}`))
  );
};
var InvalidRemappingsError2 = class extends TypeError {
  /**
   * @type {'InvalidRemappingsError'}
   * @override
   */
  name = "InvalidRemappingsError";
  /**
   * @type {'InvalidRemappingsError'}
   */
  _tag = "InvalidRemappingsError";
};
var loadRemappings = (configFilePath) => {
  const remappingsPath = path2__namespace.join(configFilePath, "remappings.txt");
  const readConfig = (configPath) => Effect.try({
    try: () => fs.readFileSync(configPath, "utf8"),
    catch: () => new InvalidRemappingsError2("No remapping file exists")
  });
  return readConfig(remappingsPath).pipe(
    // if remappings doesn't exist that's fine just return nothing
    Effect.catchTag("InvalidRemappingsError", () => {
      return Effect.succeed("");
    }),
    Effect.flatMap((remappings) => {
      if (remappings.trim() === "") {
        return Effect.succeed({});
      }
      const remappingEntries = remappings.trim().split("\n");
      for (const remapping of remappingEntries) {
        if (remapping.trim() === "") {
          continue;
        }
        const remappingArr = remapping.split("=");
        if (remappingArr.length !== 2) {
          return Effect.fail(
            new InvalidRemappingsError2(
              `Invalid remapping ${remapping}. Remapping in remapping.txt should look like @solmate-utils/=lib/solmate/src/utils/`
            )
          );
        }
      }
      const config = {
        remappings: Object.fromEntries(
          remappingEntries.map((remapping) => {
            const [from, to] = remapping.trim().split("=");
            return (
              /** @type {[string, string]}*/
              [
                from,
                `${configFilePath.endsWith("/") ? configFilePath : `${configFilePath}/`}${(to == null ? void 0 : to.startsWith("/")) ? to.slice(1) : to}`
              ]
            );
          })
        )
      };
      return Effect.succeed(config);
    }),
    Effect.flatMap((cfg) => validateUserConfig(() => (
      /** @type {import('../types.js').CompilerConfig}*/
      cfg
    ))),
    // it can't thrw. Could clean this up via making validateUserConfig take a config instead of a factory
    Effect.catchTag("ConfigFnThrowError", (e) => Effect.die(e)),
    // internal error if this happens
    Effect.catchTag("InvalidConfigError", (e) => Effect.die(e)),
    Effect.tap(
      (normalizedConfig) => Effect.logDebug(`loading remappings from ${configFilePath}: ${JSON.stringify(normalizedConfig)}`)
    )
  );
};
var NoPluginInTsConfigFoundError = class extends Error {
  /**
   * @type {'NoPluginInTsConfigFoundError'}
   */
  _tag = "NoPluginInTsConfigFoundError";
};
var getTevmConfigFromTsConfig = (tsConfig, configPath) => {
  var _a, _b;
  if (!((_b = (_a = tsConfig.compilerOptions) == null ? void 0 : _a.plugins) == null ? void 0 : _b.length)) {
    return Effect.fail(new NoPluginInTsConfigFoundError("No compilerOptions.plugins in tsconfig"));
  }
  const plugin = (
    /**
     * @type {import("../types.js").CompilerConfig | undefined}
     */
    tsConfig.compilerOptions.plugins.find((plugin2) => plugin2.name === "@tevm/ts-plugin")
  );
  if (!plugin) {
    return Effect.fail(new NoPluginInTsConfigFoundError());
  }
  const { baseUrl, paths } = tsConfig.compilerOptions;
  const pathRemappings = Object.fromEntries(
    Object.entries(paths ?? {}).map(([key, value]) => {
      var _a2;
      return [
        key.replace(/\/\*$/, "/"),
        ((_a2 = value == null ? void 0 : value[0]) == null ? void 0 : _a2.replace(/^\./, configPath).replace(/\/\*$/, "/")) ?? ""
      ];
    })
  );
  return validateUserConfig(() => plugin).pipe(
    Effect.catchTag("ConfigFnThrowError", (e) => Effect.die(e)),
    Effect.map((config) => ({
      ...config,
      remappings: {
        ...config.remappings,
        ...pathRemappings
      }
    })),
    Effect.map(
      (config) => baseUrl ? {
        ...config,
        remappings: {
          ...pathRemappings,
          ...config.remappings
        },
        libs: [.../* @__PURE__ */ new Set([baseUrl, ...config.libs ?? []])]
      } : config
    ),
    Effect.tap((config) => {
      return Effect.logDebug(`getting config from tsconfig:
  tsconfig: ${JSON.stringify(config)}
  result: ${JSON.stringify(config)}`);
    })
  );
};
var FailedToReadConfigError2 = class extends Error {
  /**
   * @type {'FailedToReadConfigError'}
   */
  _tag = "FailedToReadConfigError";
  /**
   * @param {string} configFilePath
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(configFilePath, options) {
    super(`Failed to find ${configFilePath}/tsconfig.json`, options);
  }
};
var InvalidTsConfigError = class extends TypeError {
  /**
   * @type {'InvalidConfigError'}
   */
  _tag = "InvalidConfigError";
  /**
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(options) {
    super("Invalid tsconfig.json detected", options);
  }
};
var STsConfigWithPlugin = Schema.Struct({
  compilerOptions: Schema.Struct({
    baseUrl: Schema.optional(Schema.String),
    plugins: Schema.Array(
      Schema.Struct({
        name: Schema.String
      })
    ),
    paths: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) }))
  })
});
var STsConfig = Schema.Struct({
  compilerOptions: Schema.Struct({
    baseUrl: Schema.optional(Schema.String),
    plugins: Schema.optional(
      Schema.Array(
        Schema.Struct({
          name: Schema.String
        })
      )
    ),
    paths: Schema.optional(Schema.Record({ key: Schema.String, value: Schema.Array(Schema.String) }))
  })
});
var loadTsConfig = (configFilePath) => {
  const tsConfigPath = path2__namespace.join(configFilePath, "tsconfig.json");
  const jsConfigPath = path2__namespace.join(configFilePath, "jsconfig.json");
  return Effect.try({
    try: () => fs.existsSync(jsConfigPath) ? fs.readFileSync(jsConfigPath, "utf8") : fs.readFileSync(tsConfigPath, "utf8"),
    catch: (cause) => new FailedToReadConfigError2(configFilePath, { cause })
  }).pipe(
    // parse the json
    Effect.flatMap(effect.parseJson),
    // parse the tsconfig without plugins
    Effect.flatMap((unvalidatedConfig) => {
      const res = Schema.decodeUnknownEither(STsConfig)(unvalidatedConfig, {
        errors: "all",
        onExcessProperty: "ignore"
      });
      return Either.match(res, {
        onLeft: (left) => Effect.fail(new InvalidTsConfigError({ cause: left })),
        onRight: (right) => Effect.succeed(right)
      });
    }),
    // add ts-plugin if it's missing
    Effect.tap(
      (unvalidatedConfig) => (
        // if it doesn't have the plugin automatically install
        Schema.decodeUnknownEither(STsConfigWithPlugin)(unvalidatedConfig, {
          errors: "all",
          onExcessProperty: "ignore"
        }).pipe(
          Effect.tapBoth({
            onFailure: () => {
              const newConfig = {
                ...unvalidatedConfig,
                compilerOptions: {
                  ...unvalidatedConfig.compilerOptions,
                  plugins: [{ name: "@tevm/ts-plugin" }]
                }
              };
              try {
                const path5 = fs.existsSync(jsConfigPath) ? jsConfigPath : tsConfigPath;
                fs.writeFileSync(path5, JSON.stringify(newConfig, null, 2));
              } catch (e) {
                console.error(e);
                console.error(
                  "Missing @tevm/ts-plugin in tsconfig.json and unable to add it automatically. Please add it manually."
                );
              }
              return Effect.succeed(newConfig);
            },
            onSuccess: (config) => {
              const hasPlugin = config.compilerOptions.plugins.some((plugin) => plugin.name === "@tevm/ts-plugin");
              if (!hasPlugin) {
                const newConfig = {
                  ...config,
                  compilerOptions: {
                    ...config.compilerOptions,
                    plugins: [{ name: "@tevm/ts-plugin" }, ...config.compilerOptions.plugins]
                  }
                };
                try {
                  const path5 = fs.existsSync(jsConfigPath) ? jsConfigPath : tsConfigPath;
                  fs.writeFileSync(path5, JSON.stringify(newConfig, null, 2));
                } catch (e) {
                  console.error(e);
                  console.error(
                    "Missing @tevm/ts-plugin in tsconfig.json and unable to add it automatically. Please add it manually."
                  );
                }
                return Effect.succeed(newConfig);
              }
              return Effect.succeed(config);
            }
          })
        )
      )
    ),
    Effect.flatMap((unvalidatedConfig) => {
      const res = Schema.decodeUnknownEither(STsConfigWithPlugin)(unvalidatedConfig, {
        errors: "all",
        onExcessProperty: "ignore"
      });
      return Either.match(res, {
        onLeft: (left) => Effect.fail(new InvalidTsConfigError({ cause: left })),
        onRight: (right) => Effect.succeed(right)
      });
    }),
    Effect.catchTag("ParseError", (cause) => Effect.fail(new InvalidTsConfigError({ cause }))),
    Effect.tap((tsConfig) => Effect.logDebug(`loading tsconfig from ${configFilePath}: ${JSON.stringify(tsConfig)}`))
  );
};

// src/loadConfig.js
var LoadConfigError = class extends Error {
  /**
   * @type {LoadConfigError['_tag']}
   * @override
   */
  name;
  /**
   * @type {LoadConfigErrorType['_tag']}
   **/
  _tag;
  /**
   * @param {string} configFilePath
   * @param {LoadConfigErrorType} underlyingError
   **/
  constructor(configFilePath, underlyingError) {
    super(
      `${underlyingError._tag}: Unable load config from ${configFilePath}
${underlyingError.message}`,
      { cause: underlyingError.cause }
    );
    this._tag = underlyingError._tag;
    this.name = underlyingError._tag;
  }
};
var loadConfig = (configFilePath) => {
  const userConfig = Effect.logDebug(`loadConfig: loading userConfig at ${JSON.stringify(configFilePath)}`).pipe(
    Effect.flatMap(() => loadJsonConfig(configFilePath)),
    Effect.catchTag(
      "FailedToReadConfigError",
      (e) => Effect.logDebug(`loadConfig: loading tsConfig at ${JSON.stringify(configFilePath)}`).pipe(Effect.flatMap(() => loadTsConfig(configFilePath))).pipe(
        Effect.flatMap((tsConfig) => getTevmConfigFromTsConfig(tsConfig, configFilePath)),
        Effect.catchTag("NoPluginInTsConfigFoundError", () => Effect.fail(e)),
        Effect.catchTag("FailedToReadConfigError", () => Effect.fail(e))
      )
    )
  );
  const foundryConfig = Effect.flatMap(userConfig, (userConfig2) => {
    return loadFoundryConfig(userConfig2.foundryProject, configFilePath);
  });
  const remappingsConfig = loadRemappings(configFilePath);
  const handleError = (error) => {
    return Effect.fail(new LoadConfigError(configFilePath, error));
  };
  return Effect.all([userConfig, foundryConfig, remappingsConfig]).pipe(
    Effect.tap(
      ([userConfig2, foundryConfig2, remappingsConfig2]) => Effect.logDebug(
        `loadConfig: Config read CompilerConfigs ${JSON.stringify({
          userConfig: userConfig2,
          foundryConfig: foundryConfig2,
          remappingsConfig: remappingsConfig2
        })}`
      )
    ),
    Effect.flatMap(mergeConfigs),
    Effect.tap(
      (mergedConfigs) => Effect.logDebug(
        `loadConfig: Config read CompilerConfigs ${JSON.stringify({
          mergedConfigs
        })}`
      )
    ),
    Effect.flatMap(withDefaults),
    Effect.tapError(effect.logAllErrors),
    Effect.catchTags({
      FailedToReadConfigError: handleError,
      FoundryConfigError: handleError,
      FoundryNotFoundError: handleError,
      InvalidConfigError: handleError,
      InvalidRemappingsError: handleError,
      ParseJsonError: handleError,
      InvalidJsonConfigError: handleError
    }),
    Effect.tap((config) => Effect.logDebug(`loadConfig: Config loaded ${JSON.stringify({ config })}`))
  );
};

exports.defaultConfig = defaultConfig;
exports.defineConfig = defineConfig;
exports.loadConfig = loadConfig;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map