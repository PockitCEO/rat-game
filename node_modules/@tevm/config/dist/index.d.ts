import * as effect_Effect from 'effect/Effect';
import { Effect } from 'effect/Effect';
import { ReadonlyRecord } from 'effect/Record';
import * as _tevm_effect from '@tevm/effect';

/**
 * Error thrown when the user provided config factory throws
 * @internal
 */
declare class ConfigFnThrowError extends Error {
    /**
     * @param {object} options
     * @param {unknown} options.cause
     */
    constructor(options: {
        cause: unknown;
    });
    /**
     * @type {'ConfigFnThrowError'}
     */
    _tag: "ConfigFnThrowError";
}
/**
 * TypeError thrown when the user provided config factory is incorrectly typed
 * @internal
 */
declare class InvalidConfigError extends TypeError {
    /**
     * @type {'InvalidConfigError'}
     */
    _tag: "InvalidConfigError";
}
type ValidateUserConfigError = ConfigFnThrowError | InvalidConfigError;

declare namespace defaultConfig {
    let jsonAsConst: never[];
    let foundryProject: boolean;
    let remappings: {};
    let libs: never[];
    let debug: boolean;
    let cacheDir: string;
}

/**
 * Error class for {@link defineConfig}
 */
declare class DefineConfigError extends Error {
    /**
     * @param {string} configFilePath
     * @param {import("./types.js").DefineConfigErrorType} underlyingError
     **/
    constructor(configFilePath: string, underlyingError: DefineConfigErrorType);
    /**
     * @type {import("./types.js").DefineConfigErrorType['_tag']}
     * @override
     */
    override name: DefineConfigErrorType["_tag"];
    /**
     * @type {import("./types.js").DefineConfigErrorType['_tag']}
     **/
    _tag: DefineConfigErrorType["_tag"];
}
/**
 * Typesafe way to create an Tevm CompilerConfig
 * @type {import("./types.js").DefineConfig}
 * @example
 * ```ts
 * import { defineConfig } from '@tevm/ts-plugin'
 *
 * export default defineConfig(() => ({
 * 	lib: ['lib'],
 * 	remappings: {
 * 	  'foo': 'foo/bar'
 * 	}
 * })
 * ```
 */
declare const defineConfig: DefineConfig;

/**
 * Error thrown if foundry is not found in path while foundryProject is set in config
 * @internal
 */
declare class FoundryNotFoundError extends Error {
    /**
     * @param {string} forgeCommand
     * @param {object} [options]
     * @param {unknown} [options.cause]
     */
    constructor(forgeCommand: string, options?: {
        cause?: unknown;
    });
    /**
     * @type {'FoundryNotFoundError'}
     */
    _tag: "FoundryNotFoundError";
}
/**
 * Error thrown if parsing the foundry config with `forge config` fails
 * @internal
 */
declare class FoundryConfigError extends Error {
    /**
     * @param {string} forgeCommand
     * @param {object} [options]
     * @param {unknown} [options.cause]
     */
    constructor(forgeCommand: string, options?: {
        cause?: unknown;
    });
    /**
     * @type {'FoundryConfigError'}
     */
    _tag: "FoundryConfigError";
}
/**
 * Error thrown if foundry remappings cannot be parsed while foundryProject is set
 * @internal
 */
declare class InvalidRemappingsError extends Error {
    /**
     * @param {string} remappings
     * @param {object} [options]
     * @param {unknown} [options.cause]
     */
    constructor(remappings: string, options?: {
        cause?: unknown;
    });
    /**
     * @type {'InvalidRemappingsError'}
     */
    _tag: "InvalidRemappingsError";
}
type LoadFoundryConfigError = FoundryNotFoundError | FoundryConfigError | InvalidRemappingsError;

/**
 * Configuration of the solidity compiler
 * When resolved with defaults it is a {@link ResolvedCompilerConfig}
 */
type CompilerConfig$1 = {
    /**
     * A glob pattern or array of glob patterns indicating which ABIs should be resolved as const.
     * This allows for more precise typing of ABIs in TypeScript.
     */
    jsonAsConst?: string | readonly string[] | undefined;
    /**
     * If set to true it will resolve forge remappings and libs
     * Set to "path/to/forge/executable" to use a custom forge executable
     */
    foundryProject?: boolean | string | undefined;
    /**
     * Sets directories to search for solidity imports in
     * Read autoamtically for forge projects if forge: true
     */
    libs?: readonly string[] | undefined;
    /**
     * Remap the location of contracts
     */
    remappings?: ReadonlyRecord<string, string> | undefined;
    /**
     * If debug is true tevm will write the .d.ts files in the ts server and publish extra debug info to a debug file
     */
    debug?: boolean | undefined;
    /**
     * Location of the tevm cache folder
     */
    cacheDir?: string | undefined;
};
type ConfigFactory = () => CompilerConfig$1;
/**
 * A fully resolved compiler config with defaults filled in
 * See {@link CompilerConfig}
 */
type ResolvedCompilerConfig$1 = {
    /**
     * A glob pattern or array of glob patterns indicating which ABIs should be resolved as const.
     * This allows for more precise typing of ABIs in TypeScript.
     */
    jsonAsConst: readonly string[];
    /**
     * If set to true it will resolve forge remappings and libs
     * Set to "path/to/forge/executable" to use a custom forge executable
     */
    foundryProject: boolean | string;
    /**
     * Sets directories to search for solidity imports in
     * Read autoamtically for forge projects if forge: true
     */
    libs: readonly string[];
    /**
     * Remap the location of contracts
     */
    remappings: ReadonlyRecord<string, string>;
    /**
     * If debug is true tevm will write the .d.ts files in the ts server and publish extra debug info to a debug file
     */
    debug?: boolean | undefined;
    /**
     * Location of the tevm cache folder
     */
    cacheDir: string;
};
type DefineConfigErrorType = ValidateUserConfigError | LoadFoundryConfigError;
/**
 * Creates an Tevm config
 * Takes a user provided configFactory
 * @example
 * import { defineConfig } from 'tevm/config'
 * export default defineConfig({
 * 	foundryProject: true,
 * 		libs: ['libs/contracts'],
 *	})
 */
type DefineConfig = (configFactory: ConfigFactory) => {
    configFn: (configFilePath: string) => Effect<ResolvedCompilerConfig$1, DefineConfigError, never>;
};

/**
 * Expected shape of tsconfig.json or jsconfig.json
 * @typedef {{ compilerOptions?: { plugins?: ReadonlyArray<{ name: string }> | undefined, baseUrl?: string | undefined, paths?: Record<string, ReadonlyArray<string>> | undefined } | undefined }} TsConfig
 * @internal
 */
declare class FailedToReadConfigError extends Error {
    /**
     * @param {string} configFilePath
     * @param {object} [options]
     * @param {unknown} [options.cause]
     */
    constructor(configFilePath: string, options?: {
        cause?: unknown;
    });
    /**
     * @type {'FailedToReadConfigError'}
     */
    _tag: "FailedToReadConfigError";
}
/**
 * TypeError thrown when the user provided config factory is incorrectly typed
 * @internal
 */
declare class InvalidTsConfigError extends TypeError {
    /**
     * @param {object} [options]
     * @param {unknown} [options.cause]
     */
    constructor(options?: {
        cause?: unknown;
    });
    /**
     * @type {'InvalidConfigError'}
     */
    _tag: "InvalidConfigError";
}
type LoadTsConfigError = _tevm_effect.ParseJsonError | FailedToReadConfigError | InvalidTsConfigError;

/**
 * Error type for {@link getTevmConfigFromTsConfig}
 * @internal
 */
declare class NoPluginInTsConfigFoundError extends Error {
    /**
     * @type {'NoPluginInTsConfigFoundError'}
     */
    _tag: "NoPluginInTsConfigFoundError";
}
type GetTevmConfigFromTsConfigError = NoPluginInTsConfigFoundError | InvalidConfigError;

/**
 * TypeError thrown when the user provided config factory is incorrectly typed
 * @internal
 */
declare class InvalidJsonConfigError extends TypeError {
    /**
     * @param {object} [options]
     * @param {unknown} [options.cause]
     */
    constructor(options?: {
        cause?: unknown;
    });
    /**
     * @type {'InvalidJsonConfigError'}
     * @override
     */
    override name: "InvalidJsonConfigError";
    /**
     * @type {'InvalidJsonConfigError'}
     */
    _tag: "InvalidJsonConfigError";
}

/**
 * @typedef {import("./tsconfig/index.js").LoadTsConfigError | import("./tsconfig/index.js").GetTevmConfigFromTsConfigError | import("./foundry/index.js").LoadFoundryConfigError | InvalidJsonConfigError} LoadConfigErrorType
 */
/**
 * Error class for {@link loadConfig}
 */
declare class LoadConfigError extends Error {
    /**
     * @param {string} configFilePath
     * @param {LoadConfigErrorType} underlyingError
     **/
    constructor(configFilePath: string, underlyingError: LoadConfigErrorType);
    /**
     * @type {LoadConfigError['_tag']}
     * @override
     */
    override name: LoadConfigError["_tag"];
    /**
     * @type {LoadConfigErrorType['_tag']}
     **/
    _tag: LoadConfigErrorType["_tag"];
}
declare function loadConfig(configFilePath: string): effect_Effect.Effect<ResolvedCompilerConfig$1, LoadConfigError, never>;
type LoadConfigErrorType = LoadTsConfigError | GetTevmConfigFromTsConfigError | LoadFoundryConfigError | InvalidJsonConfigError;

type CompilerConfig = CompilerConfig$1;
type ResolvedCompilerConfig = ResolvedCompilerConfig$1;

export { type CompilerConfig, type ResolvedCompilerConfig, defaultConfig, defineConfig, loadConfig };
