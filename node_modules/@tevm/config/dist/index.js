import { flatMap, all, tap, logDebug, succeed, catchTags, catchTag, fail, tapError, try as _try, die, tapBoth, map } from 'effect/Effect';
import { Struct, optional, Union, String, Array as Array$1, Undefined, Boolean, Record, Literal, decodeUnknownEither } from '@effect/schema/Schema';
import { formatErrorSync } from '@effect/schema/TreeFormatter';
import { pipe } from 'effect';
import { match } from 'effect/Either';
import { execSync } from 'child_process';
import * as path2 from 'path';
import { logAllErrors, parseJson } from '@tevm/effect';
import { readFileSync, existsSync, writeFileSync } from 'fs';

// src/config/withDefaults.js
var defaultConfig = {
  jsonAsConst: [],
  foundryProject: false,
  remappings: {},
  libs: [],
  debug: false,
  cacheDir: ".tevm"
};
var withDefaults = (config) => succeed({
  jsonAsConst: (() => {
    if (config.jsonAsConst === void 0) {
      return defaultConfig.jsonAsConst;
    }
    if (Array.isArray(config.jsonAsConst)) {
      return config.jsonAsConst;
    }
    if (typeof config.jsonAsConst === "string") {
      return [config.jsonAsConst];
    }
    console.error("Invalid jsonAsConst value must be a string or array of strings");
    return defaultConfig.jsonAsConst;
  })(),
  foundryProject: config.foundryProject ?? defaultConfig.foundryProject,
  remappings: {
    ...defaultConfig.remappings,
    ...config.remappings
  },
  libs: [...defaultConfig.libs, ...config.libs ?? []],
  debug: config.debug ?? defaultConfig.debug,
  cacheDir: config.cacheDir ?? defaultConfig.cacheDir
}).pipe(
  tap(
    (configWithDefaults) => logDebug(
      `withDefaults: resolved config: ${JSON.stringify({
        originalConfig: config,
        configWithDefaults
      })}`
    )
  )
);
var mergeConfigs = (configs) => {
  var _a, _b, _c;
  return succeed({
    remappings: Object.fromEntries(configs.flatMap((config) => Object.entries(config.remappings ?? {}))),
    foundryProject: (_a = configs.reverse().find((config) => config.foundryProject !== void 0)) == null ? void 0 : _a.foundryProject,
    libs: [...new Set(configs.flatMap((config) => config.libs ?? []))],
    debug: (_b = configs.reverse().find((config) => config.debug !== void 0)) == null ? void 0 : _b.debug,
    cacheDir: (_c = configs.reverse().find((config) => config.cacheDir !== void 0)) == null ? void 0 : _c.cacheDir
  });
};
var ConfigFnThrowError = class extends Error {
  /**
   * @type {'ConfigFnThrowError'}
   */
  _tag = "ConfigFnThrowError";
  /**
   * @param {object} options
   * @param {unknown} options.cause
   */
  constructor(options) {
    const message = typeof options.cause === "string" ? options.cause : options.cause instanceof Error ? options.cause.message : "";
    super(`Provided config factory threw an error: ${message}`, options);
  }
};
var InvalidConfigError = class extends TypeError {
  /**
   * @type {'InvalidConfigError'}
   */
  _tag = "InvalidConfigError";
};
var SCompilerConfig = Struct({
  name: optional(Union(Literal("@tevm/ts-plugin"), Undefined)),
  foundryProject: optional(Union(Boolean, String, Undefined)),
  libs: optional(Union(Array$1(String), Undefined)),
  remappings: optional(Union(Record({ key: String, value: String }), Undefined)),
  debug: optional(Union(Boolean, Undefined)),
  cacheDir: optional(Union(String, Undefined)),
  jsonAsConst: optional(Union(String, Array$1(String), Undefined))
  // Updated property
});
var validateUserConfig = (untrustedConfigFactory) => {
  return pipe(
    _try({
      try: untrustedConfigFactory,
      catch: (cause) => new ConfigFnThrowError({
        cause
      })
    }),
    flatMap((unvalidatedConfig) => {
      const res = decodeUnknownEither(SCompilerConfig)(unvalidatedConfig, {
        errors: "all",
        onExcessProperty: "error"
      });
      return match(res, {
        onLeft: (left) => fail(new InvalidConfigError(formatErrorSync(left), { cause: left })),
        onRight: (right) => succeed(right)
      });
    }),
    tap(
      (validatedConfig) => logDebug(`validatedConfig: Validated config successfully: ${JSON.stringify(validatedConfig)}`)
    )
  );
};
var FoundryNotFoundError = class extends Error {
  /**
   * @type {'FoundryNotFoundError'}
   */
  _tag = "FoundryNotFoundError";
  /**
   * @param {string} forgeCommand
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(forgeCommand, options) {
    super(
      `Failed to resolve forge config using "${forgeCommand} config --json" command. Make sure forge is installed and accessible and forge config --json works.
note: forge is used to fetch remappings only if forgeConfig is set. If you would prefer to not use forge you can set remappings
or lib directly in your Tevm compiler config and then Tevm will run without forge`,
      options
    );
  }
};
var FoundryConfigError = class extends Error {
  /**
   * @type {'FoundryConfigError'}
   */
  _tag = "FoundryConfigError";
  /**
   * @param {string} forgeCommand
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(forgeCommand, options) {
    super(`Unable to resolve foundry config using ${forgeCommand} config --json`, options);
  }
};
var InvalidRemappingsError = class extends Error {
  /**
   * @type {'InvalidRemappingsError'}
   */
  _tag = "InvalidRemappingsError";
  /**
   * @param {string} remappings
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(remappings, options) {
    super(`Invalid remappings: ${remappings}`, options);
  }
};
var loadFoundryConfig = (foundryProject, configFilePath) => {
  if (!foundryProject) {
    return tap(succeed({}), () => logDebug("loadFoundryConfig: skipping because foundryProject is not set"));
  }
  const forgeCommand = typeof foundryProject === "string" ? foundryProject : "forge";
  let stdout;
  try {
    stdout = execSync(`${forgeCommand} config --json`, {
      cwd: configFilePath
    }).toString();
  } catch (cause) {
    console.error(cause);
    return fail(new FoundryNotFoundError(forgeCommand, { cause }));
  }
  let forgeConfig;
  try {
    forgeConfig = JSON.parse(stdout);
  } catch (cause) {
    console.error(cause);
    return fail(new FoundryConfigError(forgeCommand, { cause }));
  }
  const remappings = {};
  if (forgeConfig.remappings) {
    for (const remap of forgeConfig.remappings) {
      const parts = remap.split("=");
      if (parts.length !== 2) {
        return fail(new InvalidRemappingsError(remap));
      }
      const [key, value] = parts;
      remappings[key.trim()] = path2.join(configFilePath, value.trim());
    }
  }
  return tap(
    succeed({
      libs: forgeConfig == null ? void 0 : forgeConfig.libs,
      remappings
    }),
    (config) => {
      return logDebug(
        `loadFoundryConfig: foundryProject is set, loading foundry config as an Tevm CompilerConfig: ${JSON.stringify(
          config
        )}`
      );
    }
  );
};

// src/defineConfig.js
var DefineConfigError = class extends Error {
  /**
   * @type {import("./types.js").DefineConfigErrorType['_tag']}
   * @override
   */
  name;
  /**
   * @type {import("./types.js").DefineConfigErrorType['_tag']}
   **/
  _tag;
  /**
   * @param {string} configFilePath
   * @param {import("./types.js").DefineConfigErrorType} underlyingError
   **/
  constructor(configFilePath, underlyingError) {
    super(
      `${underlyingError._tag}: Unable to resolve Tevm CompilerConfig at ${configFilePath}
${underlyingError.message}`,
      { cause: underlyingError.cause }
    );
    this._tag = underlyingError._tag;
    this.name = underlyingError._tag;
  }
};
var defineConfig = (configFactory) => ({
  configFn: (configFilePath) => {
    const config = validateUserConfig(configFactory);
    const foundryConfig = flatMap(config, ({ foundryProject }) => loadFoundryConfig(foundryProject, configFilePath));
    const handleError = (error) => {
      return fail(new DefineConfigError(configFilePath, error));
    };
    return all([config, foundryConfig]).pipe(
      tap(
        ([userConfig, foundryConfig2]) => logDebug(
          `defineConfig: Config read CompilerConfigs ${JSON.stringify({
            userConfig,
            foundryConfig: foundryConfig2
          })}`
        )
      ),
      flatMap(mergeConfigs),
      tap((mergedConfigs) => logDebug(`defineConfig: MergedConfigs ${JSON.stringify({ mergedConfigs })}`)),
      flatMap(withDefaults),
      catchTags({
        InvalidRemappingsError: handleError,
        InvalidConfigError: handleError,
        FoundryNotFoundError: handleError,
        FoundryConfigError: handleError,
        ConfigFnThrowError: handleError
      }),
      tap(
        (config2) => logDebug(
          `defineConfig: Added defaults. Config read ${JSON.stringify({
            config: config2
          })}`
        )
      )
    );
  }
});
var FailedToReadConfigError = class extends Error {
  /**
   * @type {'FailedToReadConfigError'}
   */
  _tag = "FailedToReadConfigError";
  /**
   * @param {string} configFilePath
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(configFilePath, options) {
    super(`Failed to find tevm.config.json ${configFilePath}`, options);
  }
};
var InvalidJsonConfigError = class extends TypeError {
  /**
   * @type {'InvalidJsonConfigError'}
   * @override
   */
  name = "InvalidJsonConfigError";
  /**
   * @type {'InvalidJsonConfigError'}
   */
  _tag = "InvalidJsonConfigError";
  /**
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(options) {
    super("Invalid json detected", options);
  }
};
var loadJsonConfig = (configFilePath) => {
  const tevmConfigPath0 = path2.join(configFilePath, "tevm.config.json");
  const tevmConfigPath1 = path2.join(configFilePath, "tevm.json");
  const readConfig = (configPath) => _try({
    try: () => readFileSync(configPath, "utf8"),
    catch: (cause) => new FailedToReadConfigError(configFilePath, { cause })
  });
  return readConfig(tevmConfigPath0).pipe(
    catchTag("FailedToReadConfigError", () => {
      return readConfig(tevmConfigPath1);
    }),
    flatMap(parseJson),
    catchTag("ParseJsonError", (cause) => fail(new InvalidJsonConfigError({ cause }))),
    flatMap((cfg) => validateUserConfig(() => (
      /** @type {import('../types.js').CompilerConfig}*/
      cfg
    ))),
    // it can't throw. Could clean this up via making validateUserConfig take a config instead of a factory
    catchTag("ConfigFnThrowError", (e) => die(e)),
    tap((tsConfig) => logDebug(`loading tsconfig from ${configFilePath}: ${JSON.stringify(tsConfig)}`))
  );
};
var InvalidRemappingsError2 = class extends TypeError {
  /**
   * @type {'InvalidRemappingsError'}
   * @override
   */
  name = "InvalidRemappingsError";
  /**
   * @type {'InvalidRemappingsError'}
   */
  _tag = "InvalidRemappingsError";
};
var loadRemappings = (configFilePath) => {
  const remappingsPath = path2.join(configFilePath, "remappings.txt");
  const readConfig = (configPath) => _try({
    try: () => readFileSync(configPath, "utf8"),
    catch: () => new InvalidRemappingsError2("No remapping file exists")
  });
  return readConfig(remappingsPath).pipe(
    // if remappings doesn't exist that's fine just return nothing
    catchTag("InvalidRemappingsError", () => {
      return succeed("");
    }),
    flatMap((remappings) => {
      if (remappings.trim() === "") {
        return succeed({});
      }
      const remappingEntries = remappings.trim().split("\n");
      for (const remapping of remappingEntries) {
        if (remapping.trim() === "") {
          continue;
        }
        const remappingArr = remapping.split("=");
        if (remappingArr.length !== 2) {
          return fail(
            new InvalidRemappingsError2(
              `Invalid remapping ${remapping}. Remapping in remapping.txt should look like @solmate-utils/=lib/solmate/src/utils/`
            )
          );
        }
      }
      const config = {
        remappings: Object.fromEntries(
          remappingEntries.map((remapping) => {
            const [from, to] = remapping.trim().split("=");
            return (
              /** @type {[string, string]}*/
              [
                from,
                `${configFilePath.endsWith("/") ? configFilePath : `${configFilePath}/`}${(to == null ? void 0 : to.startsWith("/")) ? to.slice(1) : to}`
              ]
            );
          })
        )
      };
      return succeed(config);
    }),
    flatMap((cfg) => validateUserConfig(() => (
      /** @type {import('../types.js').CompilerConfig}*/
      cfg
    ))),
    // it can't thrw. Could clean this up via making validateUserConfig take a config instead of a factory
    catchTag("ConfigFnThrowError", (e) => die(e)),
    // internal error if this happens
    catchTag("InvalidConfigError", (e) => die(e)),
    tap(
      (normalizedConfig) => logDebug(`loading remappings from ${configFilePath}: ${JSON.stringify(normalizedConfig)}`)
    )
  );
};
var NoPluginInTsConfigFoundError = class extends Error {
  /**
   * @type {'NoPluginInTsConfigFoundError'}
   */
  _tag = "NoPluginInTsConfigFoundError";
};
var getTevmConfigFromTsConfig = (tsConfig, configPath) => {
  var _a, _b;
  if (!((_b = (_a = tsConfig.compilerOptions) == null ? void 0 : _a.plugins) == null ? void 0 : _b.length)) {
    return fail(new NoPluginInTsConfigFoundError("No compilerOptions.plugins in tsconfig"));
  }
  const plugin = (
    /**
     * @type {import("../types.js").CompilerConfig | undefined}
     */
    tsConfig.compilerOptions.plugins.find((plugin2) => plugin2.name === "@tevm/ts-plugin")
  );
  if (!plugin) {
    return fail(new NoPluginInTsConfigFoundError());
  }
  const { baseUrl, paths } = tsConfig.compilerOptions;
  const pathRemappings = Object.fromEntries(
    Object.entries(paths ?? {}).map(([key, value]) => {
      var _a2;
      return [
        key.replace(/\/\*$/, "/"),
        ((_a2 = value == null ? void 0 : value[0]) == null ? void 0 : _a2.replace(/^\./, configPath).replace(/\/\*$/, "/")) ?? ""
      ];
    })
  );
  return validateUserConfig(() => plugin).pipe(
    catchTag("ConfigFnThrowError", (e) => die(e)),
    map((config) => ({
      ...config,
      remappings: {
        ...config.remappings,
        ...pathRemappings
      }
    })),
    map(
      (config) => baseUrl ? {
        ...config,
        remappings: {
          ...pathRemappings,
          ...config.remappings
        },
        libs: [.../* @__PURE__ */ new Set([baseUrl, ...config.libs ?? []])]
      } : config
    ),
    tap((config) => {
      return logDebug(`getting config from tsconfig:
  tsconfig: ${JSON.stringify(config)}
  result: ${JSON.stringify(config)}`);
    })
  );
};
var FailedToReadConfigError2 = class extends Error {
  /**
   * @type {'FailedToReadConfigError'}
   */
  _tag = "FailedToReadConfigError";
  /**
   * @param {string} configFilePath
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(configFilePath, options) {
    super(`Failed to find ${configFilePath}/tsconfig.json`, options);
  }
};
var InvalidTsConfigError = class extends TypeError {
  /**
   * @type {'InvalidConfigError'}
   */
  _tag = "InvalidConfigError";
  /**
   * @param {object} [options]
   * @param {unknown} [options.cause]
   */
  constructor(options) {
    super("Invalid tsconfig.json detected", options);
  }
};
var STsConfigWithPlugin = Struct({
  compilerOptions: Struct({
    baseUrl: optional(String),
    plugins: Array$1(
      Struct({
        name: String
      })
    ),
    paths: optional(Record({ key: String, value: Array$1(String) }))
  })
});
var STsConfig = Struct({
  compilerOptions: Struct({
    baseUrl: optional(String),
    plugins: optional(
      Array$1(
        Struct({
          name: String
        })
      )
    ),
    paths: optional(Record({ key: String, value: Array$1(String) }))
  })
});
var loadTsConfig = (configFilePath) => {
  const tsConfigPath = path2.join(configFilePath, "tsconfig.json");
  const jsConfigPath = path2.join(configFilePath, "jsconfig.json");
  return _try({
    try: () => existsSync(jsConfigPath) ? readFileSync(jsConfigPath, "utf8") : readFileSync(tsConfigPath, "utf8"),
    catch: (cause) => new FailedToReadConfigError2(configFilePath, { cause })
  }).pipe(
    // parse the json
    flatMap(parseJson),
    // parse the tsconfig without plugins
    flatMap((unvalidatedConfig) => {
      const res = decodeUnknownEither(STsConfig)(unvalidatedConfig, {
        errors: "all",
        onExcessProperty: "ignore"
      });
      return match(res, {
        onLeft: (left) => fail(new InvalidTsConfigError({ cause: left })),
        onRight: (right) => succeed(right)
      });
    }),
    // add ts-plugin if it's missing
    tap(
      (unvalidatedConfig) => (
        // if it doesn't have the plugin automatically install
        decodeUnknownEither(STsConfigWithPlugin)(unvalidatedConfig, {
          errors: "all",
          onExcessProperty: "ignore"
        }).pipe(
          tapBoth({
            onFailure: () => {
              const newConfig = {
                ...unvalidatedConfig,
                compilerOptions: {
                  ...unvalidatedConfig.compilerOptions,
                  plugins: [{ name: "@tevm/ts-plugin" }]
                }
              };
              try {
                const path5 = existsSync(jsConfigPath) ? jsConfigPath : tsConfigPath;
                writeFileSync(path5, JSON.stringify(newConfig, null, 2));
              } catch (e) {
                console.error(e);
                console.error(
                  "Missing @tevm/ts-plugin in tsconfig.json and unable to add it automatically. Please add it manually."
                );
              }
              return succeed(newConfig);
            },
            onSuccess: (config) => {
              const hasPlugin = config.compilerOptions.plugins.some((plugin) => plugin.name === "@tevm/ts-plugin");
              if (!hasPlugin) {
                const newConfig = {
                  ...config,
                  compilerOptions: {
                    ...config.compilerOptions,
                    plugins: [{ name: "@tevm/ts-plugin" }, ...config.compilerOptions.plugins]
                  }
                };
                try {
                  const path5 = existsSync(jsConfigPath) ? jsConfigPath : tsConfigPath;
                  writeFileSync(path5, JSON.stringify(newConfig, null, 2));
                } catch (e) {
                  console.error(e);
                  console.error(
                    "Missing @tevm/ts-plugin in tsconfig.json and unable to add it automatically. Please add it manually."
                  );
                }
                return succeed(newConfig);
              }
              return succeed(config);
            }
          })
        )
      )
    ),
    flatMap((unvalidatedConfig) => {
      const res = decodeUnknownEither(STsConfigWithPlugin)(unvalidatedConfig, {
        errors: "all",
        onExcessProperty: "ignore"
      });
      return match(res, {
        onLeft: (left) => fail(new InvalidTsConfigError({ cause: left })),
        onRight: (right) => succeed(right)
      });
    }),
    catchTag("ParseError", (cause) => fail(new InvalidTsConfigError({ cause }))),
    tap((tsConfig) => logDebug(`loading tsconfig from ${configFilePath}: ${JSON.stringify(tsConfig)}`))
  );
};

// src/loadConfig.js
var LoadConfigError = class extends Error {
  /**
   * @type {LoadConfigError['_tag']}
   * @override
   */
  name;
  /**
   * @type {LoadConfigErrorType['_tag']}
   **/
  _tag;
  /**
   * @param {string} configFilePath
   * @param {LoadConfigErrorType} underlyingError
   **/
  constructor(configFilePath, underlyingError) {
    super(
      `${underlyingError._tag}: Unable load config from ${configFilePath}
${underlyingError.message}`,
      { cause: underlyingError.cause }
    );
    this._tag = underlyingError._tag;
    this.name = underlyingError._tag;
  }
};
var loadConfig = (configFilePath) => {
  const userConfig = logDebug(`loadConfig: loading userConfig at ${JSON.stringify(configFilePath)}`).pipe(
    flatMap(() => loadJsonConfig(configFilePath)),
    catchTag(
      "FailedToReadConfigError",
      (e) => logDebug(`loadConfig: loading tsConfig at ${JSON.stringify(configFilePath)}`).pipe(flatMap(() => loadTsConfig(configFilePath))).pipe(
        flatMap((tsConfig) => getTevmConfigFromTsConfig(tsConfig, configFilePath)),
        catchTag("NoPluginInTsConfigFoundError", () => fail(e)),
        catchTag("FailedToReadConfigError", () => fail(e))
      )
    )
  );
  const foundryConfig = flatMap(userConfig, (userConfig2) => {
    return loadFoundryConfig(userConfig2.foundryProject, configFilePath);
  });
  const remappingsConfig = loadRemappings(configFilePath);
  const handleError = (error) => {
    return fail(new LoadConfigError(configFilePath, error));
  };
  return all([userConfig, foundryConfig, remappingsConfig]).pipe(
    tap(
      ([userConfig2, foundryConfig2, remappingsConfig2]) => logDebug(
        `loadConfig: Config read CompilerConfigs ${JSON.stringify({
          userConfig: userConfig2,
          foundryConfig: foundryConfig2,
          remappingsConfig: remappingsConfig2
        })}`
      )
    ),
    flatMap(mergeConfigs),
    tap(
      (mergedConfigs) => logDebug(
        `loadConfig: Config read CompilerConfigs ${JSON.stringify({
          mergedConfigs
        })}`
      )
    ),
    flatMap(withDefaults),
    tapError(logAllErrors),
    catchTags({
      FailedToReadConfigError: handleError,
      FoundryConfigError: handleError,
      FoundryNotFoundError: handleError,
      InvalidConfigError: handleError,
      InvalidRemappingsError: handleError,
      ParseJsonError: handleError,
      InvalidJsonConfigError: handleError
    }),
    tap((config) => logDebug(`loadConfig: Config loaded ${JSON.stringify({ config })}`))
  );
};

export { defaultConfig, defineConfig, loadConfig };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map