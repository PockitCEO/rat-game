import { EVM, getActivePrecompiles, createEVM } from '@ethereumjs/evm';
export { EVMError, EOFContainer as Eof, Message as EthjsMessage, EVMError as EvmError, getActivePrecompiles } from '@ethereumjs/evm';
import { createLogger } from '@tevm/logger';
import { MisconfiguredClientError, InvalidParamsError } from '@tevm/errors';

// src/index.ts
var Evm = class _Evm extends EVM {
  /**
   * Adds a custom precompile to the EVM.
   * @param {import('./CustomPrecompile.js').CustomPrecompile} precompile
   * @throws {MisconfiguredClientError}
   */
  addCustomPrecompile(precompile) {
    if (this._customPrecompiles === void 0) {
      throw new MisconfiguredClientError(
        "Custom precompiles is empty. This is an internal bug as it should always be defined"
      );
    }
    this._customPrecompiles.push(precompile);
    this._precompiles = getActivePrecompiles(this.common, this._customPrecompiles);
  }
  /**
   * Removes a custom precompile from the EVM.
   * @param {import('./CustomPrecompile.js').CustomPrecompile} precompile
   * @throws {MisconfiguredClientError}
   * @throws {InvalidParamsError}
   */
  removeCustomPrecompile(precompile) {
    if (this._customPrecompiles === void 0) {
      throw new MisconfiguredClientError(
        "Custom precompiles is empty. This is an internal bug as it should always be defined"
      );
    }
    const index = this._customPrecompiles.indexOf(precompile);
    if (index === -1) {
      throw new InvalidParamsError("Precompile not found");
    }
    this._customPrecompiles.splice(index, 1);
    this._precompiles = getActivePrecompiles(this.common, this._customPrecompiles);
  }
  /**
   * @type {(typeof import('./EvmType.js').Evm)['create']}
   */
  static create = async (options) => {
    const evm = (
      /** @type {any}*/
      await createEVM(options)
    );
    evm.addCustomPrecompile = _Evm.prototype.addCustomPrecompile.bind(evm);
    evm.removeCustomPrecompile = _Evm.prototype.removeCustomPrecompile.bind(evm);
    return evm;
  };
};

// src/createEvm.js
var createEvm = async ({
  common,
  stateManager,
  blockchain,
  customPrecompiles,
  profiler,
  allowUnlimitedContractSize,
  loggingLevel
}) => {
  const logger = createLogger({
    name: "@tevm/evm",
    level: loggingLevel ?? "warn"
  });
  logger.debug({
    allowUnlimitedContractSize,
    profiler,
    customPrecompiles: customPrecompiles?.map((c) => c.address.toString())
  });
  const evm = await Evm.create({
    common: common.ethjsCommon,
    stateManager,
    blockchain,
    allowUnlimitedContractSize: allowUnlimitedContractSize ?? false,
    allowUnlimitedInitCodeSize: false,
    customOpcodes: [],
    // TODO uncomment the mapping once we make the api correct
    // Edit: nvm not letting this block a stable release maybe update it next major
    // @warning Always pass in an empty array if no precompiles as `addPrecompile` method assumes it's there
    customPrecompiles: customPrecompiles ?? [],
    profiler: {
      enabled: profiler ?? false
    }
  });
  if (loggingLevel === "trace") {
    const evmAny = (
      /** @type {any} */
      evm
    );
    evmAny.DEBUG = true;
    evmAny._debug = logger;
  }
  evm.addCustomPrecompile = evm.addCustomPrecompile?.bind(evm) ?? Evm.prototype.addCustomPrecompile.bind(evm);
  evm.removeCustomPrecompile = evm.removeCustomPrecompile?.bind(evm) ?? Evm.prototype.removeCustomPrecompile.bind(evm);
  return evm;
};

export { Evm, createEvm };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map