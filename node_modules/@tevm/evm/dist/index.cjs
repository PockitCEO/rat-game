'use strict';

var evm = require('@ethereumjs/evm');
var logger = require('@tevm/logger');
var errors = require('@tevm/errors');

// src/index.ts
var Evm = class _Evm extends evm.EVM {
  /**
   * Adds a custom precompile to the EVM.
   * @param {import('./CustomPrecompile.js').CustomPrecompile} precompile
   * @throws {MisconfiguredClientError}
   */
  addCustomPrecompile(precompile) {
    if (this._customPrecompiles === void 0) {
      throw new errors.MisconfiguredClientError(
        "Custom precompiles is empty. This is an internal bug as it should always be defined"
      );
    }
    this._customPrecompiles.push(precompile);
    this._precompiles = evm.getActivePrecompiles(this.common, this._customPrecompiles);
  }
  /**
   * Removes a custom precompile from the EVM.
   * @param {import('./CustomPrecompile.js').CustomPrecompile} precompile
   * @throws {MisconfiguredClientError}
   * @throws {InvalidParamsError}
   */
  removeCustomPrecompile(precompile) {
    if (this._customPrecompiles === void 0) {
      throw new errors.MisconfiguredClientError(
        "Custom precompiles is empty. This is an internal bug as it should always be defined"
      );
    }
    const index = this._customPrecompiles.indexOf(precompile);
    if (index === -1) {
      throw new errors.InvalidParamsError("Precompile not found");
    }
    this._customPrecompiles.splice(index, 1);
    this._precompiles = evm.getActivePrecompiles(this.common, this._customPrecompiles);
  }
  /**
   * @type {(typeof import('./EvmType.js').Evm)['create']}
   */
  static create = async (options) => {
    const evm$1 = (
      /** @type {any}*/
      await evm.createEVM(options)
    );
    evm$1.addCustomPrecompile = _Evm.prototype.addCustomPrecompile.bind(evm$1);
    evm$1.removeCustomPrecompile = _Evm.prototype.removeCustomPrecompile.bind(evm$1);
    return evm$1;
  };
};

// src/createEvm.js
var createEvm = async ({
  common,
  stateManager,
  blockchain,
  customPrecompiles,
  profiler,
  allowUnlimitedContractSize,
  loggingLevel
}) => {
  const logger$1 = logger.createLogger({
    name: "@tevm/evm",
    level: loggingLevel ?? "warn"
  });
  logger$1.debug({
    allowUnlimitedContractSize,
    profiler,
    customPrecompiles: customPrecompiles?.map((c) => c.address.toString())
  });
  const evm = await Evm.create({
    common: common.ethjsCommon,
    stateManager,
    blockchain,
    allowUnlimitedContractSize: allowUnlimitedContractSize ?? false,
    allowUnlimitedInitCodeSize: false,
    customOpcodes: [],
    // TODO uncomment the mapping once we make the api correct
    // Edit: nvm not letting this block a stable release maybe update it next major
    // @warning Always pass in an empty array if no precompiles as `addPrecompile` method assumes it's there
    customPrecompiles: customPrecompiles ?? [],
    profiler: {
      enabled: profiler ?? false
    }
  });
  if (loggingLevel === "trace") {
    const evmAny = (
      /** @type {any} */
      evm
    );
    evmAny.DEBUG = true;
    evmAny._debug = logger$1;
  }
  evm.addCustomPrecompile = evm.addCustomPrecompile?.bind(evm) ?? Evm.prototype.addCustomPrecompile.bind(evm);
  evm.removeCustomPrecompile = evm.removeCustomPrecompile?.bind(evm) ?? Evm.prototype.removeCustomPrecompile.bind(evm);
  return evm;
};

Object.defineProperty(exports, "EVMError", {
  enumerable: true,
  get: function () { return evm.EVMError; }
});
Object.defineProperty(exports, "Eof", {
  enumerable: true,
  get: function () { return evm.EOFContainer; }
});
Object.defineProperty(exports, "EthjsMessage", {
  enumerable: true,
  get: function () { return evm.Message; }
});
Object.defineProperty(exports, "EvmError", {
  enumerable: true,
  get: function () { return evm.EVMError; }
});
Object.defineProperty(exports, "getActivePrecompiles", {
  enumerable: true,
  get: function () { return evm.getActivePrecompiles; }
});
exports.Evm = Evm;
exports.createEvm = createEvm;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map