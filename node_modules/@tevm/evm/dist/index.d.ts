import { EVMOpts as EVMOpts$1, EVM } from '@ethereumjs/evm';
export { EVMError, EOFContainer as Eof, Message as EthjsMessage, EVMError as EvmError, EVMResult as EvmResult, EVMRunCallOpts as EvmRunCallOpts, ExecResult, InterpreterStep, Log, PrecompileInput, getActivePrecompiles } from '@ethereumjs/evm';
import { Chain } from '@tevm/blockchain';
import { Common } from '@tevm/common';
import { LogOptions } from '@tevm/logger';
import { Predeploy } from '@tevm/predeploys';
import { StateManager } from '@tevm/state';

/**
 * The options available to pass to the EVM. Inferred from ethereumjs/evm
 * @see https://github.com/ethereumjs/ethereumjs-monorepo/pull/3334
 * @example
 * ```typescript
 * import { type Evm, createEvm, CreateEvmOptions } from 'tevm/evm'
 * import { mainnet } from 'tevm/common'
 * import { createStateManager } from 'tevm/state'
 * import { createBlockchain } from 'tevm/blockchain'}
 * import { EthjsAddress } from 'tevm/utils'
 *
 * const evm: Evm = createEvm({
 *   common: mainnet.copy(),
 *   stateManager: createStateManager(),
 *   blockchain: createBlockchain(),
 * })
 * ```
 */
type EVMOpts = EVMOpts$1;

declare class Evm$1 extends EVM {
    stateManager: StateManager;
    protected _customPrecompiles: CustomPrecompile[];
    addCustomPrecompile(precompile: CustomPrecompile): void;
    removeCustomPrecompile(precompile: CustomPrecompile): void;
    static create(options?: EVMOpts): Promise<Evm$1>;
}

/**
 * TODO This should be publically exported from ethereumjs but isn't
 * Typing this by hand is tedious so we are using some typescript inference to get it
 * do a pr to export this from ethereumjs and then replace this with an import
 * TODO this should be modified to take a hex address rather than an ethjs address to be consistent with rest of Tevm
 */
/**
 * Custom precompiles allow you to run arbitrary JavaScript code in the EVM
 * @example
 * ```typescript
 * import { createMemoryClient } from 'tevm'
 * import { type CustomPrecompile } from 'tevm/evm'
 * import { definePrecompile, defineCall } from 'tevm'
 * import { createContract } from 'tevm/contract'
 *
 * const precompileContract = createContract({
 *   name: 'Precompile',
 *   humanReadableAbi: [
 *     'function cwd(string) returns (string)',
 *   ],
 * })
 * const customPrecompiles: CustomPrecompile = definePrecompile({
 *   contract: precompileContract,
 *   call: defineCall(precompileContract.abi, {
 *     cwd: async ({ args }) => {
 *       return {
 *         returnValue: process.cwd(),
 *         executionGasUsed: 0n,
 *       }
 *     },
 *   }),
 * })
 *
 * const memoryClient = createMemoryClient({ customPrecompiles: [customPrecompiles] })
 * ```
 * @see [Scripting guide](https://tevm.sh/learn/scripting/)
 * @see [definePrecompile](https://tevm.sh/reference/tevm/precompiles/functions/defineprecompile/)
 * @see [MemoryClient](https://tevm.sh/reference/tevm/memory-client/type-aliases/memoryclient/)
 */
type CustomPrecompile = Exclude<Exclude<Parameters<(typeof Evm$1)['create']>[0], undefined>['customPrecompiles'], undefined>[number];

/**
 * Options for [createEvm](https://tevm.sh/reference/tevm/evm/functions/createevm/)
 * @example
 * ```typescript
 * import { createEvm, CreateEvmOptions } from 'tevm/evm'
 * import { mainnet } from 'tevm/common'
 * import { createStateManager } from 'tevm/state'
 * import { createBlockchain } from 'tevm/blockchain'}
 * import { EthjsAddress } from 'tevm/utils'
 *
 * const evm = createEvm({
 *   common: mainnet.copy(),
 *   stateManager: createStateManager(),
 *   blockchain: createBlockchain(),
 * })
 *
 * const result = await evm.runCall({
 *   to: EthjsAddress.fromString(`0x${'0'.repeat(40)}`),
 *   value: 420n,
 *   skipBalance: true,
 * })
 *
 * console.log(result)
 * ```
 * The EVM is normally encapsolated by both `@tevm/vm` Vm, TevmNode, and MemoryClient.
 * @see [MemoryClient](https://tevm.sh/reference/tevm/memory-client/type-aliases/memoryclient/)
 * @see [TevmNode](https://tevm.sh/reference/tevm/node/functions/createbaseclient/)
 * @see [Vm](https://tevm.sh/reference/tevm/vm/functions/createvm/)
 */
type CreateEvmOptions = {
    /**
     * The logging level to run the evm at. Defaults to 'warn'
     */
    loggingLevel?: LogOptions['level'];
    /**
     * Ethereumjs common object
     */
    common: Common;
    /**
     * A custom Tevm state manager
     */
    stateManager: StateManager;
    /**
     * Enable profiler. Defaults to false.
     */
    profiler?: boolean;
    blockchain: Chain;
    /**
     * Custom precompiles allow you to run arbitrary JavaScript code in the EVM.
     * See the [Precompile guide](https://todo.todo) documentation for a deeper dive
     * An ever growing standard library of precompiles is provided at `tevm/precompiles`
     * @notice Not implemented yet {@link https://github.com/evmts/tevm-monorepo/pull/728/files | Implementation pr }
     *
     * Below example shows how to make a precompile so you can call `fs.writeFile` and `fs.readFile` in your contracts.
     * Note: this specific precompile is also provided in the standard library
     *
     * For security precompiles can only be added statically when the vm is created.
     * @example
     * ```ts
     * import { createMemoryClient, defineCall, definePrecompile } from 'tevm'
     * import { createContract } from '@tevm/contract'
     * import fs from 'fs/promises'
     *
     * const Fs = createContract({
     *   name: 'Fs',
     *   humanReadableAbi: [
     *     'function readFile(string path) returns (string)',
     *     'function writeFile(string path, string data) returns (bool)',
     *   ]
     * })
     *
     * const fsPrecompile = definePrecompile({
     * 	contract: Fs,
     * 	address: '0xf2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2',
     * 	call: defineCall(Fs.abi, {
     * 		readFile: async ({ args }) => {
     * 			return {
     * 				returnValue: await fs.readFile(...args, 'utf8'),
     * 				executionGasUsed: 0n,
     * 			}
     * 		},
     * 		writeFile: async ({ args }) => {
     * 			await fs.writeFile(...args)
     * 			return { returnValue: true, executionGasUsed: 0n }
     * 		},
     * 	}),
     * })
     *
     * const tevm = createMemoryClient({ customPrecompiles: [fsPrecompile] })
     */
    customPrecompiles?: CustomPrecompile[];
    /**
     * Custom predeploys allow you to deploy arbitrary EVM bytecode to an address.
     * This is a convenience method and equivalent to calling tevm.setAccount() manually
     * to set the contract code.
     * ```typescript
     * const tevm = createMemoryClient({
     *   customPredeploys: [
     *     // can pass a `tevm Script` here as well
     *     {
     *        address: '0x420420...',
     *        abi: [...],
     *        deployedBytecode: '0x420420...',
     *     }
     *   ],
     * })
     * ```
     */
    customPredeploys?: ReadonlyArray<Predeploy<any, any>>;
    /**
     * Enable/disable unlimited contract size. Defaults to false.
     */
    allowUnlimitedContractSize?: boolean;
};

declare function createEvm({ common, stateManager, blockchain, customPrecompiles, profiler, allowUnlimitedContractSize, loggingLevel, }: CreateEvmOptions): Promise<Evm$1>;

/**
 * The Tevm EVM is in charge of executing bytecode. It is a very light wrapper around ethereumjs EVM
 * The Evm class provides tevm specific typing with regard to the custom stateManager. It does not
 * provide custom typing to the blockchain or common objects.
 * @type {typeof import('./EvmType.js').Evm}
 * @example
 * ```typescript
 * import { type Evm, createEvm, CreateEvmOptions } from 'tevm/evm'
 * import { mainnet } from 'tevm/common'
 * import { createStateManager } from 'tevm/state'
 * import { createBlockchain } from 'tevm/blockchain'}
 * import { EthjsAddress } from 'tevm/utils'
 *
 * const evm = createEvm({
 *   common: mainnet.copy(),
 *   stateManager: createStateManager(),
 *   blockchain: createBlockchain(),
 * })
 * ```
 * @see [createEvm](https://tevm.sh/reference/tevm/evm/functions/createevm/)
 */
declare class Evm extends EVM {
    /**
     * @type {(typeof import('./EvmType.js').Evm)['create']}
     */
    static create: (typeof Evm$1)["create"];
    /**
     * Adds a custom precompile to the EVM.
     * @param {import('./CustomPrecompile.js').CustomPrecompile} precompile
     * @throws {MisconfiguredClientError}
     */
    addCustomPrecompile(precompile: CustomPrecompile): void;
    /**
     * Removes a custom precompile from the EVM.
     * @param {import('./CustomPrecompile.js').CustomPrecompile} precompile
     * @throws {MisconfiguredClientError}
     * @throws {InvalidParamsError}
     */
    removeCustomPrecompile(precompile: CustomPrecompile): void;
}

export { type CreateEvmOptions, type CustomPrecompile, type EVMOpts, Evm, Evm$1 as EvmType, createEvm };
