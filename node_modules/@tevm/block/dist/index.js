import { tevmDefault, ConsensusAlgorithm, ConsensusType } from '@tevm/common';
import { Rlp } from '@tevm/rlp';
import { Trie } from '@tevm/trie';
import { createTxFromBlockBodyData, createTxFromRLP, Capability, BlobEIP4844Transaction, TransactionFactory } from '@tevm/tx';
import { concatBytes, numberToHex, toBytes, equalsBytes, keccak256, KECCAK256_RLP_ARRAY, EthjsAddress, KECCAK256_RLP, bytesToHex, bytesToBigInt, ecrecover, hexToBytes, bytesToUtf8, createWithdrawal, toType, TypeOutput, setLengthLeft, isHex } from '@tevm/utils';
import { InternalError, MisconfiguredClientError } from '@tevm/errors';

// src/block.ts
var ClRequest = class {
  type;
  bytes;
  constructor(type, bytes) {
    if (type === void 0) throw new InternalError("request type is required");
    this.type = type;
    this.bytes = bytes;
  }
  serialize() {
    return concatBytes(Uint8Array.from([this.type]), this.bytes);
  }
};
function parseExecutionWitnessFromSnakeJson({
  state_diff,
  verkle_proof
}) {
  return {
    stateDiff: state_diff.map(({ stem, suffix_diffs }) => ({
      stem,
      suffixDiffs: suffix_diffs.map(({ current_value, new_value, suffix }) => ({
        currentValue: current_value,
        newValue: new_value,
        suffix
      }))
    })),
    verkleProof: {
      commitmentsByPath: verkle_proof.commitments_by_path,
      d: verkle_proof.d,
      depthExtensionPresent: verkle_proof.depth_extension_present,
      ipaProof: {
        cl: verkle_proof.ipa_proof.cl,
        cr: verkle_proof.ipa_proof.cr,
        finalEvaluation: verkle_proof.ipa_proof.final_evaluation
      },
      otherStems: verkle_proof.other_stems
    }
  };
}
function executionPayloadFromBeaconPayload(payload) {
  const executionPayload = {
    parentHash: payload.parent_hash,
    feeRecipient: payload.fee_recipient,
    stateRoot: payload.state_root,
    receiptsRoot: payload.receipts_root,
    logsBloom: payload.logs_bloom,
    prevRandao: payload.prev_randao,
    blockNumber: numberToHex(BigInt(payload.block_number)),
    gasLimit: numberToHex(BigInt(payload.gas_limit)),
    gasUsed: numberToHex(BigInt(payload.gas_used)),
    timestamp: numberToHex(BigInt(payload.timestamp)),
    extraData: payload.extra_data,
    baseFeePerGas: numberToHex(BigInt(payload.base_fee_per_gas)),
    blockHash: payload.block_hash,
    transactions: payload.transactions
  };
  if (payload.withdrawals !== void 0 && payload.withdrawals !== null) {
    executionPayload.withdrawals = payload.withdrawals.map((wd) => ({
      index: numberToHex(BigInt(wd.index)),
      validatorIndex: numberToHex(BigInt(wd.validator_index)),
      address: wd.address,
      amount: numberToHex(BigInt(wd.amount))
    }));
  }
  if (payload.blob_gas_used !== void 0 && payload.blob_gas_used !== null) {
    executionPayload.blobGasUsed = numberToHex(BigInt(payload.blob_gas_used));
  }
  if (payload.excess_blob_gas !== void 0 && payload.excess_blob_gas !== null) {
    executionPayload.excessBlobGas = numberToHex(BigInt(payload.excess_blob_gas));
  }
  if (payload.parent_beacon_block_root !== void 0 && payload.parent_beacon_block_root !== null) {
    executionPayload.parentBeaconBlockRoot = payload.parent_beacon_block_root;
  }
  if (payload.execution_witness !== void 0 && payload.execution_witness !== null) {
    executionPayload.executionWitness = payload.execution_witness.verkleProof !== void 0 ? payload.execution_witness : parseExecutionWitnessFromSnakeJson(payload.execution_witness);
  }
  return executionPayload;
}

// src/clique.ts
var CLIQUE_EXTRA_VANITY = 32;
var CLIQUE_EXTRA_SEAL = 65;
function zeros(length) {
  return new Uint8Array(length);
}
function createZeroAddress() {
  return new EthjsAddress(new Uint8Array(20));
}
function createAddressFromPublicKey(publicKey) {
  const addressBytes = keccak256(publicKey, "bytes").slice(-20);
  return new EthjsAddress(addressBytes);
}
function safeToType(input, outputType) {
  if (input === null || input === void 0) {
    return void 0;
  }
  if (typeof input === "string" && outputType === 2) {
    const bytes = toBytes(input);
    return toType(bytes, outputType);
  }
  return toType(input, outputType);
}
function getSignatureV(signature) {
  if (signature.v !== void 0) {
    return BigInt(signature.v);
  }
  if (signature.recovery !== void 0) {
    return BigInt(signature.recovery) + 27n;
  }
  throw new Error("Invalid signature format: missing v or recovery");
}

// src/helpers.ts
var numberToHex2 = (input) => {
  if (input === void 0) return void 0;
  if (!isHex(input)) {
    const regex = new RegExp(/^\d+$/);
    if (!regex.test(input)) {
      const msg = `Cannot convert string to hex string. numberToHex only supports 0x-prefixed hex or integer strings but the given string was: ${input}`;
      throw new Error(msg);
    }
    return `0x${Number.parseInt(input, 10).toString(16)}`;
  }
  return input;
};
function valuesArrayToHeaderData(values) {
  const [
    parentHash,
    uncleHash,
    coinbase,
    stateRoot,
    transactionsTrie,
    receiptTrie,
    logsBloom,
    difficulty,
    number,
    gasLimit,
    gasUsed,
    timestamp,
    extraData,
    mixHash,
    nonce,
    baseFeePerGas,
    withdrawalsRoot,
    blobGasUsed,
    excessBlobGas,
    parentBeaconBlockRoot,
    requestsRoot
  ] = values;
  if (values.length > 21) {
    throw new Error(`invalid header. More values than expected were received. Max: 20, got: ${values.length}`);
  }
  if (values.length < 15) {
    throw new Error(`invalid header. Less values than expected were received. Min: 15, got: ${values.length}`);
  }
  return {
    ...parentHash !== void 0 ? { parentHash } : {},
    ...uncleHash !== void 0 ? { uncleHash } : {},
    ...coinbase !== void 0 ? { coinbase } : {},
    ...stateRoot !== void 0 ? { stateRoot } : {},
    ...transactionsTrie !== void 0 ? { transactionsTrie } : {},
    ...receiptTrie !== void 0 ? { receiptTrie } : {},
    ...logsBloom !== void 0 ? { logsBloom } : {},
    ...difficulty !== void 0 ? { difficulty } : {},
    ...number !== void 0 ? { number } : {},
    ...gasLimit !== void 0 ? { gasLimit } : {},
    ...gasUsed !== void 0 ? { gasUsed } : {},
    ...timestamp !== void 0 ? { timestamp } : {},
    ...extraData !== void 0 ? { extraData } : {},
    ...mixHash !== void 0 ? { mixHash } : {},
    ...nonce !== void 0 ? { nonce } : {},
    ...baseFeePerGas !== void 0 ? { baseFeePerGas } : {},
    ...withdrawalsRoot !== void 0 ? { withdrawalsRoot } : {},
    ...blobGasUsed !== void 0 ? { blobGasUsed } : {},
    ...excessBlobGas !== void 0 ? { excessBlobGas } : {},
    ...parentBeaconBlockRoot !== void 0 ? { parentBeaconBlockRoot } : {},
    ...requestsRoot !== void 0 ? { requestsRoot } : {}
  };
}
function getDifficulty(headerData) {
  const { difficulty } = headerData;
  if (difficulty !== void 0) {
    return safeToType(difficulty, 1);
  }
  return null;
}
var fakeExponential = (factor, numerator, denominator) => {
  let i = BigInt(1);
  let output = BigInt(0);
  let numerator_accum = factor * denominator;
  while (numerator_accum > BigInt(0)) {
    output += numerator_accum;
    numerator_accum = numerator_accum * numerator / (denominator * i);
    i++;
  }
  return output / denominator;
};

// src/header.ts
var DEFAULT_GAS_LIMIT = BigInt("0xffffffffffffff");
var bigIntToUnpaddedBytes = (n) => {
  return toBytes(n).slice(2);
};
var BlockHeader = class _BlockHeader {
  parentHash;
  uncleHash;
  coinbase;
  stateRoot;
  transactionsTrie;
  receiptTrie;
  logsBloom;
  difficulty;
  number;
  gasLimit;
  gasUsed;
  timestamp;
  extraData;
  mixHash;
  nonce;
  baseFeePerGas;
  withdrawalsRoot;
  blobGasUsed;
  excessBlobGas;
  parentBeaconBlockRoot;
  requestsRoot;
  common;
  keccakFunction;
  cache = {
    hash: void 0
  };
  /**
   * EIP-4399: After merge to PoS, `mixHash` supplanted as `prevRandao`
   */
  get prevRandao() {
    if (!this.common.ethjsCommon.isActivatedEIP(4399)) {
      const msg = this._errorMsg("The prevRandao parameter can only be accessed when EIP-4399 is activated");
      throw new Error(msg);
    }
    return this.mixHash;
  }
  /**
   * Static constructor to create a block header from a header data dictionary
   *
   * @param headerData
   * @param opts
   */
  static fromHeaderData(headerData, opts) {
    return new _BlockHeader(headerData, opts);
  }
  /**
   * Static constructor to create a block header from a RLP-serialized header
   *
   * @param serializedHeaderData
   * @param opts
   */
  static fromRLPSerializedHeader(serializedHeaderData, opts) {
    const values = Rlp.decode(serializedHeaderData);
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized header input. Must be array");
    }
    return _BlockHeader.fromValuesArray(values, opts);
  }
  /**
   * Static constructor to create a block header from an array of Bytes values
   *
   * @param values
   * @param opts
   */
  static fromValuesArray(values, opts) {
    const headerData = valuesArrayToHeaderData(values);
    const { number, baseFeePerGas, excessBlobGas, blobGasUsed, parentBeaconBlockRoot, requestsRoot } = headerData;
    const header = _BlockHeader.fromHeaderData(headerData, opts);
    if (header.common.ethjsCommon.isActivatedEIP(1559) && baseFeePerGas === void 0) {
      const eip1559ActivationBlock = toBytes(header.common.ethjsCommon.eipBlock(1559));
      if (eip1559ActivationBlock !== void 0 && equalsBytes(eip1559ActivationBlock, number)) {
        throw new Error("invalid header. baseFeePerGas should be provided");
      }
    }
    if (header.common.ethjsCommon.isActivatedEIP(4844)) {
      if (excessBlobGas === void 0) {
        throw new Error("invalid header. excessBlobGas should be provided");
      }
      if (blobGasUsed === void 0) {
        throw new Error("invalid header. blobGasUsed should be provided");
      }
    }
    if (header.common.ethjsCommon.isActivatedEIP(4788) && parentBeaconBlockRoot === void 0) {
      throw new Error("invalid header. parentBeaconBlockRoot should be provided");
    }
    if (header.common.ethjsCommon.isActivatedEIP(7685) && requestsRoot === void 0) {
      throw new Error("invalid header. requestsRoot should be provided");
    }
    return header;
  }
  /**
   * This constructor takes the values, validates them, assigns them and freezes the object.
   *
   * @deprecated Use the public static factory methods to assist in creating a Header object from
   * varying data types. For a default empty header, use {@link BlockHeader.fromHeaderData}.
   *
   */
  constructor(headerData, opts) {
    if (opts.common) {
      this.common = opts.common.copy();
    } else {
      this.common = tevmDefault.copy();
    }
    this.keccakFunction = this.common.ethjsCommon.customCrypto.keccak256 ?? ((value) => keccak256(value, "bytes"));
    const skipValidateConsensusFormat = opts.skipConsensusFormatValidation ?? false;
    const defaults = {
      parentHash: zeros(32),
      uncleHash: KECCAK256_RLP_ARRAY,
      coinbase: createZeroAddress(),
      stateRoot: zeros(32),
      transactionsTrie: KECCAK256_RLP,
      receiptTrie: KECCAK256_RLP,
      logsBloom: zeros(256),
      difficulty: 0n,
      number: 0n,
      gasLimit: DEFAULT_GAS_LIMIT,
      gasUsed: 0n,
      timestamp: 0n,
      extraData: new Uint8Array(0),
      mixHash: zeros(32),
      nonce: zeros(8)
    };
    const parentHash = safeToType(headerData.parentHash, 2) ?? defaults.parentHash;
    const uncleHash = safeToType(headerData.uncleHash, 2) ?? defaults.uncleHash;
    const coinbase = new EthjsAddress(safeToType(headerData.coinbase ?? defaults.coinbase, 2));
    const stateRoot = safeToType(headerData.stateRoot, 2) ?? defaults.stateRoot;
    const transactionsTrie = safeToType(headerData.transactionsTrie, 2) ?? defaults.transactionsTrie;
    const receiptTrie = safeToType(headerData.receiptTrie, 2) ?? defaults.receiptTrie;
    const logsBloom = safeToType(headerData.logsBloom, 2) ?? defaults.logsBloom;
    const difficulty = safeToType(headerData.difficulty, 1) ?? defaults.difficulty;
    const number = safeToType(headerData.number, 1) ?? defaults.number;
    const gasLimit = safeToType(headerData.gasLimit, 1) ?? defaults.gasLimit;
    const gasUsed = safeToType(headerData.gasUsed, 1) ?? defaults.gasUsed;
    const timestamp = safeToType(headerData.timestamp, 1) ?? defaults.timestamp;
    const extraData = safeToType(headerData.extraData, 2) ?? defaults.extraData;
    const mixHash = safeToType(headerData.mixHash, 2) ?? defaults.mixHash;
    const nonce = safeToType(headerData.nonce, 2) ?? defaults.nonce;
    const setHardfork = opts.setHardfork ?? false;
    if (setHardfork === true) {
      this.common.ethjsCommon.setHardforkBy({
        blockNumber: number,
        timestamp
      });
    } else if (typeof setHardfork !== "boolean") {
      this.common.ethjsCommon.setHardforkBy({
        blockNumber: number,
        timestamp
      });
    }
    const hardforkDefaults = {
      baseFeePerGas: this.common.ethjsCommon.isActivatedEIP(1559) ? number === this.common.ethjsCommon.hardforkBlock("london") ? this.common.ethjsCommon.param("initialBaseFee") : 7n : void 0,
      withdrawalsRoot: this.common.ethjsCommon.isActivatedEIP(4895) ? KECCAK256_RLP : void 0,
      blobGasUsed: this.common.ethjsCommon.isActivatedEIP(4844) ? 0n : void 0,
      excessBlobGas: this.common.ethjsCommon.isActivatedEIP(4844) ? 0n : void 0,
      parentBeaconBlockRoot: this.common.ethjsCommon.isActivatedEIP(4788) ? zeros(32) : void 0,
      requestsRoot: this.common.ethjsCommon.isActivatedEIP(7685) ? KECCAK256_RLP : void 0
    };
    const baseFeePerGas = safeToType(headerData.baseFeePerGas, 1) ?? hardforkDefaults.baseFeePerGas;
    const withdrawalsRoot = safeToType(headerData.withdrawalsRoot, 2) ?? hardforkDefaults.withdrawalsRoot;
    const blobGasUsed = safeToType(headerData.blobGasUsed, 1) ?? hardforkDefaults.blobGasUsed;
    const excessBlobGas = safeToType(headerData.excessBlobGas, 1) ?? hardforkDefaults.excessBlobGas;
    const parentBeaconBlockRoot = safeToType(headerData.parentBeaconBlockRoot, 2) ?? hardforkDefaults.parentBeaconBlockRoot;
    const requestsRoot = safeToType(headerData.requestsRoot, 2) ?? hardforkDefaults.requestsRoot;
    if (!this.common.ethjsCommon.isActivatedEIP(1559) && baseFeePerGas !== void 0) {
      throw new Error("A base fee for a block can only be set with EIP1559 being activated");
    }
    if (!this.common.ethjsCommon.isActivatedEIP(4895) && withdrawalsRoot !== void 0) {
      throw new Error("A withdrawalsRoot for a header can only be provided with EIP4895 being activated");
    }
    if (!this.common.ethjsCommon.isActivatedEIP(4844)) {
      if (blobGasUsed !== void 0) {
        throw new Error("blob gas used can only be provided with EIP4844 activated");
      }
      if (excessBlobGas !== void 0) {
        throw new Error("excess blob gas can only be provided with EIP4844 activated");
      }
    }
    if (!this.common.ethjsCommon.isActivatedEIP(4788) && parentBeaconBlockRoot !== void 0) {
      throw new Error("A parentBeaconBlockRoot for a header can only be provided with EIP4788 being activated");
    }
    if (!this.common.ethjsCommon.isActivatedEIP(7685) && requestsRoot !== void 0) {
      throw new Error("requestsRoot can only be provided with EIP 7685 activated");
    }
    this.parentHash = parentHash;
    this.uncleHash = uncleHash;
    this.coinbase = coinbase;
    this.stateRoot = stateRoot;
    this.transactionsTrie = transactionsTrie;
    this.receiptTrie = receiptTrie;
    this.logsBloom = logsBloom;
    this.difficulty = difficulty;
    this.number = number;
    this.gasLimit = gasLimit;
    this.gasUsed = gasUsed;
    this.timestamp = timestamp;
    this.extraData = extraData;
    this.mixHash = mixHash;
    this.nonce = nonce;
    this.baseFeePerGas = baseFeePerGas;
    this.withdrawalsRoot = withdrawalsRoot;
    this.blobGasUsed = blobGasUsed;
    this.excessBlobGas = excessBlobGas;
    this.parentBeaconBlockRoot = parentBeaconBlockRoot;
    this.requestsRoot = requestsRoot;
    this._genericFormatValidation();
    this._validateDAOExtraData();
    if (opts.calcDifficultyFromHeader && this.common.ethjsCommon.consensusAlgorithm() === ConsensusAlgorithm.Ethash) {
      this.difficulty = this.ethashCanonicalDifficulty(opts.calcDifficultyFromHeader);
    }
    if (opts.cliqueSigner) {
      const minExtraDataLength = CLIQUE_EXTRA_VANITY + CLIQUE_EXTRA_SEAL;
      if (this.extraData.length < minExtraDataLength) {
        const remainingLength = minExtraDataLength - this.extraData.length;
        this.extraData = concatBytes(this.extraData, new Uint8Array(remainingLength));
      }
      this.extraData = this.cliqueSealBlock(opts.cliqueSigner);
    }
    if (skipValidateConsensusFormat === false) this._consensusFormatValidation();
    const freeze = opts?.freeze ?? true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  /**
   * Validates correct buffer lengths, throws if invalid.
   */
  _genericFormatValidation() {
    const { parentHash, stateRoot, transactionsTrie, receiptTrie, mixHash, nonce } = this;
    if (parentHash.length !== 32) {
      const msg = this._errorMsg(`parentHash must be 32 bytes, received ${parentHash.length} bytes`);
      throw new Error(msg);
    }
    if (stateRoot.length !== 32) {
      const msg = this._errorMsg(`stateRoot must be 32 bytes, received ${stateRoot.length} bytes`);
      throw new Error(msg);
    }
    if (transactionsTrie.length !== 32) {
      const msg = this._errorMsg(`transactionsTrie must be 32 bytes, received ${transactionsTrie.length} bytes`);
      throw new Error(msg);
    }
    if (receiptTrie.length !== 32) {
      const msg = this._errorMsg(`receiptTrie must be 32 bytes, received ${receiptTrie.length} bytes`);
      throw new Error(msg);
    }
    if (mixHash.length !== 32) {
      const msg = this._errorMsg(`mixHash must be 32 bytes, received ${mixHash.length} bytes`);
      throw new Error(msg);
    }
    if (nonce.length !== 8) {
      const msg = this._errorMsg(`nonce must be 8 bytes, received ${nonce.length} bytes`);
      throw new Error(msg);
    }
    if (this.gasUsed > this.gasLimit) {
      const msg = this._errorMsg(`Invalid block: too much gas used. Used: ${this.gasUsed}, gas limit: ${this.gasLimit}`);
      throw new Error(msg);
    }
    if (this.common.ethjsCommon.isActivatedEIP(1559)) {
      if (typeof this.baseFeePerGas !== "bigint") {
        const msg = this._errorMsg("EIP1559 block has no base fee field");
        throw new Error(msg);
      }
      const londonHfBlock = this.common.ethjsCommon.hardforkBlock("london");
      if (typeof londonHfBlock === "bigint" && londonHfBlock !== 0n && this.number === londonHfBlock) {
        const initialBaseFee = this.common.ethjsCommon.param("initialBaseFee");
        if (this.baseFeePerGas !== initialBaseFee) {
          const msg = this._errorMsg("Initial EIP1559 block does not have initial base fee");
          throw new Error(msg);
        }
      }
    }
    if (this.common.ethjsCommon.isActivatedEIP(4895)) {
      if (this.withdrawalsRoot === void 0) {
        const msg = this._errorMsg("EIP4895 block has no withdrawalsRoot field");
        throw new Error(msg);
      }
      if (this.withdrawalsRoot?.length !== 32) {
        const msg = this._errorMsg(`withdrawalsRoot must be 32 bytes, received ${this.withdrawalsRoot?.length} bytes`);
        throw new Error(msg);
      }
    }
    if (this.common.ethjsCommon.isActivatedEIP(4788)) {
      if (this.parentBeaconBlockRoot === void 0) {
        const msg = this._errorMsg("EIP4788 block has no parentBeaconBlockRoot field");
        throw new Error(msg);
      }
      if (this.parentBeaconBlockRoot?.length !== 32) {
        const msg = this._errorMsg(
          `parentBeaconBlockRoot must be 32 bytes, received ${this.parentBeaconBlockRoot?.length} bytes`
        );
        throw new Error(msg);
      }
    }
    if (this.common.ethjsCommon.isActivatedEIP(7685) === true) {
      if (this.requestsRoot === void 0) {
        const msg = this._errorMsg("EIP7685 block has no requestsRoot field");
        throw new Error(msg);
      }
    }
  }
  /**
   * Checks static parameters related to consensus algorithm
   * @throws if any check fails
   */
  _consensusFormatValidation() {
    const { nonce, uncleHash, difficulty, extraData, number } = this;
    if (this.common.ethjsCommon.consensusAlgorithm() === ConsensusAlgorithm.Ethash) {
      if (number > 0n && this.extraData.length > this.common.ethjsCommon.param("maxExtraDataSize")) {
        const msg = this._errorMsg("invalid amount of extra data");
        throw new Error(msg);
      }
    }
    if (this.common.ethjsCommon.consensusAlgorithm() === ConsensusAlgorithm.Clique) {
      const minLength = CLIQUE_EXTRA_VANITY + CLIQUE_EXTRA_SEAL;
      if (!this.cliqueIsEpochTransition()) {
        if (this.extraData.length !== minLength) {
          const msg = this._errorMsg(
            `extraData must be ${minLength} bytes on non-epoch transition blocks, received ${this.extraData.length} bytes`
          );
          throw new Error(msg);
        }
      } else {
        const signerLength = this.extraData.length - minLength;
        if (signerLength % 20 !== 0) {
          const msg = this._errorMsg(
            `invalid signer list length in extraData, received signer length of ${signerLength} (not divisible by 20)`
          );
          throw new Error(msg);
        }
        if (!this.coinbase.isZero()) {
          const msg = this._errorMsg(
            `coinbase must be filled with zeros on epoch transition blocks, received ${this.coinbase}`
          );
          throw new Error(msg);
        }
      }
      if (!equalsBytes(this.mixHash, new Uint8Array(32))) {
        const msg = this._errorMsg(`mixHash must be filled with zeros, received ${this.mixHash}`);
        throw new Error(msg);
      }
    }
    if (this.common.ethjsCommon.consensusType() === ConsensusType.ProofOfStake) {
      let error = false;
      let errorMsg = "";
      if (!equalsBytes(uncleHash, KECCAK256_RLP_ARRAY)) {
        errorMsg += `, uncleHash: ${bytesToHex(uncleHash)} (expected: ${bytesToHex(KECCAK256_RLP_ARRAY)})`;
        error = true;
      }
      if (number !== 0n) {
        if (difficulty !== 0n) {
          errorMsg += `, difficulty: ${difficulty} (expected: 0)`;
          error = true;
        }
        if (extraData.length > 32) {
          errorMsg += `, extraData: ${bytesToHex(extraData)} (cannot exceed 32 bytes length, received ${extraData.length} bytes)`;
          error = true;
        }
        if (!equalsBytes(nonce, zeros(8))) {
          errorMsg += `, nonce: ${bytesToHex(nonce)} (expected: ${bytesToHex(zeros(8))})`;
          error = true;
        }
      }
      if (error) {
        const msg = this._errorMsg(`Invalid PoS block: ${errorMsg}`);
        throw new Error(msg);
      }
    }
  }
  /**
   * Validates if the block gasLimit remains in the boundaries set by the protocol.
   * Throws if out of bounds.
   *
   * @param parentBlockHeader - the header from the parent `Block` of this header
   */
  validateGasLimit(parentBlockHeader) {
    let parentGasLimit = parentBlockHeader.gasLimit;
    const londonHardforkBlock = this.common.ethjsCommon.hardforkBlock("london");
    if (typeof londonHardforkBlock === "bigint" && londonHardforkBlock !== 0n && this.number === londonHardforkBlock) {
      const elasticity = this.common.ethjsCommon.param("elasticityMultiplier");
      parentGasLimit = parentGasLimit * elasticity;
    }
    const gasLimit = this.gasLimit;
    const a = parentGasLimit / this.common.ethjsCommon.param("gasLimitBoundDivisor");
    const maxGasLimit = parentGasLimit + a;
    const minGasLimit = parentGasLimit - a;
    if (gasLimit >= maxGasLimit) {
      const msg = this._errorMsg(`gas limit increased too much. Gas limit: ${gasLimit}, max gas limit: ${maxGasLimit}`);
      throw new Error(msg);
    }
    if (gasLimit <= minGasLimit) {
      const msg = this._errorMsg(`gas limit decreased too much. Gas limit: ${gasLimit}, min gas limit: ${minGasLimit}`);
      throw new Error(msg);
    }
    if (gasLimit < this.common.ethjsCommon.param("minGasLimit")) {
      const msg = this._errorMsg(
        `gas limit decreased below minimum gas limit. Gas limit: ${gasLimit}, minimum gas limit: ${this.common.ethjsCommon.param("minGasLimit")}`
      );
      throw new Error(msg);
    }
  }
  /**
   * Calculates the base fee for a potential next block
   */
  calcNextBaseFee() {
    if (!this.common.ethjsCommon.isActivatedEIP(1559)) {
      const msg = this._errorMsg("calcNextBaseFee() can only be called with EIP1559 being activated");
      throw new Error(msg);
    }
    let nextBaseFee;
    const elasticity = this.common.ethjsCommon.param("elasticityMultiplier");
    const parentGasTarget = this.gasLimit / elasticity;
    if (parentGasTarget === this.gasUsed) {
      nextBaseFee = this.baseFeePerGas;
    } else if (this.gasUsed > parentGasTarget) {
      const gasUsedDelta = this.gasUsed - parentGasTarget;
      const baseFeeMaxChangeDenominator = this.common.ethjsCommon.param("baseFeeMaxChangeDenominator");
      const calculatedDelta = this.baseFeePerGas * gasUsedDelta / parentGasTarget / baseFeeMaxChangeDenominator;
      nextBaseFee = (calculatedDelta > 1n ? calculatedDelta : 1n) + this.baseFeePerGas;
    } else {
      const gasUsedDelta = parentGasTarget - this.gasUsed;
      const baseFeeMaxChangeDenominator = this.common.ethjsCommon.param("baseFeeMaxChangeDenominator");
      const calculatedDelta = this.baseFeePerGas * gasUsedDelta / parentGasTarget / baseFeeMaxChangeDenominator;
      nextBaseFee = this.baseFeePerGas - calculatedDelta > 0n ? this.baseFeePerGas - calculatedDelta : 0n;
    }
    return nextBaseFee;
  }
  /**
   * Returns the price per unit of blob gas for a blob transaction in the current/pending block
   * @returns the price in gwei per unit of blob gas spent
   */
  getBlobGasPrice() {
    if (this.excessBlobGas === void 0) {
      throw new Error("header must have excessBlobGas field populated");
    }
    return this._getBlobGasPrice(this.excessBlobGas);
  }
  /**
   * Returns the blob gas price depending upon the `excessBlobGas` value
   * @param excessBlobGas
   */
  _getBlobGasPrice(excessBlobGas) {
    return fakeExponential(
      this.common.ethjsCommon.param("minBlobGasPrice"),
      excessBlobGas,
      this.common.ethjsCommon.param("blobGasPriceUpdateFraction")
    );
  }
  /**
   * Returns the total fee for blob gas spent for including blobs in block.
   *
   * @param numBlobs number of blobs in the transaction/block
   * @returns the total blob gas fee for numBlobs blobs
   */
  calcDataFee(numBlobs) {
    const blobGasPerBlob = this.common.ethjsCommon.param("blobGasPerBlob");
    const blobGasUsed = blobGasPerBlob * BigInt(numBlobs);
    const blobGasPrice = this.getBlobGasPrice();
    return blobGasUsed * blobGasPrice;
  }
  /**
   * Calculates the excess blob gas for next (hopefully) post EIP 4844 block.
   */
  calcNextExcessBlobGas() {
    const targetGasConsumed = (this.excessBlobGas ?? 0n) + (this.blobGasUsed ?? 0n);
    const targetBlobGasPerBlock = this.common.ethjsCommon.param("targetBlobGasPerBlock");
    if (targetGasConsumed <= targetBlobGasPerBlock) {
      return 0n;
    }
    return targetGasConsumed - targetBlobGasPerBlock;
  }
  /**
   * Calculate the blob gas price of the block built on top of this one
   * @returns The blob gas price
   */
  calcNextBlobGasPrice() {
    return this._getBlobGasPrice(this.calcNextExcessBlobGas());
  }
  /**
   * Returns a Uint8Array Array of the raw Bytes in this header, in order.
   */
  raw() {
    const rawItems = [
      this.parentHash,
      this.uncleHash,
      this.coinbase.bytes,
      this.stateRoot,
      this.transactionsTrie,
      this.receiptTrie,
      this.logsBloom,
      bigIntToUnpaddedBytes(this.difficulty),
      bigIntToUnpaddedBytes(this.number),
      bigIntToUnpaddedBytes(this.gasLimit),
      bigIntToUnpaddedBytes(this.gasUsed),
      bigIntToUnpaddedBytes(this.timestamp ?? 0n),
      this.extraData,
      this.mixHash,
      this.nonce
    ];
    if (this.common.ethjsCommon.isActivatedEIP(1559)) {
      rawItems.push(bigIntToUnpaddedBytes(this.baseFeePerGas));
    }
    if (this.common.ethjsCommon.isActivatedEIP(4895)) {
      rawItems.push(this.withdrawalsRoot);
    }
    if (this.common.ethjsCommon.isActivatedEIP(6800)) ;
    if (this.common.ethjsCommon.isActivatedEIP(4844)) {
      rawItems.push(bigIntToUnpaddedBytes(this.blobGasUsed));
      rawItems.push(bigIntToUnpaddedBytes(this.excessBlobGas));
    }
    if (this.common.ethjsCommon.isActivatedEIP(4788)) {
      rawItems.push(this.parentBeaconBlockRoot);
    }
    if (this.common.ethjsCommon.isActivatedEIP(7685) === true) {
      rawItems.push(this.requestsRoot);
    }
    return rawItems;
  }
  /**
   * Returns the hash of the block header.
   */
  hash() {
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = this.keccakFunction(Rlp.encode(this.raw()));
      }
      return this.cache.hash;
    }
    return this.keccakFunction(Rlp.encode(this.raw()));
  }
  /**
   * Checks if the block header is a genesis header.
   */
  isGenesis() {
    return this.number === 0n;
  }
  _requireClique(name) {
    if (this.common.ethjsCommon.consensusAlgorithm() !== ConsensusAlgorithm.Clique) {
      const msg = this._errorMsg(`BlockHeader.${name}() call only supported for clique PoA networks`);
      throw new Error(msg);
    }
  }
  /**
   * Returns the canonical difficulty for this block.
   *
   * @param parentBlockHeader - the header from the parent `Block` of this header
   */
  ethashCanonicalDifficulty(parentBlockHeader) {
    if (this.common.ethjsCommon.consensusType() !== ConsensusType.ProofOfWork) {
      const msg = this._errorMsg("difficulty calculation is only supported on PoW chains");
      throw new Error(msg);
    }
    if (this.common.ethjsCommon.consensusAlgorithm() !== ConsensusAlgorithm.Ethash) {
      const msg = this._errorMsg("difficulty calculation currently only supports the ethash algorithm");
      throw new Error(msg);
    }
    const blockTs = this.timestamp;
    const { timestamp: parentTs, difficulty: parentDif } = parentBlockHeader;
    const minimumDifficulty = this.common.ethjsCommon.param("minimumDifficulty");
    const offset = parentDif / this.common.ethjsCommon.param("difficultyBoundDivisor");
    let num = this.number;
    let dif;
    if (this.common.ethjsCommon.gteHardfork("byzantium") === true) {
      const uncleAddend = equalsBytes(parentBlockHeader.uncleHash, KECCAK256_RLP_ARRAY) ? 1 : 2;
      let a = BigInt(uncleAddend) - (blockTs - parentTs) / BigInt(9);
      const cutoff = BigInt(-99);
      if (cutoff > a) {
        a = cutoff;
      }
      dif = parentDif + offset * a;
    }
    if (this.common.ethjsCommon.gteHardfork("byzantium") === true) {
      num = num - this.common.ethjsCommon.param("difficultyBombDelay");
      if (num < 0n) {
        num = 0n;
      }
    } else if (this.common.ethjsCommon.gteHardfork("homestead") === true) {
      let a = 1n - (blockTs - parentTs) / BigInt(10);
      const cutoff = BigInt(-99);
      if (cutoff > a) {
        a = cutoff;
      }
      dif = parentDif + offset * a;
    } else {
      if (parentTs + this.common.ethjsCommon.param("durationLimit") > blockTs) {
        dif = offset + parentDif;
      } else {
        dif = parentDif - offset;
      }
    }
    const exp = num / BigInt(1e5) - 2n;
    if (exp >= 0) {
      dif = dif + 2n ** exp;
    }
    if (dif < minimumDifficulty) {
      dif = minimumDifficulty;
    }
    return dif;
  }
  /**
   * PoA clique signature hash without the seal.
   */
  cliqueSigHash() {
    this._requireClique("cliqueSigHash");
    const raw = this.raw();
    raw[12] = this.extraData.subarray(0, this.extraData.length - CLIQUE_EXTRA_SEAL);
    return this.keccakFunction(Rlp.encode(raw));
  }
  /**
   * Checks if the block header is an epoch transition
   * header (only clique PoA, throws otherwise)
   */
  cliqueIsEpochTransition() {
    this._requireClique("cliqueIsEpochTransition");
    const epoch = BigInt(this.common.ethjsCommon.consensusConfig().epoch);
    return this.number % epoch === 0n;
  }
  /**
   * Returns extra vanity data
   * (only clique PoA, throws otherwise)
   */
  cliqueExtraVanity() {
    this._requireClique("cliqueExtraVanity");
    return this.extraData.subarray(0, CLIQUE_EXTRA_VANITY);
  }
  /**
   * Returns extra seal data
   * (only clique PoA, throws otherwise)
   */
  cliqueExtraSeal() {
    this._requireClique("cliqueExtraSeal");
    return this.extraData.subarray(-CLIQUE_EXTRA_SEAL);
  }
  /**
   * Seal block with the provided signer.
   * Returns the final extraData field to be assigned to `this.extraData`.
   * @hidden
   */
  cliqueSealBlock(privateKey) {
    this._requireClique("cliqueSealBlock");
    const ecSignFunction = this.common.ethjsCommon.customCrypto?.ecsign;
    if (!ecSignFunction) {
      throw new Error("ecsign function must be provided in customCrypto for clique signing");
    }
    const signature = ecSignFunction(this.cliqueSigHash(), privateKey);
    const v = getSignatureV(signature);
    const vBytes = new Uint8Array([Number(v - 27n)]);
    const rBytes = toBytes(signature.r);
    const sBytes = toBytes(signature.s);
    const signatureB = concatBytes(rBytes, sBytes, vBytes);
    const extraDataWithoutSeal = this.extraData.subarray(0, this.extraData.length - CLIQUE_EXTRA_SEAL);
    const extraData = concatBytes(extraDataWithoutSeal, signatureB);
    return extraData;
  }
  /**
   * Returns a list of signers
   * (only clique PoA, throws otherwise)
   *
   * This function throws if not called on an epoch
   * transition block and should therefore be used
   * in conjunction with {@link BlockHeader.cliqueIsEpochTransition}
   */
  cliqueEpochTransitionSigners() {
    this._requireClique("cliqueEpochTransitionSigners");
    if (!this.cliqueIsEpochTransition()) {
      const msg = this._errorMsg("Signers are only included in epoch transition blocks (clique)");
      throw new Error(msg);
    }
    const start = CLIQUE_EXTRA_VANITY;
    const end = this.extraData.length - CLIQUE_EXTRA_SEAL;
    const signerBytes = this.extraData.subarray(start, end);
    const signerList = [];
    const signerLength = 20;
    for (let start2 = 0; start2 <= signerBytes.length - signerLength; start2 += signerLength) {
      signerList.push(signerBytes.subarray(start2, start2 + signerLength));
    }
    return signerList.map((buf) => new EthjsAddress(buf));
  }
  /**
   * Verifies the signature of the block (last 65 bytes of extraData field)
   * (only clique PoA, throws otherwise)
   *
   *  Method throws if signature is invalid
   */
  cliqueVerifySignature(signerList) {
    this._requireClique("cliqueVerifySignature");
    const signerAddress = this.cliqueSigner();
    const signerFound = signerList.find((signer) => {
      return signer.equals(signerAddress);
    });
    return !!signerFound;
  }
  /**
   * Returns the signer address
   */
  cliqueSigner() {
    this._requireClique("cliqueSigner");
    const extraSeal = this.cliqueExtraSeal();
    if (extraSeal.length === 0 || equalsBytes(extraSeal, new Uint8Array(65))) {
      return createZeroAddress();
    }
    const r = extraSeal.subarray(0, 32);
    const s = extraSeal.subarray(32, 64);
    const v = bytesToBigInt(extraSeal.subarray(64, 65)) + 27n;
    const pubKey = ecrecover(this.cliqueSigHash(), v, r, s);
    return createAddressFromPublicKey(pubKey);
  }
  /**
   * Returns the rlp encoding of the block header.
   */
  serialize() {
    return Rlp.encode(this.raw());
  }
  /**
   * Returns the block header in JSON format.
   */
  toJSON() {
    const withdrawalAttr = this.withdrawalsRoot ? { withdrawalsRoot: bytesToHex(this.withdrawalsRoot) } : {};
    const jsonDict = {
      parentHash: bytesToHex(this.parentHash),
      uncleHash: bytesToHex(this.uncleHash),
      coinbase: this.coinbase.toString(),
      stateRoot: bytesToHex(this.stateRoot),
      transactionsTrie: bytesToHex(this.transactionsTrie),
      ...withdrawalAttr,
      receiptTrie: bytesToHex(this.receiptTrie),
      logsBloom: bytesToHex(this.logsBloom),
      difficulty: numberToHex(this.difficulty),
      number: numberToHex(this.number),
      gasLimit: numberToHex(this.gasLimit),
      gasUsed: numberToHex(this.gasUsed),
      timestamp: numberToHex(this.timestamp),
      extraData: bytesToHex(this.extraData),
      mixHash: bytesToHex(this.mixHash),
      nonce: bytesToHex(this.nonce)
    };
    if (this.common.ethjsCommon.isActivatedEIP(1559)) {
      jsonDict.baseFeePerGas = numberToHex(this.baseFeePerGas);
    }
    if (this.common.ethjsCommon.isActivatedEIP(4844)) {
      jsonDict.blobGasUsed = numberToHex(this.blobGasUsed);
      jsonDict.excessBlobGas = numberToHex(this.excessBlobGas);
    }
    if (this.common.ethjsCommon.isActivatedEIP(4788)) {
      jsonDict.parentBeaconBlockRoot = bytesToHex(this.parentBeaconBlockRoot);
    }
    if (this.common.ethjsCommon.isActivatedEIP(7685)) {
      jsonDict.requestsRoot = bytesToHex(this.requestsRoot);
    }
    return jsonDict;
  }
  /**
   * Validates extra data is DAO_ExtraData for DAO_ForceExtraDataRange blocks after DAO
   * activation block (see: https://blog.slock.it/hard-fork-specification-24b889e70703)
   */
  _validateDAOExtraData() {
    if (this.common.ethjsCommon.hardforkIsActiveOnBlock("dao", this.number) === false) {
      return;
    }
    const DAOActivationBlock = this.common.ethjsCommon.hardforkBlock("dao");
    if (DAOActivationBlock === null || this.number < DAOActivationBlock) {
      return;
    }
    const DAO_ExtraData = hexToBytes("0x64616f2d686172642d666f726b");
    const DAO_ForceExtraDataRange = BigInt(9);
    const drift = this.number - DAOActivationBlock;
    if (drift <= DAO_ForceExtraDataRange && !equalsBytes(this.extraData, DAO_ExtraData)) {
      const msg = this._errorMsg(
        `extraData should be 'dao-hard-fork', got ${bytesToUtf8(this.extraData)} (hex: ${bytesToHex(this.extraData)})`
      );
      throw new Error(msg);
    }
  }
  /**
   * Return a compact error string representation of the object
   */
  errorStr() {
    let hash = "";
    try {
      hash = bytesToHex(this.hash());
    } catch (_e) {
      hash = "error";
    }
    let hf = "";
    try {
      hf = this.common.ethjsCommon.hardfork();
    } catch (_e) {
      hf = "error";
    }
    let errorStr = `block header number=${this.number} hash=${hash} `;
    errorStr += `hf=${hf} baseFeePerGas=${this.baseFeePerGas ?? "none"}`;
    return errorStr;
  }
  /**
   * Helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
};

// src/block.ts
var Block = class _Block {
  header;
  transactions = [];
  uncleHeaders = [];
  withdrawals;
  requests;
  common;
  keccakFunction;
  /**
   * EIP-6800: Verkle Proof Data (experimental)
   * null implies that the non default executionWitness might exist but not available
   * and will not lead to execution of the block via vm with verkle stateless manager
   */
  executionWitness;
  cache = {};
  /**
   * Returns the withdrawals trie root for array of Withdrawal.
   * @param wts array of Withdrawal to compute the root of
   * @param optional emptyTrie to use to generate the root
   */
  static async genWithdrawalsTrieRoot(wts, emptyTrie) {
    const trie = emptyTrie ?? new Trie();
    for (const [i, wt] of wts.entries()) {
      await trie.put(Rlp.encode(i), Rlp.encode(wt.raw()));
    }
    return trie.root();
  }
  /**
   * Returns the txs trie root for array of TypedTransaction
   * @param txs array of TypedTransaction to compute the root of
   * @param optional emptyTrie to use to generate the root
   */
  static async genTransactionsTrieRoot(txs, emptyTrie) {
    const trie = emptyTrie ?? new Trie();
    for (const [i, tx] of txs.entries()) {
      await trie.put(Rlp.encode(i), tx.serialize());
    }
    return trie.root();
  }
  /**
   * Returns the requests trie root for an array of CLRequests
   * @param requests - an array of CLRequests
   * @param emptyTrie optional empty trie used to generate the root
   * @returns a 32 byte Uint8Array representing the requests trie root
   */
  static async genRequestsTrieRoot(requests, emptyTrie) {
    const trie = emptyTrie ?? new Trie();
    for (const [i, req] of requests.entries()) {
      await trie.put(Rlp.encode(i), req.serialize());
    }
    return trie.root();
  }
  /**
   * Static constructor to create a block from a block data dictionary
   *
   * @param blockData
   * @param opts
   * @deprecated Use createBlock() instead - this method is kept for compatibility
   */
  static fromBlockData(blockData, opts) {
    const {
      header: headerData,
      transactions: txsData,
      uncleHeaders: uhsData,
      withdrawals: withdrawalsData,
      executionWitness: executionWitnessData,
      requests: clRequests
    } = blockData;
    const header = BlockHeader.fromHeaderData(headerData, opts);
    const transactions = [];
    for (const txData of txsData ?? []) {
      transactions.push(txData);
    }
    const uncleHeaders = [];
    const { calcDifficultyFromHeader, ...restOpts } = opts;
    const uncleOpts = {
      ...restOpts,
      // Use header common in case of setHardfork being activated
      common: header.common
    };
    if (opts?.setHardfork !== void 0) {
      uncleOpts.setHardfork = true;
    }
    for (const uhData of uhsData ?? []) {
      const uh = BlockHeader.fromHeaderData(uhData, uncleOpts);
      uncleHeaders.push(uh);
    }
    const withdrawals = withdrawalsData?.map(createWithdrawal);
    const executionWitness = executionWitnessData;
    return new _Block(opts, header, transactions, uncleHeaders, withdrawals, clRequests, executionWitness);
  }
  /**
   * Static constructor to create a block from a RLP-serialized block
   *
   * @param serialized
   * @param opts
   * @deprecated Use createBlockFromRLP() instead - this method is kept for compatibility
   */
  static fromRLPSerializedBlock(serialized, opts) {
    const values = Rlp.decode(Uint8Array.from(serialized));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized block input. Must be array");
    }
    return _Block.fromValuesArray(values, opts);
  }
  /**
   * Static constructor to create a block from an array of Bytes values
   *
   * @param values
   * @param opts
   * @deprecated Use createBlockFromValuesArray() instead - this method is kept for compatibility
   */
  static fromValuesArray(values, opts) {
    if (values.length > 5) {
      throw new Error(`invalid block. More values=${values.length} than expected were received (at most 5)`);
    }
    const [headerData, txsData, uhsData, withdrawalBytes, requestBytes, executionWitnessBytes] = values;
    const header = BlockHeader.fromValuesArray(headerData, opts);
    if (header.common.ethjsCommon.isActivatedEIP(4895) && (withdrawalBytes === void 0 || !Array.isArray(withdrawalBytes))) {
      throw new Error("Invalid serialized block input: EIP-4895 is active, and no withdrawals were provided as array");
    }
    const transactions = [];
    for (const txData of txsData ?? []) {
      transactions.push(
        createTxFromBlockBodyData(txData, {
          ...opts,
          // Use header common in case of setHardfork being activated
          common: header.common.ethjsCommon
        })
      );
    }
    const uncleHeaders = [];
    const { calcDifficultyFromHeader: _, ...carriedOverUncleOpts } = opts ?? {};
    const uncleOpts = {
      ...carriedOverUncleOpts,
      // Use header common in case of setHardfork being activated
      common: header.common
    };
    if (opts?.setHardfork !== void 0) {
      uncleOpts.setHardfork = true;
    }
    for (const uncleHeaderData of uhsData ?? []) {
      uncleHeaders.push(BlockHeader.fromValuesArray(uncleHeaderData, uncleOpts));
    }
    const withdrawals = withdrawalBytes?.map(([index, validatorIndex, address, amount]) => ({
      index,
      validatorIndex,
      address,
      amount
    }))?.map((w) => createWithdrawal(w));
    let requests = [];
    if (header.common.ethjsCommon.isActivatedEIP(7685)) {
      requests = requestBytes.map((bytes) => new ClRequest(bytes[0], bytes.slice(1)));
    }
    let executionWitness = null;
    if (header.common.ethjsCommon.isActivatedEIP(6800)) {
      if (executionWitnessBytes !== void 0) {
        executionWitness = JSON.parse(bytesToUtf8(Rlp.decode(executionWitnessBytes)));
      } else if (opts?.executionWitness !== void 0) {
        executionWitness = opts.executionWitness;
      } else {
        executionWitness = null;
      }
    }
    return new _Block(opts, header, transactions, uncleHeaders, withdrawals, requests, executionWitness);
  }
  /**
   *  Method to retrieve a block from an execution payload
   * @param execution payload constructed from beacon payload
   * @param opts {@link BlockOptions}
   * @returns the block constructed block
   */
  static async fromExecutionPayload(payload, opts) {
    const {
      blockNumber: number,
      receiptsRoot: receiptTrie,
      prevRandao: mixHash,
      feeRecipient: coinbase,
      transactions,
      withdrawals: withdrawalsData,
      requestsRoot,
      executionWitness
    } = payload;
    const txs = [];
    for (const [index, serializedTx] of transactions.entries()) {
      try {
        const tx = createTxFromRLP(hexToBytes(serializedTx), {
          common: opts?.common.ethjsCommon
        });
        txs.push(tx);
      } catch (error) {
        const validationError = `Invalid tx at index ${index}: ${error}`;
        throw validationError;
      }
    }
    const reqRoot = requestsRoot === null ? void 0 : requestsRoot;
    const transactionsTrie = await _Block.genTransactionsTrieRoot(txs, new Trie({ common: opts?.common.ethjsCommon }));
    const withdrawals = withdrawalsData?.map((wData) => createWithdrawal(wData));
    const withdrawalsRoot = withdrawals ? await _Block.genWithdrawalsTrieRoot(withdrawals, new Trie({ common: opts?.common.ethjsCommon })) : void 0;
    const header = {
      ...payload,
      number,
      receiptTrie,
      transactionsTrie,
      withdrawalsRoot,
      mixHash,
      coinbase,
      requestsRoot: reqRoot
    };
    const block = _Block.fromBlockData({ header, transactions: txs, withdrawals, executionWitness }, opts);
    if (block.common.ethjsCommon.isActivatedEIP(6800) && (executionWitness === void 0 || executionWitness === null)) {
      throw Error("Missing executionWitness for EIP-6800 activated executionPayload");
    }
    if (!equalsBytes(block.hash(), hexToBytes(payload.blockHash))) {
      const validationError = `Invalid blockHash, expected: ${payload.blockHash}, received: ${bytesToHex(block.hash())}`;
      throw Error(validationError);
    }
    return block;
  }
  /**
   *  Method to retrieve a block from a beacon payload json
   * @param payload json of a beacon beacon fetched from beacon apis
   * @param opts {@link BlockOptions}
   * @returns the block constructed block
   */
  static async fromBeaconPayloadJson(payload, opts) {
    const executionPayload = executionPayloadFromBeaconPayload(payload);
    return _Block.fromExecutionPayload(executionPayload, opts);
  }
  /**
   * This constructor takes the values, validates them, assigns them and freezes the object.
   * Use the static factory methods to assist in creating a Block object from varying data types and options.
   */
  constructor(opts, header, transactions = [], uncleHeaders = [], withdrawals, requests, executionWitness) {
    this.header = header ?? BlockHeader.fromHeaderData({}, opts);
    this.common = this.header.common;
    this.keccakFunction = this.common.ethjsCommon.customCrypto.keccak256 ?? ((item) => keccak256(item, "bytes"));
    this.transactions = transactions;
    this.withdrawals = withdrawals ?? (this.common.ethjsCommon.isActivatedEIP(4895) ? [] : void 0);
    this.executionWitness = executionWitness;
    this.requests = requests ?? (this.common.ethjsCommon.isActivatedEIP(7685) ? [] : void 0);
    if (this.common.ethjsCommon.isActivatedEIP(6800) && this.executionWitness === void 0) {
      this.executionWitness = {
        stateDiff: [],
        verkleProof: {
          commitmentsByPath: [],
          d: "0x",
          depthExtensionPresent: "0x",
          ipaProof: {
            cl: [],
            cr: [],
            finalEvaluation: "0x"
          },
          otherStems: []
        }
      };
    }
    this.uncleHeaders = uncleHeaders;
    if (uncleHeaders.length > 0) {
      this.validateUncles();
      if (this.common.ethjsCommon.consensusType() === ConsensusType.ProofOfAuthority) {
        const msg = this._errorMsg("Block initialization with uncleHeaders on a PoA network is not allowed");
        throw new Error(msg);
      }
      if (this.common.ethjsCommon.consensusType() === ConsensusType.ProofOfStake) {
        const msg = this._errorMsg("Block initialization with uncleHeaders on a PoS network is not allowed");
        throw new Error(msg);
      }
    }
    if (!this.common.ethjsCommon.isActivatedEIP(4895) && withdrawals !== void 0) {
      throw new Error("Cannot have a withdrawals field if EIP 4895 is not active");
    }
    if (!this.common.ethjsCommon.isActivatedEIP(6800) && executionWitness !== void 0 && executionWitness !== null) {
      throw new Error("Cannot have executionWitness field if EIP 6800 is not active ");
    }
    if (!this.common.ethjsCommon.isActivatedEIP(7685) && requests !== void 0) {
      throw new Error("Cannot have requests field if EIP 7685 is not active");
    }
    if (requests !== void 0 && requests.length > 1) {
      for (let x = 1; x < requests.length; x++) {
        if (requests[x].type < requests[x - 1].type)
          throw new Error("requests are not sorted in ascending order");
      }
    }
    const freeze = opts?.freeze ?? true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  /**
   * Returns a Array of the raw Bytes Arrays of this block, in order.
   */
  raw() {
    const bytesArray = [
      this.header.raw(),
      this.transactions.map(
        (tx) => tx.supports(Capability.EIP2718TypedTransaction) ? tx.serialize() : tx.raw()
      ),
      this.uncleHeaders.map((uh) => uh.raw())
    ];
    const withdrawalsRaw = this.withdrawals?.map((wt) => wt.raw());
    if (withdrawalsRaw) {
      bytesArray.push(withdrawalsRaw);
    }
    if (this.executionWitness !== void 0 && this.executionWitness !== null) {
      const executionWitnessBytes = Rlp.encode(JSON.stringify(this.executionWitness));
      bytesArray.push(executionWitnessBytes);
    }
    return bytesArray;
  }
  /**
   * Returns the hash of the block.
   */
  hash() {
    return this.header.hash();
  }
  /**
   * Determines if this block is the genesis block.
   */
  isGenesis() {
    return this.header.isGenesis();
  }
  /**
   * Returns the rlp encoding of the block.
   */
  serialize() {
    return Rlp.encode(this.raw());
  }
  /**
   * Generates transaction trie for validation.
   */
  async genTxTrie() {
    return _Block.genTransactionsTrieRoot(this.transactions, new Trie({ common: this.common.ethjsCommon }));
  }
  /**
   * Validates the transaction trie by generating a trie
   * and do a check on the root hash.
   * @returns True if the transaction trie is valid, false otherwise
   */
  async transactionsTrieIsValid() {
    let result;
    if (this.transactions.length === 0) {
      result = equalsBytes(this.header.transactionsTrie, KECCAK256_RLP);
      return result;
    }
    if (this.cache.txTrieRoot === void 0) {
      this.cache.txTrieRoot = await this.genTxTrie();
    }
    result = equalsBytes(this.cache.txTrieRoot, this.header.transactionsTrie);
    return result;
  }
  async requestsTrieIsValid() {
    if (!this.common.ethjsCommon.isActivatedEIP(7685)) {
      throw new Error("EIP 7685 is not activated");
    }
    let result;
    if (this.requests?.length === 0) {
      result = equalsBytes(this.header.requestsRoot, KECCAK256_RLP);
      return result;
    }
    if (this.cache.requestsRoot === void 0) {
      this.cache.requestsRoot = await _Block.genRequestsTrieRoot(this.requests ?? []);
    }
    result = equalsBytes(this.cache.requestsRoot, this.header.requestsRoot);
    return result;
  }
  /**
   * Validates transaction signatures and minimum gas requirements.
   * @returns {string[]} an array of error strings
   */
  getTransactionsValidationErrors() {
    const errors = [];
    let blobGasUsed = 0n;
    const blobGasLimit = this.common.ethjsCommon.param("maxblobGasPerBlock");
    const blobGasPerBlob = this.common.ethjsCommon.param("blobGasPerBlob");
    for (let [i, tx] of this.transactions.entries()) {
      const errs = tx.getValidationErrors();
      if (this.common.ethjsCommon.isActivatedEIP(1559)) {
        if (tx.supports(Capability.EIP1559FeeMarket)) {
          tx = tx;
          if (tx.maxFeePerGas < this.header.baseFeePerGas) {
            errs.push("tx unable to pay base fee (EIP-1559 tx)");
          }
        } else {
          tx = tx;
          if (tx.gasPrice < this.header.baseFeePerGas) {
            errs.push("tx unable to pay base fee (non EIP-1559 tx)");
          }
        }
      }
      if (this.common.ethjsCommon.isActivatedEIP(4844)) {
        if (tx instanceof BlobEIP4844Transaction) {
          blobGasUsed += BigInt(tx.numBlobs()) * blobGasPerBlob;
          if (blobGasUsed > blobGasLimit) {
            errs.push(
              `tx causes total blob gas of ${blobGasUsed} to exceed maximum blob gas per block of ${blobGasLimit}`
            );
          }
        }
      }
      if (errs.length > 0) {
        errors.push(`errors at tx ${i}: ${errs.join(", ")}`);
      }
    }
    if (this.common.ethjsCommon.isActivatedEIP(4844)) {
      if (blobGasUsed !== this.header.blobGasUsed) {
        errors.push(`invalid blobGasUsed expected=${this.header.blobGasUsed} actual=${blobGasUsed}`);
      }
    }
    return errors;
  }
  /**
   * Validates transaction signatures and minimum gas requirements.
   * @returns True if all transactions are valid, false otherwise
   */
  transactionsAreValid() {
    const errors = this.getTransactionsValidationErrors();
    return errors.length === 0;
  }
  /**
   * Validates the block data, throwing if invalid.
   * This can be checked on the Block itself without needing access to any parent block
   * It checks:
   * - All transactions are valid
   * - The transactions trie is valid
   * - The uncle hash is valid
   * @param onlyHeader if only passed the header, skip validating txTrie and unclesHash (default: false)
   * @param verifyTxs if set to `false`, will not check for transaction validation errors (default: true)
   */
  async validateData(onlyHeader = false, verifyTxs = true) {
    if (verifyTxs) {
      const txErrors = this.getTransactionsValidationErrors();
      if (txErrors.length > 0) {
        const msg = this._errorMsg(`invalid transactions: ${txErrors.join(" ")}`);
        throw new Error(msg);
      }
    }
    if (onlyHeader) {
      return;
    }
    if (verifyTxs) {
      for (const [index, tx] of this.transactions.entries()) {
        if (!tx.isSigned()) {
          const msg = this._errorMsg(`invalid transactions: transaction at index ${index} is unsigned`);
          throw new Error(msg);
        }
      }
    }
    if (!await this.transactionsTrieIsValid()) {
      const msg = this._errorMsg("invalid transaction trie");
      throw new Error(msg);
    }
    if (!this.uncleHashIsValid()) {
      const msg = this._errorMsg("invalid uncle hash");
      throw new Error(msg);
    }
    if (this.common.ethjsCommon.isActivatedEIP(4895) && !await this.withdrawalsTrieIsValid()) {
      const msg = this._errorMsg("invalid withdrawals trie");
      throw new Error(msg);
    }
    if (this.common.ethjsCommon.isActivatedEIP(6800)) {
      if (this.executionWitness === void 0) {
        throw new Error("Invalid block: missing executionWitness");
      }
      if (this.executionWitness === null) {
        throw new Error("Invalid block: ethereumjs stateless client needs executionWitness");
      }
    }
  }
  /**
   * Validates that blob gas fee for each transaction is greater than or equal to the
   * blobGasPrice for the block and that total blob gas in block is less than maximum
   * blob gas per block
   * @param parentHeader header of parent block
   */
  validateBlobTransactions(parentHeader) {
    if (this.common.ethjsCommon.isActivatedEIP(4844)) {
      const blobGasLimit = this.common.ethjsCommon.param("maxblobGasPerBlock");
      const blobGasPerBlob = this.common.ethjsCommon.param("blobGasPerBlob");
      let blobGasUsed = 0n;
      const expectedExcessBlobGas = parentHeader.calcNextExcessBlobGas();
      if (this.header.excessBlobGas !== expectedExcessBlobGas) {
        throw new Error(
          `block excessBlobGas mismatch: have ${this.header.excessBlobGas}, want ${expectedExcessBlobGas}`
        );
      }
      let blobGasPrice = this.header.getBlobGasPrice();
      for (const tx of this.transactions) {
        if (tx instanceof BlobEIP4844Transaction) {
          blobGasPrice = blobGasPrice ?? this.header.getBlobGasPrice();
          if (tx.maxFeePerBlobGas < blobGasPrice) {
            throw new Error(
              `blob transaction maxFeePerBlobGas ${tx.maxFeePerBlobGas} < than block blob gas price ${blobGasPrice} - ${this.errorStr()}`
            );
          }
          blobGasUsed += BigInt(tx.blobVersionedHashes.length) * blobGasPerBlob;
          if (blobGasUsed > blobGasLimit) {
            throw new Error(
              `tx causes total blob gas of ${blobGasUsed} to exceed maximum blob gas per block of ${blobGasLimit}`
            );
          }
        }
      }
      if (this.header.blobGasUsed !== blobGasUsed) {
        throw new Error(`block blobGasUsed mismatch: have ${this.header.blobGasUsed}, want ${blobGasUsed}`);
      }
    }
  }
  /**
   * Validates the uncle's hash.
   * @returns true if the uncle's hash is valid, false otherwise.
   */
  uncleHashIsValid() {
    if (this.uncleHeaders.length === 0) {
      return equalsBytes(KECCAK256_RLP_ARRAY, this.header.uncleHash);
    }
    const uncles = this.uncleHeaders.map((uh) => uh.raw());
    const raw = Rlp.encode(uncles);
    return equalsBytes(this.keccakFunction(raw), this.header.uncleHash);
  }
  /**
   * Validates the withdrawal root
   * @returns true if the withdrawals trie root is valid, false otherwise
   */
  async withdrawalsTrieIsValid() {
    if (!this.common.ethjsCommon.isActivatedEIP(4895)) {
      throw new Error("EIP 4895 is not activated");
    }
    let result;
    if (this.withdrawals?.length === 0) {
      result = equalsBytes(this.header.withdrawalsRoot, KECCAK256_RLP);
      return result;
    }
    if (this.cache.withdrawalsTrieRoot === void 0) {
      this.cache.withdrawalsTrieRoot = await _Block.genWithdrawalsTrieRoot(
        this.withdrawals ?? [],
        new Trie({ common: this.common.ethjsCommon })
      );
    }
    result = equalsBytes(this.cache.withdrawalsTrieRoot, this.header.withdrawalsRoot);
    return result;
  }
  /**
   * Consistency checks for uncles included in the block, if any.
   *
   * Throws if invalid.
   *
   * The rules for uncles checked are the following:
   * Header has at most 2 uncles.
   * Header does not count an uncle twice.
   */
  validateUncles() {
    if (this.isGenesis()) {
      return;
    }
    if (this.uncleHeaders.length > 2) {
      const msg = this._errorMsg("too many uncle headers");
      throw new Error(msg);
    }
    const uncleHashes = this.uncleHeaders.map((header) => bytesToHex(header.hash()));
    if (!(new Set(uncleHashes).size === uncleHashes.length)) {
      const msg = this._errorMsg("duplicate uncles");
      throw new Error(msg);
    }
  }
  /**
   * Returns the canonical difficulty for this block.
   *
   * @param parentBlock - the parent of this `Block`
   */
  ethashCanonicalDifficulty(parentBlock) {
    return this.header.ethashCanonicalDifficulty(parentBlock.header);
  }
  /**
   * Validates if the block gasLimit remains in the boundaries set by the protocol.
   * Throws if invalid
   *
   * @param parentBlock - the parent of this `Block`
   */
  validateGasLimit(parentBlock) {
    return this.header.validateGasLimit(parentBlock.header);
  }
  /**
   * Returns the block in JSON format.
   */
  toJSON() {
    const withdrawalsAttr = this.withdrawals ? {
      withdrawals: this.withdrawals.map((wt) => wt.toJSON())
    } : {};
    return {
      header: this.header.toJSON(),
      transactions: this.transactions.map((tx) => tx.toJSON()),
      uncleHeaders: this.uncleHeaders.map((uh) => uh.toJSON()),
      ...withdrawalsAttr,
      requests: this.requests?.map((req) => bytesToHex(req.serialize()))
    };
  }
  toExecutionPayload() {
    const blockJson = this.toJSON();
    const header = blockJson.header;
    const transactions = this.transactions.map((tx) => bytesToHex(tx.serialize())) ?? [];
    const withdrawalsArr = blockJson.withdrawals ? { withdrawals: blockJson.withdrawals } : {};
    const executionPayload = {
      blockNumber: header.number,
      parentHash: header.parentHash,
      feeRecipient: header.coinbase,
      stateRoot: header.stateRoot,
      receiptsRoot: header.receiptTrie,
      logsBloom: header.logsBloom,
      gasLimit: header.gasLimit,
      gasUsed: header.gasUsed,
      timestamp: header.timestamp,
      extraData: header.extraData,
      baseFeePerGas: header.baseFeePerGas,
      blobGasUsed: header.blobGasUsed,
      excessBlobGas: header.excessBlobGas,
      blockHash: bytesToHex(this.hash()),
      prevRandao: header.mixHash,
      transactions,
      ...withdrawalsArr,
      parentBeaconBlockRoot: header.parentBeaconBlockRoot,
      executionWitness: this.executionWitness
    };
    return executionPayload;
  }
  /**
   * Return a compact error string representation of the object
   */
  errorStr() {
    let hash = "";
    try {
      hash = bytesToHex(this.hash());
    } catch (_e) {
      hash = "error";
    }
    let hf = "";
    try {
      hf = this.common.ethjsCommon.hardfork();
    } catch (_e) {
      hf = "error";
    }
    let errorStr = `block number=${this.header.number} hash=${hash} `;
    errorStr += `hf=${hf} baseFeePerGas=${this.header.baseFeePerGas ?? "none"} `;
    errorStr += `txs=${this.transactions.length} uncles=${this.uncleHeaders.length}`;
    return errorStr;
  }
  /**
   * Internal helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
};

// src/header-from-rpc.ts
function blockHeaderFromRpc(blockParams, options) {
  const {
    parentHash,
    sha3Uncles,
    miner,
    stateRoot,
    transactionsRoot,
    receiptsRoot,
    logsBloom,
    difficulty,
    number,
    gasLimit,
    gasUsed,
    timestamp,
    extraData,
    mixHash,
    nonce,
    baseFeePerGas,
    withdrawalsRoot,
    blobGasUsed,
    excessBlobGas,
    parentBeaconBlockRoot,
    requestsRoot
  } = blockParams;
  const blockHeader = BlockHeader.fromHeaderData(
    {
      parentHash,
      uncleHash: sha3Uncles,
      coinbase: miner,
      stateRoot,
      transactionsTrie: transactionsRoot,
      receiptTrie: receiptsRoot,
      logsBloom,
      difficulty: numberToHex2(difficulty),
      number,
      gasLimit,
      gasUsed,
      timestamp,
      extraData,
      mixHash,
      nonce,
      baseFeePerGas,
      withdrawalsRoot,
      blobGasUsed,
      excessBlobGas,
      parentBeaconBlockRoot,
      requestsRoot
    },
    options
  );
  return blockHeader;
}

// src/from-rpc.ts
function normalizeTxParams(_txParams) {
  const txParams = Object.assign({}, _txParams);
  txParams.gasLimit = toType(txParams.gasLimit ?? txParams.gas, TypeOutput.BigInt);
  txParams.data = txParams.data === void 0 ? txParams.input : txParams.data;
  txParams.gasPrice = txParams.gasPrice !== void 0 ? BigInt(txParams.gasPrice) : void 0;
  txParams.value = txParams.value !== void 0 ? BigInt(txParams.value) : void 0;
  txParams.to = txParams.to !== null && txParams.to !== void 0 ? setLengthLeft(toBytes(txParams.to), 20) : null;
  txParams.v = toType(txParams.v, TypeOutput.BigInt);
  return txParams;
}
function blockFromRpc(blockParams, options, uncles = []) {
  const header = blockHeaderFromRpc(blockParams, options);
  const transactions = [];
  const opts = { common: header.common.ethjsCommon };
  for (const _txParams of blockParams.transactions ?? []) {
    const txParams = normalizeTxParams(_txParams);
    try {
      const tx = TransactionFactory(txParams, opts);
      transactions.push(tx);
    } catch (e) {
      if (e instanceof Error && e.message.includes("The chain ID does not match the chain ID of Common.")) {
        throw new MisconfiguredClientError(
          "Detected that forked blocks do not have same chain id as the tevm client. To fix this explicitly pass in a `common` property with correct chain id"
        );
      }
      if (e instanceof Error) {
        throw new InternalError(e.message, { cause: e });
      }
      throw new InternalError("Unexpected error", { cause: e });
    }
  }
  const uncleHeaders = uncles.map((uh) => blockHeaderFromRpc(uh, options));
  const requests = blockParams.requests?.map((req) => {
    const bytes = hexToBytes(req);
    return new ClRequest(bytes[0], bytes.slice(1));
  });
  return Block.fromBlockData(
    {
      header,
      transactions,
      uncleHeaders,
      withdrawals: blockParams.withdrawals,
      requests
    },
    options
  );
}

// src/index.ts
function createBlock(blockData, opts) {
  return Block.fromBlockData(blockData, opts);
}
function createBlockFromRLP(serialized, opts) {
  return Block.fromRLPSerializedBlock(serialized, opts);
}
function createBlockFromValuesArray(values, opts) {
  return Block.fromValuesArray(values, opts);
}
async function createBlockFromExecutionPayload(payload, opts) {
  return Block.fromExecutionPayload(payload, opts);
}
async function createBlockFromBeaconPayload(payload, opts) {
  return Block.fromBeaconPayloadJson(payload, opts);
}
function createBlockHeader(headerData, opts) {
  return BlockHeader.fromHeaderData(headerData, opts);
}
function createBlockHeaderFromRLP(serializedHeaderData, opts) {
  return BlockHeader.fromRLPSerializedHeader(serializedHeaderData, opts);
}
function createBlockHeaderFromValuesArray(values, opts) {
  return BlockHeader.fromValuesArray(values, opts);
}

export { Block, BlockHeader, ClRequest, blockFromRpc, createBlock, createBlockFromBeaconPayload, createBlockFromExecutionPayload, createBlockFromRLP, createBlockFromValuesArray, createBlockHeader, createBlockHeaderFromRLP, createBlockHeaderFromValuesArray, executionPayloadFromBeaconPayload, getDifficulty, valuesArrayToHeaderData };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map