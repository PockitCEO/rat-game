'use strict';

var blockchain = require('@tevm/blockchain');
var common = require('@tevm/common');
var evm = require('@tevm/evm');
var logger = require('@tevm/logger');
var precompiles = require('@tevm/precompiles');
var receiptManager = require('@tevm/receipt-manager');
var state = require('@tevm/state');
var txpool = require('@tevm/txpool');
var utils = require('@tevm/utils');
var vm = require('@tevm/vm');
var jsonrpc = require('@tevm/jsonrpc');

// src/createTevmNode.js

// src/DEFAULT_CHAIN_ID.js
var DEFAULT_CHAIN_ID = 900;
var prefundedAccounts = [
  "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
  "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
  "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
  "0x90F79bf6EB2c4f870365E785982E1f101E93b906",
  "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65",
  "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc",
  "0x976EA74026E726554dB657fA54763abd0C3a0aa9",
  "0x14dC79964da2C08b23698B3D3cc7Ca32193d9955",
  "0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f",
  "0xa0Ee7A142d267C1f36714E4a8F75612F20a79720"
];
var INITIAL_ACCOUNTS = [`0x${"00".repeat(20)}`, ...prefundedAccounts];
var INITIAL_BALANCE = utils.parseEther("1000");
var multicall3Contract = {
  nonce: 0n,
  balance: 0n,
  storageRoot: "0x",
  deployedBytecode: "0x6080604052600436106100f35760003560e01c80634d2301cc1161008a578063a8b0574e11610059578063a8b0574e1461025a578063bce38bd714610275578063c3077fa914610288578063ee82ac5e1461029b57600080fd5b80634d2301cc146101ec57806372425d9d1461022157806382ad56cb1461023457806386d516e81461024757600080fd5b80633408e470116100c65780633408e47014610191578063399542e9146101a45780633e64a696146101c657806342cbb15c146101d957600080fd5b80630f28c97d146100f8578063174dea711461011a578063252dba421461013a57806327e86d6e1461015b575b600080fd5b34801561010457600080fd5b50425b6040519081526020015b60405180910390f35b61012d610128366004610a85565b6102ba565b6040516101119190610bbe565b61014d610148366004610a85565b6104ef565b604051610111929190610bd8565b34801561016757600080fd5b50437fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0140610107565b34801561019d57600080fd5b5046610107565b6101b76101b2366004610c60565b610690565b60405161011193929190610cba565b3480156101d257600080fd5b5048610107565b3480156101e557600080fd5b5043610107565b3480156101f857600080fd5b50610107610207366004610ce2565b73ffffffffffffffffffffffffffffffffffffffff163190565b34801561022d57600080fd5b5044610107565b61012d610242366004610a85565b6106ab565b34801561025357600080fd5b5045610107565b34801561026657600080fd5b50604051418152602001610111565b61012d610283366004610c60565b61085a565b6101b7610296366004610a85565b610a1a565b3480156102a757600080fd5b506101076102b6366004610d18565b4090565b60606000828067ffffffffffffffff8111156102d8576102d8610d31565b60405190808252806020026020018201604052801561031e57816020015b6040805180820190915260008152606060208201528152602001906001900390816102f65790505b5092503660005b8281101561047757600085828151811061034157610341610d60565b6020026020010151905087878381811061035d5761035d610d60565b905060200281019061036f9190610d8f565b6040810135958601959093506103886020850185610ce2565b73ffffffffffffffffffffffffffffffffffffffff16816103ac6060870187610dcd565b6040516103ba929190610e32565b60006040518083038185875af1925050503d80600081146103f7576040519150601f19603f3d011682016040523d82523d6000602084013e6103fc565b606091505b50602080850191909152901515808452908501351761046d577f08c379a000000000000000000000000000000000000000000000000000000000600052602060045260176024527f4d756c746963616c6c333a2063616c6c206661696c656400000000000000000060445260846000fd5b5050600101610325565b508234146104e6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f4d756c746963616c6c333a2076616c7565206d69736d6174636800000000000060448201526064015b60405180910390fd5b50505092915050565b436060828067ffffffffffffffff81111561050c5761050c610d31565b60405190808252806020026020018201604052801561053f57816020015b606081526020019060019003908161052a5790505b5091503660005b8281101561068657600087878381811061056257610562610d60565b90506020028101906105749190610e42565b92506105836020840184610ce2565b73ffffffffffffffffffffffffffffffffffffffff166105a66020850185610dcd565b6040516105b4929190610e32565b6000604051808303816000865af19150503d80600081146105f1576040519150601f19603f3d011682016040523d82523d6000602084013e6105f6565b606091505b5086848151811061060957610609610d60565b602090810291909101015290508061067d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4d756c746963616c6c333a2063616c6c206661696c656400000000000000000060448201526064016104dd565b50600101610546565b5050509250929050565b43804060606106a086868661085a565b905093509350939050565b6060818067ffffffffffffffff8111156106c7576106c7610d31565b60405190808252806020026020018201604052801561070d57816020015b6040805180820190915260008152606060208201528152602001906001900390816106e55790505b5091503660005b828110156104e657600084828151811061073057610730610d60565b6020026020010151905086868381811061074c5761074c610d60565b905060200281019061075e9190610e76565b925061076d6020840184610ce2565b73ffffffffffffffffffffffffffffffffffffffff166107906040850185610dcd565b60405161079e929190610e32565b6000604051808303816000865af19150503d80600081146107db576040519150601f19603f3d011682016040523d82523d6000602084013e6107e0565b606091505b506020808401919091529015158083529084013517610851577f08c379a000000000000000000000000000000000000000000000000000000000600052602060045260176024527f4d756c746963616c6c333a2063616c6c206661696c656400000000000000000060445260646000fd5b50600101610714565b6060818067ffffffffffffffff81111561087657610876610d31565b6040519080825280602002602001820160405280156108bc57816020015b6040805180820190915260008152606060208201528152602001906001900390816108945790505b5091503660005b82811015610a105760008482815181106108df576108df610d60565b602002602001015190508686838181106108fb576108fb610d60565b905060200281019061090d9190610e42565b925061091c6020840184610ce2565b73ffffffffffffffffffffffffffffffffffffffff1661093f6020850185610dcd565b60405161094d929190610e32565b6000604051808303816000865af19150503d806000811461098a576040519150601f19603f3d011682016040523d82523d6000602084013e61098f565b606091505b506020830152151581528715610a07578051610a07576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4d756c746963616c6c333a2063616c6c206661696c656400000000000000000060448201526064016104dd565b506001016108c3565b5050509392505050565b6000806060610a2b60018686610690565b919790965090945092505050565b60008083601f840112610a4b57600080fd5b50813567ffffffffffffffff811115610a6357600080fd5b6020830191508360208260051b8501011115610a7e57600080fd5b9250929050565b60008060208385031215610a9857600080fd5b823567ffffffffffffffff811115610aaf57600080fd5b610abb85828601610a39565b90969095509350505050565b6000815180845260005b81811015610aed57602081850181015186830182015201610ad1565b81811115610aff576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b600082825180855260208086019550808260051b84010181860160005b84811015610bb1578583037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001895281518051151584528401516040858501819052610b9d81860183610ac7565b9a86019a9450505090830190600101610b4f565b5090979650505050505050565b602081526000610bd16020830184610b32565b9392505050565b600060408201848352602060408185015281855180845260608601915060608160051b870101935082870160005b82811015610c52577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0888703018452610c40868351610ac7565b95509284019290840190600101610c06565b509398975050505050505050565b600080600060408486031215610c7557600080fd5b83358015158114610c8557600080fd5b9250602084013567ffffffffffffffff811115610ca157600080fd5b610cad86828701610a39565b9497909650939450505050565b838152826020820152606060408201526000610cd96060830184610b32565b95945050505050565b600060208284031215610cf457600080fd5b813573ffffffffffffffffffffffffffffffffffffffff81168114610bd157600080fd5b600060208284031215610d2a57600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81833603018112610dc357600080fd5b9190910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112610e0257600080fd5b83018035915067ffffffffffffffff821115610e1d57600080fd5b602001915036819003821315610a7e57600080fd5b8183823760009101908152919050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1833603018112610dc357600080fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1833603018112610dc357600080fdfea2646970667358221220bb2b5c71a328032f97c676ae39a1ec2148d3e5d6f73d95e9b17910152d61f16264736f6c634300080c0033"
};
var GENESIS_STATE = Object.fromEntries(
  INITIAL_ACCOUNTS.map((address) => [
    address,
    {
      nonce: 0n,
      balance: INITIAL_BALANCE,
      storageRoot: "0x",
      codeHash: "0x"
    },
    multicall3Contract
  ])
);
var getBlockNumber = async (client) => {
  const transport = typeof client === "function" ? client({}) : client;
  const fetcher = jsonrpc.createJsonRpcFetcher(transport);
  const { result: blockNumber, error } = await fetcher.request({
    jsonrpc: "2.0",
    method: "eth_blockNumber",
    id: 1,
    params: []
  });
  if (error || blockNumber === void 0) {
    throw error;
  }
  return utils.hexToBigInt(
    /** @type {import("@tevm/utils").Hex}*/
    blockNumber
  );
};
var getChainId = async (client) => {
  const transport = typeof client === "function" ? client({}) : client;
  const fetcher = jsonrpc.createJsonRpcFetcher(transport);
  const { result: chainId, error } = await fetcher.request({
    jsonrpc: "2.0",
    method: "eth_chainId",
    id: 1,
    params: []
  });
  if (error || chainId === void 0) {
    throw error;
  }
  return utils.hexToNumber(
    /** @type {import("@tevm/utils").Hex}*/
    chainId
  );
};
var statePersister = (persister, logger) => (stateManager) => {
  logger.debug("persisting state manager...");
  state.dumpCanonicalGenesis(stateManager)().then((state) => {
    const parsedState = {};
    for (const [k, v] of Object.entries(state)) {
      const { nonce, balance, storageRoot, codeHash } = v;
      parsedState[k] = {
        ...v,
        nonce: utils.toHex(nonce),
        balance: utils.toHex(balance),
        storageRoot,
        codeHash
      };
    }
    persister.persistTevmState(parsedState);
  }).catch((error) => {
    logger.error("Failed to persist state:", error);
  });
};

// src/createTevmNode.js
var createTevmNode = (options = {}) => {
  const transport = (() => {
    if (typeof options?.fork?.transport === "function") {
      return options.fork.transport({});
    }
    return options.fork?.transport;
  })();
  let impersonatedAccount;
  const setImpersonatedAccount = (address) => {
    impersonatedAccount = address;
  };
  const loggingLevel = options.loggingLevel ?? "warn";
  const logger$1 = logger.createLogger({
    name: "TevmClient",
    level: loggingLevel
  });
  const getStateManagerOpts = async () => {
    if (transport) {
      const blockTag = await blockTagPromise;
      return {
        loggingLevel,
        ...options.persister ? { onCommit: statePersister(options.persister, logger$1) } : {},
        fork: {
          ...options.fork,
          transport,
          blockTag
        }
      };
    }
    return {
      loggingLevel,
      ...options.storageCache !== void 0 ? { storageCache: options.storageCache } : {},
      ...options.contractCache !== void 0 ? { contractCache: options.contractCache } : {},
      ...options.accountsCache !== void 0 ? { accountsCache: options.accountsCache } : {},
      ...options.fork?.transport ? { ...options.fork, transport } : {},
      ...options.persister !== void 0 ? { onCommit: statePersister(options.persister, logger$1) } : {}
    };
  };
  const extend = (client) => (extension) => {
    Object.assign(client, extension(client));
    return (
      /** @type {any}*/
      client
    );
  };
  const chainIdPromise = (async () => {
    if (options?.common) {
      return options?.common.id;
    }
    if (transport) {
      const id = await getChainId(transport);
      return id;
    }
    return DEFAULT_CHAIN_ID;
  })().then((chainId) => {
    logger$1.debug({ chainId }, "Creating client with chainId");
    return BigInt(chainId);
  });
  const blockTagPromise = (async () => {
    if (options.fork === void 0) {
      return 0n;
    }
    if (options.fork.blockTag === void 0 || options.fork.blockTag === "latest") {
      const latestBlockNumber = await getBlockNumber(options.fork.transport);
      logger$1.debug({ latestBlockNumber }, "fetched fork block number from provided forkurl");
      return latestBlockNumber;
    }
    return options.fork.blockTag;
  })();
  const chainCommonPromise = chainIdPromise.then((chainId) => {
    if (options.common) {
      return common.createCommon({
        ...options.common,
        id: Number(chainId),
        loggingLevel: options.loggingLevel ?? "warn",
        hardfork: (
          /** @type {import('@tevm/common').Hardfork}*/
          options.common.ethjsCommon.hardfork() ?? "prague"
        ),
        eips: options.common.ethjsCommon.eips(),
        customCrypto: options.common.ethjsCommon.customCrypto
      });
    }
    return common.createCommon({
      ...common.tevmDefault,
      id: Number(chainId),
      loggingLevel: options.loggingLevel ?? "warn",
      hardfork: "prague",
      eips: []
    });
  }).then((common) => {
    const copy = common.copy();
    return copy;
  });
  const blockchainPromise = Promise.all([chainCommonPromise, blockTagPromise]).then(([common, blockTag]) => {
    return blockchain.createChain({
      loggingLevel,
      common,
      ...options.fork?.transport !== void 0 ? {
        fork: {
          transport: {
            request: typeof options.fork.transport === "function" ? options.fork.transport({}).request : options.fork.transport.request
          },
          blockTag
        }
      } : {}
    });
  });
  const stateManagerPromise = blockchainPromise.then(async (blockchain) => {
    await blockchain.ready();
    return blockchain;
  }).then((chain) => chain.getCanonicalHeadBlock()).then(async (headBlock) => {
    const stateRootHex = utils.bytesToHex(headBlock.header.stateRoot);
    const restoredState = options.persister?.restoreState();
    if (restoredState) {
      logger$1.debug(restoredState, "Restoring persisted state...");
      logger$1.warn(
        "State persistence is an experimental feature. It currently does not persist the blockchain state only the EVM state."
      );
      const parsedState = {};
      for (const [k, v] of Object.entries(restoredState)) {
        const { nonce, balance, storageRoot, codeHash } = v;
        parsedState[
          /** @type {import('@tevm/utils').Address}*/
          k
        ] = {
          ...v,
          nonce: utils.hexToBigInt(nonce),
          balance: utils.hexToBigInt(balance),
          storageRoot,
          codeHash
        };
      }
      const manager = state.createStateManager({
        genesisState: parsedState,
        currentStateRoot: utils.bytesToHex(headBlock.header.stateRoot),
        stateRoots: /* @__PURE__ */ new Map([[stateRootHex, parsedState]]),
        ...await getStateManagerOpts()
      });
      await manager.ready();
      return manager;
    }
    const genesisState = {
      ...GENESIS_STATE,
      // add predeploys to genesis state
      ...Object.fromEntries(
        (options.customPredeploys ?? []).map((predeploy) => [
          predeploy.contract.address,
          {
            nonce: 0n,
            deployedBytecode: predeploy.contract.deployedBytecode,
            // TODO this is definitely wrong but should work
            storageRoot: utils.bytesToHex(utils.KECCAK256_RLP),
            codeHash: utils.keccak256(predeploy.contract.deployedBytecode)
          }
        ])
      )
    };
    const opts = await getStateManagerOpts();
    return state.createStateManager({
      ...opts,
      currentStateRoot: stateRootHex,
      stateRoots: /* @__PURE__ */ new Map([[utils.bytesToHex(headBlock.header.stateRoot), genesisState]]),
      genesisState
    });
  });
  const evmPromise = Promise.all([chainCommonPromise, stateManagerPromise, blockchainPromise]).then(
    ([common, stateManager, blockchain]) => {
      return evm.createEvm({
        common,
        stateManager,
        blockchain,
        allowUnlimitedContractSize: options.allowUnlimitedContractSize ?? false,
        customPrecompiles: [
          ...[precompiles.p256VerifyPrecompile()].filter(
            (p) => !new Set((options.customPrecompiles ?? []).map((p2) => p2.address.toString())).has(p.address.toString())
          ),
          ...options.customPrecompiles ?? []
        ],
        profiler: options.profiler ?? false,
        loggingLevel
      });
    }
  );
  const vmPromise = Promise.all([evmPromise, chainCommonPromise]).then(([evm, common]) => {
    const vm$1 = vm.createVm({
      stateManager: evm.stateManager,
      evm,
      // TODO this inherited type is wrong thus we need to cast this
      blockchain: (
        /** @type {import('@tevm/blockchain').Chain} */
        evm.blockchain
      ),
      common
    });
    return vm$1;
  });
  const txPoolPromise = vmPromise.then((vm) => new txpool.TxPool({ vm }));
  const receiptManagerPromise = vmPromise.then((vm) => {
    logger$1.debug("initializing receipts manager...");
    return new receiptManager.ReceiptsManager(receiptManager.createMapDb({ cache: /* @__PURE__ */ new Map() }), vm.blockchain);
  });
  const filters = /* @__PURE__ */ new Map();
  const createEventEmitter = () => {
    const events = /* @__PURE__ */ new Map();
    const eventEmitter2 = {
      on(eventName, listener) {
        const listeners = events.get(eventName) || [];
        listeners.push(listener);
        events.set(eventName, listeners);
      },
      removeListener(eventName, listener) {
        const listeners = events.get(eventName);
        if (listeners) {
          const index = listeners.indexOf(listener);
          if (index !== -1) {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              events.delete(eventName);
            }
          }
        }
      },
      emit(eventName, ...args) {
        const listeners = events.get(eventName);
        if (listeners?.length) {
          listeners.forEach((listener) => {
            listener(...args);
          });
          return true;
        }
        return false;
      }
    };
    return eventEmitter2;
  };
  const eventEmitter = createEventEmitter();
  const readyPromise = (async () => {
    await blockchainPromise.then((b) => b.ready());
    await stateManagerPromise.then((b) => b.ready());
    await vmPromise.then((vm) => vm.ready());
    eventEmitter.emit("connect");
    return (
      /** @type {true}*/
      true
    );
  })();
  const deepCopy = (baseClient2) => async () => {
    let impersonatedAccount2;
    const setImpersonatedAccount2 = (address) => {
      impersonatedAccount2 = address && utils.getAddress(address);
    };
    await readyPromise;
    const oldVm = await vmPromise;
    const vm = await oldVm.deepCopy();
    const oldReceiptsManager = await receiptManagerPromise;
    const receiptsManager = oldReceiptsManager.deepCopy(vm.blockchain);
    const oldTxPool = await txPoolPromise;
    const txPool = oldTxPool.deepCopy({ vm });
    const newFilters = new Map(filters);
    const eventEmitter2 = createEventEmitter();
    const copiedClient = {
      ...eventEmitter2,
      logger: baseClient2.logger,
      getReceiptsManager: async () => Promise.resolve(receiptsManager),
      getTxPool: async () => Promise.resolve(txPool),
      getVm: async () => Promise.resolve(vm),
      miningConfig: baseClient2.miningConfig,
      mode: baseClient2.mode,
      ..."forkTransport" in baseClient2 ? {
        forkTransport: {
          request: baseClient2.forkTransport.request
        }
      } : {},
      extend: (extension) => extend(baseClient2)(extension),
      deepCopy: () => deepCopy(copiedClient)(),
      ready: () => Promise.resolve(true),
      getFilters: () => newFilters,
      getImpersonatedAccount() {
        return impersonatedAccount2;
      },
      setImpersonatedAccount: setImpersonatedAccount2,
      setFilter: (filter) => {
        newFilters.set(filter.id, filter);
      },
      removeFilter: (filterId) => {
        newFilters.delete(filterId);
      },
      status: "READY"
    };
    return copiedClient;
  };
  const baseClient = {
    ...eventEmitter,
    logger: logger$1,
    getReceiptsManager: async () => {
      await readyPromise;
      return receiptManagerPromise;
    },
    getTxPool: async () => {
      await readyPromise;
      return txPoolPromise;
    },
    getVm: async () => {
      await readyPromise;
      return vmPromise;
    },
    miningConfig: options.miningConfig ?? { type: "manual" },
    mode: transport ? "fork" : "normal",
    ...transport ? {
      forkTransport: transport
    } : {},
    extend: (extension) => extend(baseClient)(extension),
    ready: () => readyPromise,
    getImpersonatedAccount() {
      return impersonatedAccount;
    },
    setImpersonatedAccount,
    getFilters: () => filters,
    setFilter: (filter) => {
      filters.set(filter.id, filter);
    },
    removeFilter: (filterId) => {
      filters.delete(filterId);
    },
    status: "INITIALIZING",
    deepCopy: () => deepCopy(baseClient)(),
    debug: async () => {
      const txPool = await txPoolPromise;
      const vm = await vmPromise;
      const receiptManager = await receiptManagerPromise;
      return {
        chainName: vm.common.name,
        status: baseClient.status,
        mode: baseClient.mode,
        miningConfig: baseClient.miningConfig,
        registeredFilters: baseClient.getFilters(),
        blocks: {
          latest: vm.blockchain.blocksByTag.get("latest")?.header.toJSON(),
          forked: vm.blockchain.blocksByTag.get("forked")?.header.toJSON()
        },
        txsInMempool: txPool.txsInPool,
        state: await vm.stateManager.dumpCanonicalGenesis(),
        hardfork: vm.common.ethjsCommon.hardfork(),
        eips: vm.common.ethjsCommon.eips(),
        chainId: vm.common.id,
        receipts: await receiptManager.getLogs(
          /** @type {import('@tevm/block').Block}*/
          vm.blockchain.blocksByTag.get("forked") ?? vm.blockchain.blocksByNumber.get(0n),
          /** @type {import('@tevm/block').Block}*/
          vm.blockchain.blocksByTag.get("latest")
        )
      };
    }
  };
  eventEmitter.on("connect", () => {
    if (baseClient.status !== "INITIALIZING") {
      return;
    }
    baseClient.status = "READY";
  });
  return baseClient;
};

// src/EIP1193EventEmitterTypes.ts
var ProviderRpcError = class extends Error {
  code;
  details;
  constructor(code, message) {
    super(message);
    this.code = code;
    this.details = message;
  }
};

exports.GENESIS_STATE = GENESIS_STATE;
exports.ProviderRpcError = ProviderRpcError;
exports.createTevmNode = createTevmNode;
exports.prefundedAccounts = prefundedAccounts;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map