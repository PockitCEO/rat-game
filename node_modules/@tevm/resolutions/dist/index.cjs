'use strict';

var Effect = require('effect/Effect');
var path = require('path');
var resolve = require('resolve');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var resolve__default = /*#__PURE__*/_interopDefault(resolve);

// src/moduleFactory.js

// src/utils/formatPath.js
var formatPath = (contractPath) => {
  return contractPath.replace(/\\/g, "/");
};

// src/utils/isImportLocal.js
var isImportLocal = (importPath) => {
  return importPath.startsWith(".") || importPath.startsWith("..");
};

// src/utils/resolveImportPath.js
var CouldNotResolveImportError = class extends Error {
  /**
   * @type {'CouldNotResolveImportError'}
   */
  _tag = "CouldNotResolveImportError";
  /**
   * @type {'CouldNotResolveImportError'}
   * @override
   */
  name = "CouldNotResolveImportError";
  /**
   * @param {string} importPath
   * @param {string} absolutePath
   * @param {Error} cause
   */
  constructor(importPath, absolutePath, cause) {
    super(`Could not resolve import ${importPath} from ${absolutePath}. Please check your remappings and libraries.`, {
      cause
    });
  }
};
var resolveImportPath = (absolutePath, importPath, remappings, libs, sync) => {
  for (const [key, value] of Object.entries(remappings)) {
    if (importPath.startsWith(key)) {
      return Effect.succeed(formatPath(path.resolve(importPath.replace(key, value))));
    }
  }
  if (isImportLocal(importPath)) {
    return Effect.succeed(formatPath(path.resolve(path.dirname(absolutePath), importPath)));
  }
  if (sync) {
    return Effect.try({
      try: () => resolve__default.default.sync(importPath, {
        basedir: path.dirname(absolutePath),
        paths: libs
      }),
      catch: (e) => new CouldNotResolveImportError(
        importPath,
        absolutePath,
        /** @type {Error}*/
        e
      )
    });
  }
  return Effect.async((resume) => {
    resolve__default.default(
      importPath,
      {
        basedir: path.dirname(absolutePath),
        paths: libs
      },
      (err, resolvedPath) => {
        if (err) {
          resume(Effect.fail(new CouldNotResolveImportError(importPath, absolutePath, err)));
        } else {
          resume(Effect.succeed(formatPath(
            /** @type {string} */
            resolvedPath
          )));
        }
      }
    );
  });
};

// src/resolveImports.js
var ImportDoesNotExistError = class extends Error {
  /**
   * @type {'ImportDoesNotExistError'}
   */
  _tag = "ImportDoesNotExistError";
  /**
   * @type {'ImportDoesNotExistError'}
   * @override
   */
  name = "ImportDoesNotExistError";
  constructor() {
    super("Import does not exist");
  }
};
var resolveImports = (absolutePath, code, remappings, libs, sync) => {
  const importRegEx = /^\s?import\s+[^'"]*['"](.*)['"]\s*/gm;
  if (typeof absolutePath !== "string") {
    return Effect.die(`Type ${typeof absolutePath} is not of type string`);
  }
  if (typeof code !== "string") {
    return Effect.die(`Type ${typeof code} is not of type string`);
  }
  if (typeof sync !== "boolean") {
    return Effect.die(`Type ${typeof sync} is not of type boolean`);
  }
  const allImports = (
    /** @type Array<import("effect/Effect").Effect<import("./types.js").ResolvedImport, import("./utils/resolveImportPath.js").CouldNotResolveImportError, >> */
    []
  );
  let foundImport = importRegEx.exec(code);
  while (foundImport != null) {
    const importPath = foundImport[1];
    if (!importPath) {
      return Effect.fail(new ImportDoesNotExistError());
    }
    allImports.push(
      resolveImportPath(absolutePath, importPath, remappings, libs, sync).pipe(
        Effect.map((absolute) => ({
          updated: absolute,
          absolute,
          original: importPath
        }))
      )
    );
    foundImport = importRegEx.exec(code);
  }
  return Effect.all(allImports);
};

// src/utils/invariant.js
var InvariantError = class extends Error {
  /**
   * @param {string} message - The message to display
   */
  constructor(message) {
    super(message);
    this.name = "InvariantError";
  }
};
function invariant(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
var ReadFileError = class extends Error {
  /**
   * @type {'ReadFileError'}
   */
  _tag = "ReadFileError";
  /**
   * @type {'ReadFileError'}
   * @override
   */
  name = "ReadFileError";
  /**
   * @param {Error} cause
   */
  constructor(cause) {
    super(`Read file error: ${cause.message}`, { cause });
  }
};
var ExistsError = class extends Error {
  /**
   * @type {'ExistsError'}
   */
  _tag = "ExistsError";
  /**
   * @type {'ExistsError'}
   * @override
   */
  name = "ExistsError";
  /**
   * @param {Error} cause
   */
  constructor(cause) {
    super(`Unable to determine existence: ${cause.message}`, { cause });
  }
};
var safeFao = (fao) => {
  return {
    /**
     * @param {string} path
     * @param {BufferEncoding} encoding
     */
    readFile: (path, encoding) => {
      return Effect.tryPromise({
        try: () => {
          return fao.readFile(path, encoding);
        },
        catch: (e) => {
          return new ReadFileError(
            /** @type Error */
            e
          );
        }
      });
    },
    /**
     * @param {string} path
     * @param {BufferEncoding} encoding
     */
    readFileSync: (path, encoding) => {
      return Effect.try({
        try: () => {
          return fao.readFileSync(path, encoding);
        },
        catch: (e) => {
          return new ReadFileError(
            /** @type Error */
            e
          );
        }
      });
    },
    /**
     * @param {string} path
     */
    exists: (path) => {
      return Effect.tryPromise({
        try: () => {
          return fao.exists(path);
        },
        catch: (e) => {
          return new ExistsError(
            /** @type Error */
            e
          );
        }
      });
    },
    /**
     * @param {string} path
     */
    existsSync: (path) => {
      return Effect.try({
        try: () => {
          return fao.existsSync(path);
        },
        catch: (e) => {
          return new ExistsError(
            /** @type Error */
            e
          );
        }
      });
    }
  };
};
var updateImportPaths = (code, resolvedImports) => {
  const solidityImportRegex = /(^\s?import\s+[^'"]*['"])(.*)(['"]\s*)/gm;
  return Effect.succeed(
    code.replaceAll(solidityImportRegex, (match, p1, p2, p3) => {
      const resolvedImport = resolvedImports.find(({ original }) => original === p2);
      if (resolvedImport) {
        return `${p1}${resolvedImport.updated}${p3}`;
      }
      return match;
    })
  );
};
var NoPragmaFoundError = class extends Error {
  /**
   * @type {'NoPragmaFoundError'}
   */
  _tag = "NoPragmaFoundError";
  /**
   * @type {'NoPragmaFoundError'}
   * @override
   */
  name = "NoPragmaFoundError";
};
var pragmaPattern = /pragma\s+solidity\s+((\^|~|>|>=|<|<=)?\s*(\d+\.\d+\.\d+)\s*);/;
var pragmaPatternWithBounds = /pragma\s+solidity\s+(>=?\d+\.\d+\.\d+)\s*<\s*(\d+\.\d+\.\d+)\s*;/;
var updatePragma = (solidityCode, version) => {
  let match = solidityCode.match(pragmaPattern);
  if (match == null ? void 0 : match[3]) {
    const versionToUse = match[3];
    const newPragma = `pragma solidity >=${versionToUse};`;
    return Effect.succeed(solidityCode.replace(pragmaPattern, newPragma));
  }
  match = solidityCode.match(pragmaPatternWithBounds);
  if (match == null ? void 0 : match[1]) {
    const versionToUse = match[1];
    const newPragma = `pragma solidity ${versionToUse};`;
    return Effect.succeed(solidityCode.replace(pragmaPatternWithBounds, newPragma));
  }
  return Effect.fail(new NoPragmaFoundError("No valid pragma statement found."));
};

// src/moduleFactory.js
var moduleFactory = (absolutePath, rawCode, remappings, libs, fao, sync) => {
  return Effect.gen(function* (_) {
    const readFile = sync ? safeFao(fao).readFileSync : safeFao(fao).readFile;
    const stack = [{ absolutePath, rawCode }];
    const modules = (
      /** @type{Map<string, import("./types.js").ModuleInfo>} */
      /* @__PURE__ */ new Map()
    );
    while (stack.length) {
      const nextItem = stack.pop();
      invariant(nextItem, "Module should exist");
      const { absolutePath: absolutePath2, rawCode: rawCode2 } = nextItem;
      if (modules.has(absolutePath2)) continue;
      const resolvedImports = yield* _(resolveImports(absolutePath2, rawCode2, remappings, libs, sync));
      modules.set(absolutePath2, {
        id: absolutePath2,
        rawCode: rawCode2,
        importedIds: resolvedImports.map(({ absolute }) => absolute),
        code: yield* _(updatePragma(yield* _(updateImportPaths(rawCode2, resolvedImports))))
      });
      for (const resolvedImport of resolvedImports) {
        const depRawCode = yield* _(readFile(resolvedImport.absolute, "utf8"));
        stack.push({
          absolutePath: resolvedImport.absolute,
          rawCode: depRawCode
        });
      }
    }
    return modules;
  });
};

exports.moduleFactory = moduleFactory;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map