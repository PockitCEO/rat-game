{"version":3,"sources":["../src/utils/formatPath.js","../src/utils/isImportLocal.js","../src/utils/resolveImportPath.js","../src/resolveImports.js","../src/utils/invariant.js","../src/utils/safeFao.js","../src/utils/updateImportPath.js","../src/utils/updatePragma.js","../src/moduleFactory.js"],"names":["succeed","pathResolve","dirname","trySync","resolve","effectAsync","fail","die","map","all","tryPromise","gen","absolutePath","rawCode"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Formats a path to be used in the contract loader\n * @param {string} contractPath - The path to the contract\n * @returns {string} - The formatted path\n * @example\n * ```ts\n * const pathToSolidity = path.join(__dirname, '../Contract.sol')\n * const formattedPath = formatPath(pathToSolidity)\n * console.log(formattedPath) // '/path/to/Contract.sol'\n * ```\n */\nexport const formatPath = (contractPath) => {\n\treturn contractPath.replace(/\\\\/g, '/')\n}\n","/**\n * Check if import path is local\n * @param {string} importPath\n * @returns {boolean}\n * @example\n * ```ts\n * const isLocal = isImportLocal('../Contract.sol')\n * console.log(isLocal) // true\n * ```\n */\nexport const isImportLocal = (importPath) => {\n\treturn importPath.startsWith('.') || importPath.startsWith('..')\n}\n","import { dirname, resolve as pathResolve } from 'node:path'\nimport { async as effectAsync, fail, succeed, try as trySync } from 'effect/Effect'\nimport resolve from 'resolve'\nimport { formatPath } from './formatPath.js'\nimport { isImportLocal } from './isImportLocal.js'\n\nexport class CouldNotResolveImportError extends Error {\n\t/**\n\t * @type {'CouldNotResolveImportError'}\n\t */\n\t_tag = 'CouldNotResolveImportError'\n\t/**\n\t * @type {'CouldNotResolveImportError'}\n\t * @override\n\t */\n\tname = 'CouldNotResolveImportError'\n\t/**\n\t * @param {string} importPath\n\t * @param {string} absolutePath\n\t * @param {Error} cause\n\t */\n\tconstructor(importPath, absolutePath, cause) {\n\t\tsuper(`Could not resolve import ${importPath} from ${absolutePath}. Please check your remappings and libraries.`, {\n\t\t\tcause,\n\t\t})\n\t}\n}\n\n/**\n * Resolve import statement to absolute file path\n *\n * @param {string} importPath import statement in *.sol contract\n * @param {string} absolutePath absolute path to the contract\n * @param {Record<string, string>} remappings remappings from the config\n * @param {ReadonlyArray<string>} libs libs from the config\n * @param {boolean} sync Whether to run this synchronously or not\n * @returns {import(\"effect/Effect\").Effect<string, CouldNotResolveImportError,never>} absolute path to the imported file\n * @example\n * ```ts\n * const pathToSolidity = path.join(__dirname, '../Contract.sol')\n * ```\n */\nexport const resolveImportPath = (absolutePath, importPath, remappings, libs, sync) => {\n\t// Remappings\n\tfor (const [key, value] of Object.entries(remappings)) {\n\t\tif (importPath.startsWith(key)) {\n\t\t\treturn succeed(formatPath(pathResolve(importPath.replace(key, value))))\n\t\t}\n\t}\n\t// Local import \"./LocalContract.sol\"\n\tif (isImportLocal(importPath)) {\n\t\treturn succeed(formatPath(pathResolve(dirname(absolutePath), importPath)))\n\t}\n\t// try resolving with node resolution\n\tif (sync) {\n\t\treturn trySync({\n\t\t\ttry: () =>\n\t\t\t\tresolve.sync(importPath, {\n\t\t\t\t\tbasedir: dirname(absolutePath),\n\t\t\t\t\tpaths: libs,\n\t\t\t\t}),\n\t\t\tcatch: (e) => new CouldNotResolveImportError(importPath, absolutePath, /** @type {Error}*/ (e)),\n\t\t})\n\t}\n\treturn effectAsync((resume) => {\n\t\tresolve(\n\t\t\timportPath,\n\t\t\t{\n\t\t\t\tbasedir: dirname(absolutePath),\n\t\t\t\tpaths: libs,\n\t\t\t},\n\t\t\t(err, resolvedPath) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tresume(fail(new CouldNotResolveImportError(importPath, absolutePath, err)))\n\t\t\t\t} else {\n\t\t\t\t\tresume(succeed(formatPath(/** @type {string} */ (resolvedPath))))\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t})\n}\n","import { all, die, fail, map } from 'effect/Effect'\nimport { resolveImportPath } from './utils/resolveImportPath.js'\n\nclass ImportDoesNotExistError extends Error {\n\t/**\n\t * @type {'ImportDoesNotExistError'}\n\t */\n\t_tag = 'ImportDoesNotExistError'\n\t/**\n\t * @type {'ImportDoesNotExistError'}\n\t * @override\n\t */\n\tname = 'ImportDoesNotExistError'\n\tconstructor() {\n\t\tsuper('Import does not exist')\n\t}\n}\n\n/**\n * @typedef {ImportDoesNotExistError | import(\"./utils/resolveImportPath.js\").CouldNotResolveImportError} ResolveImportsError\n */\n\n/**\n * Returns a the import resolutions for the given code\n * @param {string} absolutePath\n * @param {string} code\n * @param {Record<string, string>} remappings\n * @param {ReadonlyArray<string>} libs\n * @param {boolean} sync\n *\n * @returns {import(\"effect/Effect\").Effect<ReadonlyArray<import(\"./types.js\").ResolvedImport>, ResolveImportsError, never>}\n * @example\n * ```ts\n * const pathToSolidity = path.join(__dirname, '../Contract.sol')\n * const code = fs.readFileSync(pathToSolidity, 'utf8'),\n * const remappings = {}\n * const lib = []\n *\n * const imports = runPromise(\n *   resolveImports(\n *     pathToSolidity,\n *     code,\n *     remappings,\n *     libs,\n *     false\n *   )\n * )\n * console.log(imports) // [{ updated: '/path/to/Contract.sol', absolute: '/path/to/Contract.sol', original: '../Contract.sol' }]\n * ```\n */\nexport const resolveImports = (absolutePath, code, remappings, libs, sync) => {\n\tconst importRegEx = /^\\s?import\\s+[^'\"]*['\"](.*)['\"]\\s*/gm\n\n\tif (typeof absolutePath !== 'string') {\n\t\treturn die(`Type ${typeof absolutePath} is not of type string`)\n\t}\n\tif (typeof code !== 'string') {\n\t\treturn die(`Type ${typeof code} is not of type string`)\n\t}\n\tif (typeof sync !== 'boolean') {\n\t\treturn die(`Type ${typeof sync} is not of type boolean`)\n\t}\n\tconst allImports =\n\t\t/** @type Array<import(\"effect/Effect\").Effect<import(\"./types.js\").ResolvedImport, import(\"./utils/resolveImportPath.js\").CouldNotResolveImportError, >> */ ([])\n\tlet foundImport = importRegEx.exec(code)\n\twhile (foundImport != null) {\n\t\tconst importPath = foundImport[1]\n\t\tif (!importPath) {\n\t\t\treturn fail(new ImportDoesNotExistError())\n\t\t}\n\t\tallImports.push(\n\t\t\tresolveImportPath(absolutePath, importPath, remappings, libs, sync).pipe(\n\t\t\t\tmap((absolute) => ({\n\t\t\t\t\tupdated: absolute,\n\t\t\t\t\tabsolute,\n\t\t\t\t\toriginal: importPath,\n\t\t\t\t})),\n\t\t\t),\n\t\t)\n\t\tfoundImport = importRegEx.exec(code)\n\t}\n\treturn all(allImports)\n}\n","/**\n * Error thrown if an invariant is violated\n */\nexport class InvariantError extends Error {\n\t/**\n\t * @param {string} message - The message to display\n\t */\n\tconstructor(message) {\n\t\tsuper(message)\n\t\tthis.name = 'InvariantError'\n\t}\n}\n\n/**\n * Asserts an invariant in a typesafe way\n * @param {boolean} condition - The condition to assert\n * @param {string} message - The message to display if the condition is false\n * @throws {Error} Throws an error if the condition is false\n */\nexport function invariant(condition, message) {\n\tif (!condition) {\n\t\tthrow new InvariantError(message)\n\t}\n}\n","import { tryPromise, try as trySync } from 'effect/Effect'\n\n/**\n * @typedef {ReturnType<typeof safeFao>} SafeFao\n */\n\nexport class ReadFileError extends Error {\n\t/**\n\t * @type {'ReadFileError'}\n\t */\n\t_tag = 'ReadFileError'\n\t/**\n\t * @type {'ReadFileError'}\n\t * @override\n\t */\n\tname = 'ReadFileError'\n\t/**\n\t * @param {Error} cause\n\t */\n\tconstructor(cause) {\n\t\tsuper(`Read file error: ${cause.message}`, { cause })\n\t}\n}\n\nexport class ExistsError extends Error {\n\t/**\n\t * @type {'ExistsError'}\n\t */\n\t_tag = 'ExistsError'\n\t/**\n\t * @type {'ExistsError'}\n\t * @override\n\t */\n\tname = 'ExistsError'\n\t/**\n\t * @param {Error} cause\n\t */\n\tconstructor(cause) {\n\t\tsuper(`Unable to determine existence: ${cause.message}`, { cause })\n\t}\n}\n\n/**\n * Turns a file access object into a safe file access object that returns effects\n * @param {import(\"../types.js\").FileAccessObject} fao\n * @example\n * ```ts\n * const fao = {\n *   \treadFile: readFile,\n * \t\treadFileSync: readFileSync,\n *\t\texistsSync: existsSync,\n * }\n * const safeFao = safeFao(fao)\n * safeFao.readFileSync('path/to/file', 'utf8') .pipe(\n *   tap((fileContent) => console.log(fileContent)),\n * )\n * ```\n */\nexport const safeFao = (fao) => {\n\treturn {\n\t\t/**\n\t\t * @param {string} path\n\t\t * @param {BufferEncoding} encoding\n\t\t */\n\t\treadFile: (path, encoding) => {\n\t\t\treturn tryPromise({\n\t\t\t\ttry: () => {\n\t\t\t\t\treturn fao.readFile(path, encoding)\n\t\t\t\t},\n\t\t\t\tcatch: (e) => {\n\t\t\t\t\treturn new ReadFileError(/** @type Error */ (e))\n\t\t\t\t},\n\t\t\t})\n\t\t},\n\t\t/**\n\t\t * @param {string} path\n\t\t * @param {BufferEncoding} encoding\n\t\t */\n\t\treadFileSync: (path, encoding) => {\n\t\t\treturn trySync({\n\t\t\t\ttry: () => {\n\t\t\t\t\treturn fao.readFileSync(path, encoding)\n\t\t\t\t},\n\t\t\t\tcatch: (e) => {\n\t\t\t\t\treturn new ReadFileError(/** @type Error */ (e))\n\t\t\t\t},\n\t\t\t})\n\t\t},\n\t\t/**\n\t\t * @param {string} path\n\t\t */\n\t\texists: (path) => {\n\t\t\treturn tryPromise({\n\t\t\t\ttry: () => {\n\t\t\t\t\treturn fao.exists(path)\n\t\t\t\t},\n\t\t\t\tcatch: (e) => {\n\t\t\t\t\treturn new ExistsError(/** @type Error */ (e))\n\t\t\t\t},\n\t\t\t})\n\t\t},\n\t\t/**\n\t\t * @param {string} path\n\t\t */\n\t\texistsSync: (path) => {\n\t\t\treturn trySync({\n\t\t\t\ttry: () => {\n\t\t\t\t\treturn fao.existsSync(path)\n\t\t\t\t},\n\t\t\t\tcatch: (e) => {\n\t\t\t\t\treturn new ExistsError(/** @type Error */ (e))\n\t\t\t\t},\n\t\t\t})\n\t\t},\n\t}\n}\n","import { succeed } from 'effect/Effect'\n\n/**\n * Updates all the import paths that match the importedIds\n * @param {string} code Source code to update\n * @param {ReadonlyArray<import(\"../types.js\").ResolvedImport>} resolvedImports Import to update\n * @returns {import(\"effect/Effect\").Effect<string, never, never>} the source code formatted with the imprt replaced\n */\nexport const updateImportPaths = (code, resolvedImports) => {\n\tconst solidityImportRegex = /(^\\s?import\\s+[^'\"]*['\"])(.*)(['\"]\\s*)/gm\n\treturn succeed(\n\t\tcode.replaceAll(solidityImportRegex, (match, p1, p2, p3) => {\n\t\t\tconst resolvedImport = resolvedImports.find(({ original }) => original === p2)\n\t\t\tif (resolvedImport) {\n\t\t\t\treturn `${p1}${resolvedImport.updated}${p3}`\n\t\t\t}\n\t\t\treturn match\n\t\t}),\n\t)\n}\n\n/**\n * Updates a specific import path in source code\n * @param {string} source - Source code to update\n * @param {string} oldPath - The original import path to replace\n * @param {string} newPath - The new import path\n * @returns {string} - Updated source code\n */\nexport const updateImportPath = (source, oldPath, newPath) => {\n\tconst solidityImportRegex = /(^\\s?import\\s+[^'\"]*['\"])(.*)(['\"]\\s*)/gm\n\treturn source.replaceAll(solidityImportRegex, (match, p1, p2, p3) => {\n\t\tif (p2 === oldPath) {\n\t\t\treturn `${p1}${newPath}${p3}`\n\t\t}\n\t\treturn match\n\t})\n}\n","import { fail, succeed } from 'effect/Effect'\n\nexport class NoPragmaFoundError extends Error {\n\t/**\n\t * @type {'NoPragmaFoundError'}\n\t */\n\t_tag = 'NoPragmaFoundError'\n\t/**\n\t * @type {'NoPragmaFoundError'}\n\t * @override\n\t */\n\tname = 'NoPragmaFoundError'\n}\n\nconst pragmaPattern = /pragma\\s+solidity\\s+((\\^|~|>|>=|<|<=)?\\s*(\\d+\\.\\d+\\.\\d+)\\s*);/\nconst pragmaPatternWithBounds = /pragma\\s+solidity\\s+(>=?\\d+\\.\\d+\\.\\d+)\\s*<\\s*(\\d+\\.\\d+\\.\\d+)\\s*;/\n\n/**\n * Updates the pragma statement in a Solidity file to the specified version.\n * This is a huge hack to avoid needing to dynamically download solc versions. We should fix this in future\n * @param {string} solidityCode The Solidity code to update.\n * @param {string} [version] Optional version to update to. If not provided, uses the version in the file.\n * @returns {import(\"effect/Effect\").Effect<string, NoPragmaFoundError, never>} The updated Solidity code.\n */\nexport const updatePragma = (solidityCode, version) => {\n\tlet match = solidityCode.match(pragmaPattern)\n\tif (match?.[3]) {\n\t\tconst versionToUse = version || match[3]\n\t\tconst newPragma = `pragma solidity >=${versionToUse};`\n\t\treturn succeed(solidityCode.replace(pragmaPattern, newPragma))\n\t}\n\tmatch = solidityCode.match(pragmaPatternWithBounds)\n\tif (match?.[1]) {\n\t\tconst versionToUse = version ? `>=${version}` : match[1]\n\t\tconst newPragma = `pragma solidity ${versionToUse};`\n\t\treturn succeed(solidityCode.replace(pragmaPatternWithBounds, newPragma))\n\t}\n\treturn fail(new NoPragmaFoundError('No valid pragma statement found.'))\n}\n","import { gen } from 'effect/Effect'\nimport { resolveImports } from './resolveImports.js'\nimport { invariant } from './utils/invariant.js'\nimport { safeFao } from './utils/safeFao.js'\nimport { updateImportPaths } from './utils/updateImportPath.js'\nimport { updatePragma } from './utils/updatePragma.js'\n\n/**\n * @typedef {import(\"./resolveImports.js\").ResolveImportsError | import(\"./utils/safeFao.js\").ReadFileError | import(\"./utils/resolveImportPath.js\").CouldNotResolveImportError | import(\"./utils/updatePragma.js\").NoPragmaFoundError} ModuleFactoryError\n */\n\n/**\n * Creates a module from the given module information.\n * This includes resolving all imports and creating a dependency graph.\n *\n * Currently it modifies the source code in place which causes the ast to not match the source code.\n * This complexity leaks to the typescript lsp which has to account for this\n * Ideally we refactor this to not need to modify source code in place\n * Doing this hurts our ability to control the import graph and make it use node resolution though\n * See foundry that is alergic to using npm\n * Doing it this way for now is easier but for sure a leaky abstraction\n * @param {string} absolutePath\n * @param {string} rawCode\n * @param {Record<string, string>} remappings\n * @param {ReadonlyArray<string>} libs\n * @param {import(\"./types.js\").FileAccessObject} fao\n * @param {boolean} sync Whether to run this synchronously or not\n * @returns {import(\"effect/Effect\").Effect<Map<string, import(\"./types.js\").ModuleInfo>, ModuleFactoryError, never>}\n * @example\n * ```ts\n * const pathToSolidity = path.join(__dirname, '../Contract.sol')\n * const rawCode = fs.readFileSync(pathToSolidity, 'utf8'),\n *\n * const modules = runPromise(\n *   moduleFactory(\n *     pathToSolidity,\n *     rawCode,\n *     {\n *       \"remapping\": \"remapping/src\"\n *     },\n *     [\"lib/path\"],\n *     {\n *       readFileSync,\n *       readFile,\n *       existsSync,\n *     },\n *     false\n *   )\n * )\n * console.log(modules.get(pathToSolidity)) // { id: '/path/to/Contract.sol', rawCode: '...', importedIds: ['/path/to/Imported.sol'], code: '...' }\n * ```\n */\nexport const moduleFactory = (absolutePath, rawCode, remappings, libs, fao, sync) => {\n\treturn gen(function* (_) {\n\t\tconst readFile = sync ? safeFao(fao).readFileSync : safeFao(fao).readFile\n\t\tconst stack = [{ absolutePath, rawCode }]\n\t\tconst modules =\n\t\t\t/** @type{Map<string, import(\"./types.js\").ModuleInfo>} */\n\t\t\t(new Map())\n\t\twhile (stack.length) {\n\t\t\tconst nextItem = stack.pop()\n\t\t\tinvariant(nextItem, 'Module should exist')\n\t\t\tconst { absolutePath, rawCode } = nextItem\n\n\t\t\tif (modules.has(absolutePath)) continue\n\n\t\t\tconst resolvedImports = yield* _(resolveImports(absolutePath, rawCode, remappings, libs, sync))\n\n\t\t\tmodules.set(absolutePath, {\n\t\t\t\tid: absolutePath,\n\t\t\t\trawCode,\n\t\t\t\timportedIds: resolvedImports.map(({ absolute }) => absolute),\n\t\t\t\tcode: yield* _(updatePragma(yield* _(updateImportPaths(rawCode, resolvedImports)))),\n\t\t\t})\n\n\t\t\tfor (const resolvedImport of resolvedImports) {\n\t\t\t\tconst depRawCode = yield* _(readFile(resolvedImport.absolute, 'utf8'))\n\t\t\t\tstack.push({\n\t\t\t\t\tabsolutePath: resolvedImport.absolute,\n\t\t\t\t\trawCode: depRawCode,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\treturn modules\n\t})\n}\n"]}