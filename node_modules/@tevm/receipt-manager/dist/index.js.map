{"version":3,"sources":["../src/createMapDb.js","../src/ReceiptManager.ts"],"names":["i","hexToBytes","numberToHex","blockHash","txIndex"],"mappings":"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","file":"index.js","sourcesContent":["// this is from ethereumjs and carries the same license as the original\n// https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/client/src/execution/receipt.ts\nimport { concatBytes, hexToBytes, numberToHex, toHex } from '@tevm/utils'\n\n/**\n * Mapping of database entry types to their numeric IDs for storage\n * Only append new items to the bottom of the list to remain backward compatible.\n * @type {Record<import('./MapDb.js').DbType, number>}\n */\nexport const typeToId = {\n\tReceipts: 0,\n\tTxHash: 1,\n\tSkeletonBlock: 2,\n\tSkeletonBlockHashToNumber: 3,\n\tSkeletonStatus: 4,\n\tSkeletonUnfinalizedBlockByHash: 5,\n\tPreimage: 6,\n}\n\n/**\n * Creates a MapDb which uses an in-memory map as its underlying data structure.\n * This implementation provides methods for storing, retrieving, and deleting\n * transaction receipts and other blockchain data.\n *\n * @param {object} options - The configuration options\n * @param {Map<import('@tevm/utils').Hex, Uint8Array>} options.cache - The cache map to use for storage\n * @returns {import('./MapDb.js').MapDb} A MapDb instance backed by the provided cache\n *\n * @example\n * import { createMapDb } from './createMapDb.js'\n *\n * const cache = new Map()\n * const mapDb = createMapDb({ cache })\n *\n * // Store a receipt\n * await mapDb.put('Receipts', blockHash, encodedReceipt)\n *\n * // Retrieve the receipt\n * const receipt = await mapDb.get('Receipts', blockHash)\n *\n * // Delete the receipt\n * await mapDb.delete('Receipts', blockHash)\n */\nexport const createMapDb = ({ cache }) => {\n\t/**\n\t * Generates a database key by combining the type ID and the key\n\t * @param {import('./MapDb.js').DbType} type - The type of database entry\n\t * @param {Uint8Array} key - The key for the entry\n\t * @returns {import('@tevm/utils').Hex} The combined database key as a hex string\n\t * @private\n\t */\n\tconst dbKey = (type, key) => {\n\t\t// TODO add numberToBytes to utils\n\t\treturn toHex(concatBytes(hexToBytes(numberToHex(typeToId[type])), key))\n\t}\n\n\treturn {\n\t\t...{ _cache: cache },\n\t\t/**\n\t\t * Store a value in the database\n\t\t * @param {import('./MapDb.js').DbType} type - The type of data being stored\n\t\t * @param {Uint8Array} hash - The hash key for the data\n\t\t * @param {Uint8Array} value - The value to store\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tput(type, hash, value) {\n\t\t\tcache.set(dbKey(type, hash), value)\n\t\t\treturn Promise.resolve()\n\t\t},\n\n\t\t/**\n\t\t * Retrieve a value from the database\n\t\t * @param {import('./MapDb.js').DbType} type - The type of data to retrieve\n\t\t * @param {Uint8Array} hash - The hash key for the data\n\t\t * @returns {Promise<Uint8Array | null>} The stored value or null if not found\n\t\t */\n\t\tget(type, hash) {\n\t\t\treturn Promise.resolve(cache.get(dbKey(type, hash)) ?? null)\n\t\t},\n\n\t\t/**\n\t\t * Delete a value from the database\n\t\t * @param {import('./MapDb.js').DbType} type - The type of data to delete\n\t\t * @param {Uint8Array} hash - The hash key for the data to delete\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tdelete(type, hash) {\n\t\t\tcache.delete(dbKey(type, hash))\n\t\t\treturn Promise.resolve()\n\t\t},\n\n\t\t/**\n\t\t * Create a deep copy of the MapDb instance with a new copy of the cache\n\t\t * @returns {import('./MapDb.js').MapDb} A new MapDb instance with a copy of the data\n\t\t */\n\t\tdeepCopy() {\n\t\t\treturn createMapDb({ cache: new Map(cache) })\n\t\t},\n\t}\n}\n","// this is from ethereumjs and carries the same license as the original\n// https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/client/src/execution/receipt.ts\n\nimport type { Block } from '@tevm/block'\nimport { type Chain, getBlock } from '@tevm/blockchain'\nimport { Rlp } from '@tevm/rlp'\nimport type { TransactionType, TypedTransaction } from '@tevm/tx'\nimport type { EthjsLog } from '@tevm/utils'\nimport { Bloom, bytesToBigInt, bytesToNumber, equalsBytes, hexToBytes, numberToHex, stringToHex } from '@tevm/utils'\nimport type { MapDb } from './MapDb.js'\n\n// Some of these types are actually from the Vm package but they are better to live here imo\n/**\n * Abstract interface with common transaction receipt fields that all receipt types share\n * This serves as the base for both pre and post-Byzantium transaction receipts\n */\nexport interface BaseTxReceipt {\n\t/**\n\t * Cumulative gas used in the block including this transaction\n\t * Represented as a bigint to handle large gas values accurately\n\t */\n\tcumulativeBlockGasUsed: bigint\n\n\t/**\n\t * Bloom filter bitvector containing indexed log data\n\t * Used for efficient searching of logs in the blockchain\n\t */\n\tbitvector: Uint8Array\n\n\t/**\n\t * Array of logs emitted during transaction execution\n\t * Each log contains address, topics, and data fields\n\t */\n\tlogs: EthjsLog[]\n}\n\n/**\n * Receipt type for Byzantium and beyond (EIP-658)\n * Replaces the intermediary state root field with a status code field\n * Introduced in the Byzantium hard fork\n */\nexport interface PostByzantiumTxReceipt extends BaseTxReceipt {\n\t/**\n\t * Status of transaction execution\n\t * - `1` if successful\n\t * - `0` if an exception occurred during execution\n\t */\n\tstatus: 0 | 1\n}\n\n/**\n * Pre-Byzantium receipt type used before the Byzantium hard fork\n * Contains a state root field instead of the status code used in later versions\n */\nexport interface PreByzantiumTxReceipt extends BaseTxReceipt {\n\t/**\n\t * Intermediary state root after transaction execution\n\t * This is a 32-byte Merkle root of the state trie\n\t */\n\tstateRoot: Uint8Array\n}\n\n/**\n * Receipt type for EIP-4844 blob transactions\n * Extends the post-Byzantium receipt with additional blob gas fields\n */\nexport interface EIP4844BlobTxReceipt extends PostByzantiumTxReceipt {\n\t/**\n\t * Amount of blob gas consumed by the transaction\n\t *\n\t * Note: This value is not included in the receiptRLP used for encoding the receiptsRoot in a block\n\t * and is only provided as part of receipt metadata.\n\t */\n\tblobGasUsed: bigint\n\n\t/**\n\t * Price of blob gas for the block the transaction was included in\n\t *\n\t * Note: This value is not included in the `receiptRLP` used for encoding the `receiptsRoot` in a block\n\t * and is only provided as part of receipt metadata.\n\t */\n\tblobGasPrice: bigint\n}\n\n/**\n * Union type of all transaction receipt types\n * Can be pre-Byzantium, post-Byzantium, or EIP-4844 blob receipt\n */\nexport type TxReceipt = PreByzantiumTxReceipt | PostByzantiumTxReceipt | EIP4844BlobTxReceipt\n\n/**\n * TxReceiptWithType extends TxReceipt to provide transaction type information\n * This is used when the receipt needs to include the transaction type (EIP-2718)\n */\nexport type TxReceiptWithType = PreByzantiumTxReceiptWithType | PostByzantiumTxReceiptWithType\n\n/**\n * Pre-Byzantium receipt type with transaction type information\n * Extends the pre-Byzantium receipt with the EIP-2718 transaction type\n */\ninterface PreByzantiumTxReceiptWithType extends PreByzantiumTxReceipt {\n\t/**\n\t * EIP-2718 Typed Transaction Envelope type\n\t * Indicates which transaction format was used\n\t */\n\ttxType: TransactionType\n}\n\n/**\n * Post-Byzantium receipt type with transaction type information\n * Extends the post-Byzantium receipt with the EIP-2718 transaction type\n */\ninterface PostByzantiumTxReceiptWithType extends PostByzantiumTxReceipt {\n\t/**\n\t * EIP-2718 Typed Transaction Envelope type\n\t * Indicates which transaction format was used\n\t */\n\ttxType: TransactionType\n}\n\n/**\n * Return type for getReceiptByTxHash method containing the receipt and its metadata\n * Used to format responses for RPC methods like eth_getTransactionReceipt\n */\ntype GetReceiptByTxHashReturn = [receipt: TxReceipt, blockHash: Uint8Array, txIndex: number, logIndex: number]\n\n/**\n * Return type for getLogs method containing log entries with their associated block and transaction data\n * Used to format responses for RPC methods like eth_getLogs\n */\ntype GetLogsReturn = {\n\t/** The log entry containing address, topics, and data */\n\tlog: EthjsLog\n\t/** The block containing the transaction that produced this log */\n\tblock: Block\n\t/** The transaction that produced this log */\n\ttx: TypedTransaction\n\t/** Index of the transaction within the block */\n\ttxIndex: number\n\t/** Global index of the log within the block */\n\tlogIndex: number\n}[]\n\n/**\n * Index type for mapping transaction hashes to their block hash and position\n * Used to efficiently look up receipts by transaction hash\n */\ntype TxHashIndex = [blockHash: Uint8Array, txIndex: number]\n\n/**\n * Enum defining the types of indexes that can be maintained\n * Currently only supports transaction hash indexes\n */\nenum IndexType {\n\t/** Index for mapping transaction hashes to block hash and position */\n\tTxHash = 0,\n}\n\n/**\n * Enum defining operations that can be performed on indexes\n */\nenum IndexOperation {\n\t/** Create or update an index */\n\tSave = 0,\n\t/** Remove an index */\n\tDelete = 1,\n}\n\n/**\n * Types for RLP encoding and decoding\n */\n\n/** Type alias for log entries in RLP format */\ntype rlpLog = EthjsLog\n\n/** RLP format for receipt entries: [status/stateRoot, gasUsed, logs] */\ntype rlpReceipt = [postStateOrStatus: Uint8Array, cumulativeGasUsed: Uint8Array, logs: rlpLog[]]\n\n/** RLP format for txHash index entries: [blockHash, txIndex] */\ntype rlpTxHash = [blockHash: Uint8Array, txIndex: Uint8Array]\n\n/**\n * Enum for RLP conversion operations\n */\nenum RlpConvert {\n\t/** Convert from JavaScript objects to RLP-encoded bytes */\n\tEncode = 0,\n\t/** Convert from RLP-encoded bytes to JavaScript objects */\n\tDecode = 1,\n}\n\n/**\n * Enum for RLP data types\n */\nenum RlpType {\n\t/** Transaction receipts for a block */\n\tReceipts = 0,\n\t/** Log entries */\n\tLogs = 1,\n\t/** Transaction hash index */\n\tTxHash = 2,\n}\n\n/**\n * Union type for data that can be RLP encoded or decoded\n */\ntype rlpOut = EthjsLog[] | TxReceipt[] | TxHashIndex\n\n/**\n * Manages transaction receipts within the Ethereum virtual machine\n * Provides methods for storing, retrieving, and searching transaction receipts and logs\n */\nexport class ReceiptsManager {\n\t/**\n\t * Creates a new ReceiptsManager instance\n\t * @param mapDb - The database instance for storing receipts and indexes\n\t * @param chain - The blockchain instance for retrieving blocks\n\t */\n\tconstructor(\n\t\tpublic readonly mapDb: MapDb,\n\t\tpublic readonly chain: Chain,\n\t) {}\n\n\t/**\n\t * Maximum number of logs to return in getLogs\n\t * This prevents excessive memory usage and response size\n\t */\n\tGET_LOGS_LIMIT = 10000\n\n\t/**\n\t * Maximum size of getLogs response in megabytes\n\t * This prevents excessive memory usage and response size\n\t */\n\tGET_LOGS_LIMIT_MEGABYTES = 150\n\n\t/**\n\t * Maximum block range that can be queried in a single getLogs call\n\t * This prevents excessive computational load from large queries\n\t */\n\tGET_LOGS_BLOCK_RANGE_LIMIT = 2500\n\n\t/**\n\t * Creates a deep copy of this ReceiptsManager with a new chain reference\n\t * Useful for creating a snapshot of the current state\n\t *\n\t * @param chain - The new chain reference to use\n\t * @returns A new ReceiptsManager instance with copied state\n\t */\n\tdeepCopy(chain: Chain): ReceiptsManager {\n\t\treturn new ReceiptsManager(this.mapDb.deepCopy(), chain)\n\t}\n\n\t/**\n\t * Saves transaction receipts to the database for a given block\n\t * Also builds and saves transaction hash indexes for efficient lookups\n\t *\n\t * @param block - The block containing the transactions\n\t * @param receipts - The transaction receipts to save\n\t * @returns Promise that resolves when saving is complete\n\t *\n\t * @example\n\t * const block = await chain.getBlock(blockNumber)\n\t * await receiptManager.saveReceipts(block, txReceipts)\n\t */\n\tasync saveReceipts(block: Block, receipts: TxReceipt[]) {\n\t\tconst encoded = this.rlp(RlpConvert.Encode, RlpType.Receipts, receipts)\n\t\tawait this.mapDb.put('Receipts', block.hash(), encoded)\n\t\tvoid this.updateIndex(IndexOperation.Save, IndexType.TxHash, block)\n\t}\n\n\t/**\n\t * Deletes transaction receipts and their indexes for a given block\n\t * Used when removing or replacing block data\n\t *\n\t * @param block - The block whose receipts should be deleted\n\t * @returns Promise that resolves when deletion is complete\n\t *\n\t * @example\n\t * const block = await chain.getBlock(blockNumber)\n\t * await receiptManager.deleteReceipts(block)\n\t */\n\tasync deleteReceipts(block: Block) {\n\t\tawait this.mapDb.delete('Receipts', block.hash())\n\t\tvoid this.updateIndex(IndexOperation.Delete, IndexType.TxHash, block)\n\t}\n\n\t/**\n\t * Retrieves transaction receipts for a given block hash\n\t * Can optionally calculate bloom filters and include transaction types\n\t *\n\t * @param blockHash - The hash of the block to get receipts for\n\t * @param calcBloom - Whether to calculate and include bloom filters (default: false)\n\t * @param includeTxType - Whether to include transaction types in the receipts (default: false)\n\t * @returns Promise resolving to an array of transaction receipts\n\t *\n\t * @example\n\t * // Get basic receipts\n\t * const receipts = await receiptManager.getReceipts(blockHash)\n\t *\n\t * // Get receipts with bloom filters and transaction types\n\t * const receiptsWithDetails = await receiptManager.getReceipts(blockHash, true, true)\n\t */\n\tasync getReceipts(blockHash: Uint8Array, calcBloom?: boolean, includeTxType?: true): Promise<TxReceiptWithType[]>\n\tasync getReceipts(blockHash: Uint8Array, calcBloom?: boolean, includeTxType?: false): Promise<TxReceipt[]>\n\tasync getReceipts(\n\t\tblockHash: Uint8Array,\n\t\tcalcBloom = false,\n\t\tincludeTxType = false,\n\t): Promise<TxReceipt[] | TxReceiptWithType[]> {\n\t\tconst encoded = await this.mapDb.get('Receipts', blockHash)\n\t\tif (!encoded) return []\n\t\tlet receipts = this.rlp(RlpConvert.Decode, RlpType.Receipts, encoded)\n\t\tif (calcBloom) {\n\t\t\treceipts = receipts.map((r) => {\n\t\t\t\tr.bitvector = this.logsBloom(r.logs).bitvector\n\t\t\t\treturn r\n\t\t\t})\n\t\t}\n\t\tif (includeTxType) {\n\t\t\tconst block = await getBlock(this.chain)(blockHash)\n\t\t\treceipts = (receipts as TxReceiptWithType[]).map((r, i) => {\n\t\t\t\tconst type = block.transactions[i]?.type\n\t\t\t\tif (type) {\n\t\t\t\t\tr.txType = type\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t})\n\t\t}\n\t\treturn receipts\n\t}\n\n\t/**\n\t * Retrieves a transaction receipt by transaction hash\n\t * Also returns additional metadata needed for JSON-RPC responses\n\t *\n\t * @param txHash - The transaction hash to look up\n\t * @returns Promise resolving to receipt data or null if not found\n\t *\n\t * @example\n\t * const receiptData = await receiptManager.getReceiptByTxHash(txHash)\n\t * if (receiptData) {\n\t *   const [receipt, blockHash, txIndex, logIndex] = receiptData\n\t *   // Use receipt data\n\t * }\n\t */\n\tasync getReceiptByTxHash(txHash: Uint8Array): Promise<GetReceiptByTxHashReturn | null> {\n\t\tconst txHashIndex = await this.getIndex(IndexType.TxHash, txHash)\n\t\tif (!txHashIndex) return null\n\t\tconst [blockHash, txIndex] = txHashIndex\n\t\tconst receipts = await this.getReceipts(blockHash)\n\t\tif (receipts.length === 0) return null\n\t\tlet logIndex = 0\n\t\treceipts.slice(0, txIndex).forEach((r) => {\n\t\t\tlogIndex += r.logs.length\n\t\t})\n\t\tconst receipt = receipts[txIndex]\n\t\tif (!receipt) {\n\t\t\tthrow new Error('Receipt not found')\n\t\t}\n\t\treceipt.bitvector = this.logsBloom(receipt.logs).bitvector\n\t\treturn [receipt, blockHash, txIndex, logIndex]\n\t}\n\n\t/**\n\t * Retrieves logs matching the specified criteria within a block range\n\t * Implements the core functionality of eth_getLogs JSON-RPC method\n\t * Enforces size and count limits to prevent excessive resource usage\n\t *\n\t * @param from - The starting block\n\t * @param to - The ending block\n\t * @param addresses - Optional array of addresses to filter logs by\n\t * @param topics - Optional array of topics to filter logs by, can include arrays and nulls\n\t * @returns Promise resolving to array of matching logs with metadata\n\t *\n\t * @example\n\t * // Get all logs between blocks 100 and 200\n\t * const logs = await receiptManager.getLogs(block100, block200)\n\t *\n\t * // Get logs from a specific contract\n\t * const logs = await receiptManager.getLogs(block100, block200, [contractAddress])\n\t *\n\t * // Get logs with specific topics\n\t * const logs = await receiptManager.getLogs(block100, block200, undefined, [eventTopic])\n\t */\n\tasync getLogs(\n\t\tfrom: Block,\n\t\tto: Block,\n\t\taddresses?: Uint8Array[],\n\t\ttopics: (Uint8Array | Uint8Array[] | null)[] = [],\n\t): Promise<GetLogsReturn> {\n\t\tconst returnedLogs: GetLogsReturn = []\n\t\tlet returnedLogsSize = 0\n\t\tfor (let i = from.header.number; i <= to.header.number; i++) {\n\t\t\tconst block = await getBlock(this.chain)(i)\n\t\t\tconst receipts = await this.getReceipts(block.hash())\n\t\t\tif (receipts.length === 0) continue\n\t\t\tlet logs: GetLogsReturn = []\n\t\t\tlet logIndex = 0\n\t\t\tfor (const [receiptIndex, receipt] of receipts.entries()) {\n\t\t\t\tlogs.push(\n\t\t\t\t\t...receipt.logs.map((log) => ({\n\t\t\t\t\t\tlog,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\ttx: block.transactions[receiptIndex] as TypedTransaction,\n\t\t\t\t\t\ttxIndex: receiptIndex,\n\t\t\t\t\t\tlogIndex: logIndex++,\n\t\t\t\t\t})),\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (addresses && addresses.length > 0) {\n\t\t\t\tlogs = logs.filter((l) => addresses.some((a) => equalsBytes(a, l.log[0])))\n\t\t\t}\n\t\t\tif (topics.length > 0) {\n\t\t\t\t// From https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter/:\n\t\t\t\t// Topics are order-dependent. A transaction with a log with topics\n\t\t\t\t// [A, B] will be matched by the following topic filters:\n\t\t\t\t//  * [] - anything\n\t\t\t\t//  * [A] - A in first position (and anything after)\n\t\t\t\t//  * [null, B] - anything in first position AND B in second position (and anything after)\n\t\t\t\t//  * [A, B] - A in first position AND B in second position (and anything after)\n\t\t\t\t//  * [[A, B], [A, B]] - (A OR B) in first position AND (A OR B) in second position (and anything after)\n\t\t\t\tlogs = logs.filter((l) => {\n\t\t\t\t\tfor (const [i, topic] of topics.entries()) {\n\t\t\t\t\t\tif (Array.isArray(topic)) {\n\t\t\t\t\t\t\t// Can match any items in this array\n\t\t\t\t\t\t\tif (!topic.find((t) => equalsBytes(t, l.log[1][i] as Uint8Array))) return false\n\t\t\t\t\t\t} else if (!topic) {\n\t\t\t\t\t\t\t// If null then can match any\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If a value is specified then it must match\n\t\t\t\t\t\t\tif (!equalsBytes(topic, l.log[1][i] as Uint8Array)) return false\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t}\n\t\t\treturnedLogs.push(...logs)\n\t\t\t// TODO add stringToBytes to utils\n\t\t\treturnedLogsSize += hexToBytes(stringToHex(JSON.stringify(logs))).byteLength\n\t\t\tif (returnedLogs.length >= this.GET_LOGS_LIMIT || returnedLogsSize >= this.GET_LOGS_LIMIT_MEGABYTES * 1048576) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn returnedLogs\n\t}\n\n\t/**\n\t * Updates indexes in the database based on the operation type\n\t * Used internally to maintain transaction hash to receipt mappings\n\t *\n\t * @param operation - Whether to save or delete indexes\n\t * @param type - The type of index to update\n\t * @param value - The data used to update indexes (typically a block)\n\t * @returns Promise that resolves when the update is complete\n\t * @private\n\t */\n\tprivate async updateIndex(operation: IndexOperation, type: IndexType.TxHash, value: Block): Promise<void>\n\tprivate async updateIndex(operation: IndexOperation, type: IndexType, value: any): Promise<void> {\n\t\tswitch (type) {\n\t\t\tcase IndexType.TxHash: {\n\t\t\t\tconst block = value\n\t\t\t\tif (operation === IndexOperation.Save) {\n\t\t\t\t\tfor (const [i, tx] of block.transactions.entries()) {\n\t\t\t\t\t\tconst index: TxHashIndex = [block.hash(), i]\n\t\t\t\t\t\tconst encoded = this.rlp(RlpConvert.Encode, RlpType.TxHash, index)\n\t\t\t\t\t\tawait this.mapDb.put('TxHash', tx.hash(), encoded)\n\t\t\t\t\t}\n\t\t\t\t} else if (operation === IndexOperation.Delete) {\n\t\t\t\t\tfor (const tx of block.transactions) {\n\t\t\t\t\t\tawait this.mapDb.delete('TxHash', tx.hash())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unsupported index type')\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves an index value from the database\n\t * Used internally to look up transaction hash mappings\n\t *\n\t * @param type - The type of index to retrieve\n\t * @param value - The key to look up (typically a transaction hash)\n\t * @returns Promise resolving to the index value or null if not found\n\t * @private\n\t */\n\tprivate async getIndex(type: IndexType.TxHash, value: Uint8Array): Promise<TxHashIndex | null>\n\tprivate async getIndex(type: IndexType, value: Uint8Array): Promise<any | null> {\n\t\tswitch (type) {\n\t\t\tcase IndexType.TxHash: {\n\t\t\t\tconst encoded = await this.mapDb.get('TxHash', value)\n\t\t\t\tif (!encoded) return null\n\t\t\t\treturn this.rlp(RlpConvert.Decode, RlpType.TxHash, encoded)\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unsupported index type')\n\t\t}\n\t}\n\n\t/**\n\t * Encodes or decodes data using RLP serialization for database storage\n\t * Supports different data types and formats based on the parameters\n\t *\n\t * @param conversion - Whether to encode or decode\n\t * @param type - The type of data being processed\n\t * @param value - The data to encode or decode\n\t * @returns Encoded bytes or decoded data structures\n\t * @private\n\t */\n\tprivate rlp(conversion: RlpConvert.Encode, type: RlpType, value: rlpOut): Uint8Array\n\tprivate rlp(conversion: RlpConvert.Decode, type: RlpType.Receipts, values: Uint8Array): TxReceipt[]\n\tprivate rlp(conversion: RlpConvert.Decode, type: RlpType.Logs, value: rlpLog[]): EthjsLog[]\n\tprivate rlp(conversion: RlpConvert.Decode, type: RlpType.TxHash, value: Uint8Array): TxHashIndex\n\tprivate rlp(conversion: RlpConvert, type: RlpType, value: Uint8Array | rlpOut): Uint8Array | rlpOut {\n\t\tswitch (type) {\n\t\t\tcase RlpType.Receipts: {\n\t\t\t\tif (conversion === RlpConvert.Encode) {\n\t\t\t\t\treturn Rlp.encode(\n\t\t\t\t\t\t(value as TxReceipt[]).map((r) => [\n\t\t\t\t\t\t\t(r as PreByzantiumTxReceipt).stateRoot ??\n\t\t\t\t\t\t\t\t// TODO add numberToBytes to utils\n\t\t\t\t\t\t\t\thexToBytes(numberToHex((r as PostByzantiumTxReceipt).status)),\n\t\t\t\t\t\t\t// TODO add numberToBytes to utils\n\t\t\t\t\t\t\thexToBytes(numberToHex(r.cumulativeBlockGasUsed)),\n\t\t\t\t\t\t\tthis.rlp(RlpConvert.Encode, RlpType.Logs, r.logs),\n\t\t\t\t\t\t]),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tconst decoded = Rlp.decode(value as Uint8Array) as unknown as rlpReceipt[]\n\t\t\t\treturn decoded.map((r) => {\n\t\t\t\t\tconst gasUsed = r[1]\n\t\t\t\t\tconst logs = this.rlp(RlpConvert.Decode, RlpType.Logs, r[2])\n\t\t\t\t\tif (r[0].length === 32) {\n\t\t\t\t\t\t// Pre-Byzantium Receipt\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstateRoot: r[0],\n\t\t\t\t\t\t\tcumulativeBlockGasUsed: bytesToBigInt(gasUsed),\n\t\t\t\t\t\t\tlogs,\n\t\t\t\t\t\t} as PreByzantiumTxReceipt\n\t\t\t\t\t}\n\t\t\t\t\t// Post-Byzantium Receipt\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: bytesToNumber(r[0]),\n\t\t\t\t\t\tcumulativeBlockGasUsed: bytesToBigInt(gasUsed),\n\t\t\t\t\t\tlogs,\n\t\t\t\t\t} as PostByzantiumTxReceipt\n\t\t\t\t})\n\t\t\t}\n\t\t\tcase RlpType.Logs:\n\t\t\t\tif (conversion === RlpConvert.Encode) {\n\t\t\t\t\treturn Rlp.encode(value as EthjsLog[])\n\t\t\t\t}\n\t\t\t\treturn Rlp.decode(value as Uint8Array) as EthjsLog[]\n\t\t\tcase RlpType.TxHash: {\n\t\t\t\tif (conversion === RlpConvert.Encode) {\n\t\t\t\t\tconst [blockHash, txIndex] = value as TxHashIndex\n\t\t\t\t\t// TODO add numberToBytes to utils\n\t\t\t\t\treturn Rlp.encode([blockHash, hexToBytes(numberToHex(txIndex))])\n\t\t\t\t}\n\t\t\t\tconst [blockHash, txIndex] = Rlp.decode(value as Uint8Array) as unknown as rlpTxHash\n\t\t\t\treturn [blockHash, bytesToNumber(txIndex)] as TxHashIndex\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown rlp conversion')\n\t\t}\n\t}\n\n\t/**\n\t * Calculates a Bloom filter for a set of transaction logs\n\t * Used for efficient log filtering and lookups\n\t *\n\t * @param logs - The logs to include in the bloom filter\n\t * @returns A Bloom filter containing the log data\n\t * @private\n\t */\n\tprivate logsBloom(logs: rlpLog[]) {\n\t\tconst bloom = new Bloom()\n\t\tfor (let i = 0; i < logs.length; i++) {\n\t\t\tconst log = logs[i]\n\t\t\tif (!log) {\n\t\t\t\tthrow new Error('Log is empty')\n\t\t\t}\n\t\t\t// add the address\n\t\t\tbloom.add(log[0])\n\t\t\t// add the topics\n\t\t\tconst topics = log[1]\n\t\t\tfor (let q = 0; q < topics.length; q++) {\n\t\t\t\tbloom.add(topics[q] as Uint8Array)\n\t\t\t}\n\t\t}\n\t\treturn bloom\n\t}\n}\n"]}