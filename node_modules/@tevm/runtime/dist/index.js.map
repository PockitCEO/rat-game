{"version":3,"sources":["../src/generateTevmBodyDts.js","../src/generateTevmBody.js","../src/generateRuntime.js"],"names":["succeed","formatAbi"],"mappings":"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","file":"index.js","sourcesContent":["import { formatAbi } from 'abitype'\nimport { succeed } from 'effect/Effect'\n\n/**\n * Generates TypeScript declaration file (.d.ts) content for Tevm contracts.\n *\n * This function creates TypeScript type declarations for Solidity contracts,\n * including proper typing for the contract name, ABI, and optionally bytecode.\n * It also includes NatSpec documentation as JSDoc comments.\n *\n * @param {import(\"@tevm/compiler\").Artifacts} artifacts - Compiled Solidity artifacts\n *   containing ABI, bytecode, and other contract information\n * @param {boolean} includeBytecode - Whether to include bytecode in the type definitions,\n *   true for deployable contracts, false for interface-only contracts\n * @returns {import('effect/Effect').Effect<string, never, never>} - Effect that\n *   resolves to the generated TypeScript declaration file content as a string\n *\n * @example\n * ```javascript\n * import { generateDtsBody } from '@tevm/runtime'\n * import { runPromise } from 'effect/Effect'\n *\n * // Generate TypeScript declaration file content\n * const dtsContent = await runPromise(\n *   generateDtsBody(\n *     artifacts, // Solidity compilation results\n *     true       // Include bytecode\n *   )\n * )\n *\n * console.log(dtsContent)\n * ```\n *\n * @internal This function is primarily used by generateTevmBody\n */\nexport const generateDtsBody = (artifacts, includeBytecode) => {\n\treturn succeed(\n\t\t`\n\t\t${Object.entries(artifacts)\n\t\t\t.flatMap(([contractName, { abi, userdoc = {} }]) => {\n\t\t\t\t// Create contract metadata\n\t\t\t\tconst contract = {\n\t\t\t\t\tname: contractName,\n\t\t\t\t\thumanReadableAbi: formatAbi(abi),\n\t\t\t\t}\n\n\t\t\t\t// Generate JSDoc from NatSpec comments\n\t\t\t\tconst natspec = Object.entries(userdoc.methods ?? {}).map(\n\t\t\t\t\t([method, { notice }]) => ` * @property ${method} ${notice}`,\n\t\t\t\t)\n\n\t\t\t\t// Add contract-level notice if available\n\t\t\t\tif (userdoc.notice) {\n\t\t\t\t\tnatspec.unshift(` * @notice ${userdoc.notice}`)\n\t\t\t\t}\n\n\t\t\t\t// Generate type declaration for contracts with bytecode\n\t\t\t\tif (includeBytecode) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t// Define constants for name and ABI with const assertions for type safety\n\t\t\t\t\t\t`const _name${contractName} = ${JSON.stringify(contractName, null, 2)} as const;`,\n\t\t\t\t\t\t`const _abi${contractName} = ${JSON.stringify(contract.humanReadableAbi, null, 2)} as const;`,\n\n\t\t\t\t\t\t// JSDoc comments for the contract\n\t\t\t\t\t\t'/**',\n\t\t\t\t\t\t` * ${contractName} Contract (with bytecode)`,\n\t\t\t\t\t\t...natspec,\n\t\t\t\t\t\t' * @see [contract docs](https://tevm.sh/learn/contracts/) for more documentation',\n\t\t\t\t\t\t' */',\n\n\t\t\t\t\t\t// Type declaration for the contract\n\t\t\t\t\t\t`export const ${contractName}: Contract<`,\n\t\t\t\t\t\t`  typeof _name${contractName},`, // Contract name\n\t\t\t\t\t\t`  typeof _abi${contractName},`, // ABI\n\t\t\t\t\t\t'  undefined,', // Address placeholder\n\t\t\t\t\t\t'  `0x${string}`,', // Bytecode\n\t\t\t\t\t\t'  `0x${string}`,', // Deployed bytecode\n\t\t\t\t\t\t'  undefined', // Additional data - removed trailing comma\n\t\t\t\t\t\t'>;',\n\t\t\t\t\t].filter(Boolean)\n\t\t\t\t}\n\n\t\t\t\t// Generate type declaration for interface-only contracts (no bytecode)\n\t\t\t\treturn [\n\t\t\t\t\t// Define constants for ABI and name with const assertions\n\t\t\t\t\t`const _abi${contractName} = ${JSON.stringify(contract.humanReadableAbi)} as const;`,\n\t\t\t\t\t`const _name${contractName} = ${JSON.stringify(contractName)} as const;`,\n\n\t\t\t\t\t// JSDoc comments for the contract\n\t\t\t\t\t'/**',\n\t\t\t\t\t` * ${contractName} Contract (no bytecode)`,\n\t\t\t\t\t` * change file name or add file that ends in '.s.sol' extension if you wish to compile the bytecode`,\n\t\t\t\t\t' * @see [contract docs](https://tevm.sh/learn/contracts/) for more documentation',\n\t\t\t\t\t...natspec,\n\t\t\t\t\t' */',\n\n\t\t\t\t\t// Type declaration for the contract (without bytecode)\n\t\t\t\t\t`export const ${contractName}: Contract<typeof _name${contractName}, typeof _abi${contractName}, undefined, undefined, undefined, undefined>;`,\n\t\t\t\t].filter(Boolean)\n\t\t\t})\n\t\t\t.join('\\n')}\n// solc artifacts of compilation\nexport const artifacts = ${JSON.stringify(artifacts, null, 2)};\n`,\n\t)\n}\n","import { formatAbi } from 'abitype'\nimport { succeed } from 'effect/Effect'\nimport { generateDtsBody } from './generateTevmBodyDts.js'\n\n/**\n * Generates the body of a JavaScript/TypeScript module for Tevm contracts.\n *\n * This function transforms Solidity compilation artifacts into JavaScript/TypeScript code\n * that creates Tevm Contract objects. It handles different output formats (cjs, ts, mjs)\n * and can include or exclude bytecode based on the provided options.\n *\n * For TypeScript declaration files (.d.ts), it delegates to generateDtsBody\n * which creates appropriate type definitions.\n *\n * @param {import(\"@tevm/compiler\").Artifacts} artifacts - Compiled Solidity artifacts\n *   containing ABI, bytecode, and other contract information\n * @param {import('./types.js').ModuleType} moduleType - The target module format\n *   ('cjs', 'dts', 'ts', or 'mjs')\n * @param {boolean} includeBytecode - Whether to include bytecode in the output,\n *   true for script/deployable contracts, false for interface-only contracts\n * @returns {import('effect/Effect').Effect<string, never, never>} - Effect that\n *   resolves to the generated module body code as a string\n *\n * @example\n * ```javascript\n * import { generateTevmBody } from '@tevm/runtime'\n * import { runPromise } from 'effect/Effect'\n *\n * // Generate the body of a TypeScript module\n * const body = await runPromise(\n *   generateTevmBody(\n *     artifacts, // Solidity compilation results\n *     'ts',      // Generate TypeScript code\n *     true       // Include bytecode\n *   )\n * )\n *\n * console.log(body)\n * ```\n *\n * @internal This function is primarily used by generateRuntime\n */\nexport const generateTevmBody = (artifacts, moduleType, includeBytecode) => {\n\t// For TypeScript declaration files, delegate to generateDtsBody\n\tif (moduleType === 'dts') {\n\t\treturn generateDtsBody(artifacts, includeBytecode)\n\t}\n\n\t// Generate JavaScript/TypeScript code for the contracts\n\treturn succeed(\n\t\tObject.entries(artifacts)\n\t\t\t.flatMap(([contractName, { abi, userdoc = {}, evm }], i) => {\n\t\t\t\t// Create the contract configuration object\n\t\t\t\tconst contract = JSON.stringify(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: contractName,\n\t\t\t\t\t\thumanReadableAbi: formatAbi(abi),\n\t\t\t\t\t\t// Include bytecode if requested and available (checking for empty string for interfaces)\n\t\t\t\t\t\t...(includeBytecode\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tbytecode:\n\t\t\t\t\t\t\t\t\t\tevm?.bytecode?.object && evm.bytecode.object !== '' ? `0x${evm.bytecode.object}` : undefined,\n\t\t\t\t\t\t\t\t\tdeployedBytecode:\n\t\t\t\t\t\t\t\t\t\tevm?.deployedBytecode?.object && evm.deployedBytecode.object !== ''\n\t\t\t\t\t\t\t\t\t\t\t? `0x${evm.deployedBytecode.object}`\n\t\t\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {}),\n\t\t\t\t\t},\n\t\t\t\t\tnull,\n\t\t\t\t\t2,\n\t\t\t\t)\n\n\t\t\t\t// Generate JSDoc documentation from NatSpec comments\n\t\t\t\tconst natspec = Object.entries(userdoc.methods ?? {}).map(\n\t\t\t\t\t([method, { notice }]) => ` * @property ${method} ${notice}`,\n\t\t\t\t)\n\n\t\t\t\t// Add contract-level documentation if available\n\t\t\t\tif (userdoc.notice) {\n\t\t\t\t\tnatspec.unshift(` * ${userdoc.notice}`)\n\t\t\t\t}\n\n\t\t\t\t// Add link to additional documentation\n\t\t\t\tnatspec.push(' * @see [contract docs](https://tevm.sh/learn/contracts/) for more documentation')\n\t\t\t\tnatspec.unshift('/**')\n\t\t\t\tnatspec.push(' */')\n\n\t\t\t\t// Generate CommonJS format\n\t\t\t\tif (moduleType === 'cjs') {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t`const _${contractName} = ${contract};`,\n\t\t\t\t\t\t...natspec,\n\t\t\t\t\t\t`module.exports.${contractName} = createContract(_${contractName});`,\n\t\t\t\t\t\ti === 0 ? `module.exports.artifacts = ${JSON.stringify(artifacts, null, 2)};` : '',\n\t\t\t\t\t]\n\t\t\t\t}\n\n\t\t\t\t// Generate TypeScript format with const assertion\n\t\t\t\tif (moduleType === 'ts') {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t`const _${contractName} = ${contract} as const`,\n\t\t\t\t\t\t...natspec,\n\t\t\t\t\t\t`export const ${contractName} = createContract(_${contractName});`,\n\t\t\t\t\t\ti === 0 ? `export const artifacts = ${JSON.stringify(artifacts, null, 2)};` : '',\n\t\t\t\t\t]\n\t\t\t\t}\n\n\t\t\t\t// Generate ES module format\n\t\t\t\treturn [\n\t\t\t\t\t`const _${contractName} = ${contract};`,\n\t\t\t\t\t...natspec,\n\t\t\t\t\t`export const ${contractName} = createContract(_${contractName});`,\n\t\t\t\t\ti === 0 ? `export const artifacts = ${JSON.stringify(artifacts, null, 2)};` : '',\n\t\t\t\t]\n\t\t\t})\n\t\t\t.join('\\n'),\n\t)\n}\n","import { die, map } from 'effect/Effect'\nimport { generateTevmBody } from './generateTevmBody.js'\n\n/**\n * Map of import statements by module type and contract type.\n * This determines the appropriate import statement based on:\n * 1. Whether it's a regular contract or a script contract (with bytecode)\n * 2. The target module format (cjs, ts, dts, mjs)\n * 3. The Tevm contract package to import from\n *\n * @param {'tevm/contract' | '@tevm/contract'} contractPackage - Package to import contracts from\n * @returns {{\n *   contract: {\n *     cjs: string,\n *     dts: string,\n *     ts: string,\n *     mjs: string\n *   },\n *   script: {\n *     cjs: string,\n *     dts: string,\n *     ts: string,\n *     mjs: string\n *   }\n * }} A nested object mapping contract types and module types to import statements\n */\nconst importsByModuleType = (contractPackage) => ({\n\tcontract: {\n\t\tcjs: `const { createContract } = require('${contractPackage}')`,\n\t\tdts: `import type { Contract } from '${contractPackage}'`,\n\t\tts: `import { createContract } from '${contractPackage}'`,\n\t\tmjs: `import { createContract } from '${contractPackage}'`,\n\t},\n\tscript: {\n\t\tcjs: `const { createContract } = require('${contractPackage}')`,\n\t\tdts: `import type { Contract } from '${contractPackage}'`,\n\t\tts: `import { createContract } from '${contractPackage}'`,\n\t\tmjs: `import { createContract } from '${contractPackage}'`,\n\t},\n})\n\n/**\n * Generates a complete runtime module from Solidity compilation artifacts.\n *\n * This function combines the appropriate import statements with the generated\n * contract body code to create a complete module that exports the Tevm Contract\n * objects. It supports different output formats and can optionally include\n * bytecode for deployable contracts.\n *\n * @param {import(\"@tevm/compiler\").Artifacts} artifacts - Compiled Solidity artifacts\n *   containing ABI, bytecode, and other contract information\n * @param {import('./types.js').ModuleType} moduleType - The target module format\n *   ('cjs', 'dts', 'ts', or 'mjs')\n * @param {boolean} includeBytecode - Whether to include bytecode in the output,\n *   true for script/deployable contracts, false for interface-only contracts\n * @param {'tevm/contract' | '@tevm/contract'} tevmPackage - Package name to import\n *   the createContract function from\n * @returns {import('effect/Effect').Effect<string, never, never>} - Effect that\n *   resolves to the generated module code as a string\n * @throws {Error} If no artifacts are provided or if an invalid module type is specified\n *\n * @example\n * ```javascript\n * import { generateRuntime } from '@tevm/runtime'\n * import { runPromise } from 'effect/Effect'\n *\n * // Generate TypeScript module from artifacts\n * const code = await runPromise(\n *   generateRuntime(\n *     artifacts,         // Solidity compilation results\n *     'ts',              // Generate TypeScript code\n *     true,              // Include bytecode\n *     '@tevm/contract'   // Import from this package\n *   )\n * )\n *\n * console.log(code)\n * ```\n */\nexport const generateRuntime = (artifacts, moduleType, includeBytecode, tevmPackage) => {\n\t// Validate that artifacts exist\n\tif (!artifacts || Object.keys(artifacts).length === 0) {\n\t\treturn die('No artifacts provided to generateRuntime')\n\t}\n\n\t// Determine the appropriate import statements based on module type and bytecode inclusion\n\tconst contractType = includeBytecode ? 'script' : 'contract'\n\tconst imports = importsByModuleType(tevmPackage)[contractType][moduleType]\n\n\t// Validate the module type\n\tif (!imports) {\n\t\treturn die(`Unknown module type: ${moduleType}. Valid module types include 'cjs', 'dts', 'ts', and 'mjs'`)\n\t}\n\n\t// Generate the contract body and combine with imports\n\treturn generateTevmBody(artifacts, moduleType, includeBytecode).pipe(map((body) => [imports, body].join('\\n')))\n}\n"]}