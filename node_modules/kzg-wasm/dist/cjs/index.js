"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadKZG = void 0;
const util_js_1 = require("./util.js");
const kzg_js_1 = require("./kzg.js");
const trustedSetup_js_1 = require("./trustedSetup.js");
/**
 * Initialization function that instantiates WASM code and returns an object matching the `KZG` interface exposed by `@ethereumjs/util`
 *
 * @param trustedSetup Optional trusted setup, otherwise official KZG setup from the KZG ceremony is used
 *
 * @returns object - the KZG methods required for all 4844 related operations
 */
const loadKZG = async (trustedSetup = trustedSetup_js_1.default) => {
    const module = await (0, kzg_js_1.default)();
    const loadTrustedSetupWasm = module.cwrap('load_trusted_setup_from_wasm', 'number', ['string', 'number', 'string', 'number']);
    const freeTrustedSetup = module.cwrap('free_trusted_setup_wasm', null, []);
    const blobToKZGCommitmentWasm = module.cwrap('blob_to_kzg_commitment_wasm', 'string', ['array']);
    const computeBlobKZGProofWasm = module.cwrap('compute_blob_kzg_proof_wasm', 'string', ['array', 'array']);
    const verifyBlobKZGProofWasm = module.cwrap('verify_blob_kzg_proof_wasm', 'string', ['array', 'array', 'array']);
    const verifyKZGProofWasm = module.cwrap('verify_kzg_proof_wasm', 'string', ['array', 'array', 'array', 'array']);
    /**
     *
     * @param trustedSetup - an optional trusted setup parameter provided by the user
     * @returns 0 if loaded successfully or 1 otherwise
     */
    const loadTrustedSetup = (trustedSetup = trustedSetup_js_1.default) => {
        return loadTrustedSetupWasm(trustedSetup.g1, trustedSetup.n1, trustedSetup.g2, trustedSetup.n2);
    };
    /**
     *
     * @param blob - a blob of data formatted as prefixed hex string containing 4096 big endian KZG field elements
     * @returns a KZG commitment corresponding to the input blob formatted as a 48 byte prefixed hex string
     */
    const blobToKZGCommitment = (blob) => {
        const blobHex = '0x' + blobToKZGCommitmentWasm((0, util_js_1.hexToBytes)(blob));
        return blobHex;
    };
    /**
     *
     * @param blob  - a blob of data formatted as a flattened prefixed hex string of 4096 big endian KZG field elements
     * @param commitment - a KZG commitment corresponding to a blob formatted as a 48 byte prefixed hex string
     * @returns a 48 byte KZG proof as prefixed hex string corresponding to the blob and KZG commitment
     */
    const computeBlobKZGProof = (blob, commitment) => {
        const proofHex = '0x' + computeBlobKZGProofWasm((0, util_js_1.hexToBytes)(blob), (0, util_js_1.hexToBytes)(commitment));
        return proofHex;
    };
    /**
     *
     * @param blobs - an array of blobs
     * @param commitments - an array of corresponding commitments
     * @param proofs - an array of corresponding KZG proofs
     * @returns returns true if all proofs are verified against their blobs and commitments; false otherwise
     */
    const verifyBlobKZGProofBatch = (blobs, commitments, proofs) => {
        if (blobs.length !== commitments.length && commitments.length !== proofs.length) {
            throw new Error('number of blobs, commitments, and proofs, must match');
        }
        for (let x = 0; x < blobs.length; x++) {
            const res = verifyBlobKZGProofWasm((0, util_js_1.hexToBytes)(blobs[x]), (0, util_js_1.hexToBytes)(commitments[x]), (0, util_js_1.hexToBytes)(proofs[x]));
            if (res !== 'true')
                return false;
        }
        return true;
    };
    /**
     *
     * @param blob - a blob of data formatted as a flattened prefixed hex string of 4096 big endian KZG field elements
     * @param commitment - a 48 byte KZG commitment corresponding to the blob formatted as a prefixed hex string
     * @param proof - a 48 byte KZG proof corresponding to the blob and commitment formatted as a prefixed hex string
     * @returns true if proof is verified; false otherwise
     */
    const verifyBlobKZGProof = (blob, commitment, proof) => {
        const res = verifyBlobKZGProofWasm((0, util_js_1.hexToBytes)(blob), (0, util_js_1.hexToBytes)(commitment), (0, util_js_1.hexToBytes)(proof));
        return res === 'true';
    };
    /**
     *
     * @param commitment - a KZG commitment corresponding to two points z and y
     * @param z - an input point
     * @param y - the output point corresponding to the proof and commitment
     * @param proof
     * @returns true if proof is verified; false otherwise
     */
    const verifyKZGProof = (commitment, z, y, proof) => {
        const res = verifyKZGProofWasm((0, util_js_1.hexToBytes)(commitment), (0, util_js_1.hexToBytes)(z), (0, util_js_1.hexToBytes)(y), (0, util_js_1.hexToBytes)(proof));
        return res === 'true';
    };
    loadTrustedSetup(trustedSetup);
    return {
        loadTrustedSetup, freeTrustedSetup, blobToKZGCommitment, computeBlobKZGProof, verifyBlobKZGProofBatch, verifyKZGProof, verifyBlobKZGProof
    };
};
exports.loadKZG = loadKZG;
//# sourceMappingURL=index.js.map